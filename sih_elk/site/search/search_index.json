{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the APT Detection Project This project provides a comprehensive and validated set of threat detection rules for the ELK Stack (Elasticsearch, Logstash, & Kibana) , designed to identify adversary behaviors across the entire Advanced Persistent Threat (APT) lifecycle. The primary goal is to equip security analysts and threat hunters with practical, high-fidelity detection logic mapped directly to the MITRE ATT&CK\u00ae framework . Each rule is built from a structured workflow of threat simulation, log analysis, and rigorous validation to ensure accuracy and minimize false positives. Getting Started If you're new to the project, here's the recommended path: Understand the Methodology : Read the Project Workflow page to learn about the structured process used to create and validate each detection rule. Explore the Lifecycle : Browse the APT Threat Lifecycle to see how detections are mapped to specific adversary tactics. Find a Rule : Go to the Rules Created section for a complete list of all detection rules with their KQL queries. \ud83d\udcd6 Documentation Structure This documentation is organized into four main sections to help you find what you need quickly. Environment Setup This section provides detailed instructions and configurations for setting up the entire lab environment. Virtual Machine Setup ELK Setup Atomic Red Team Setup Project Workflow This section details the end-to-end methodology for rule development. It covers the complete cycle from threat simulation with Atomic Red Team (Windows) to log analysis, KQL rule creation, and final validation. View the Full Workflow APT Threat Lifecycle This is the strategic overview of the project. It breaks down a sophisticated cyberattack into 12 distinct stages based on the MITRE ATT&CK framework and links to the relevant detections for each stage. Explore the Lifecycle Rules Created This is the central repository for all detection logic. It contains a list of every finalized rule, its purpose, and the KQL query ready for deployment in Kibana. Browse All Rules","title":"Introduction"},{"location":"#welcome-to-the-apt-detection-project","text":"This project provides a comprehensive and validated set of threat detection rules for the ELK Stack (Elasticsearch, Logstash, & Kibana) , designed to identify adversary behaviors across the entire Advanced Persistent Threat (APT) lifecycle. The primary goal is to equip security analysts and threat hunters with practical, high-fidelity detection logic mapped directly to the MITRE ATT&CK\u00ae framework . Each rule is built from a structured workflow of threat simulation, log analysis, and rigorous validation to ensure accuracy and minimize false positives.","title":"Welcome to the APT Detection Project"},{"location":"#getting-started","text":"If you're new to the project, here's the recommended path: Understand the Methodology : Read the Project Workflow page to learn about the structured process used to create and validate each detection rule. Explore the Lifecycle : Browse the APT Threat Lifecycle to see how detections are mapped to specific adversary tactics. Find a Rule : Go to the Rules Created section for a complete list of all detection rules with their KQL queries.","title":"Getting Started"},{"location":"#documentation-structure","text":"This documentation is organized into four main sections to help you find what you need quickly.","title":"\ud83d\udcd6 Documentation Structure"},{"location":"#environment-setup","text":"This section provides detailed instructions and configurations for setting up the entire lab environment. Virtual Machine Setup ELK Setup Atomic Red Team Setup","title":"Environment Setup"},{"location":"#project-workflow","text":"This section details the end-to-end methodology for rule development. It covers the complete cycle from threat simulation with Atomic Red Team (Windows) to log analysis, KQL rule creation, and final validation. View the Full Workflow","title":"Project Workflow"},{"location":"#apt-threat-lifecycle","text":"This is the strategic overview of the project. It breaks down a sophisticated cyberattack into 12 distinct stages based on the MITRE ATT&CK framework and links to the relevant detections for each stage. Explore the Lifecycle","title":"APT Threat Lifecycle"},{"location":"#rules-created","text":"This is the central repository for all detection logic. It contains a list of every finalized rule, its purpose, and the KQL query ready for deployment in Kibana. Browse All Rules","title":"Rules Created"},{"location":"apt_lifecycle/","text":"APT Threat Lifecycle & Detection Coverage This document outlines the stages of an Advanced Persistent Threat (APT) lifecycle, mapped to the MITRE ATT&CK framework. Each stage includes a description of the adversary's objective, a concise detection strategy, a placeholder for your rule, and a link to the relevant Atomic Red Team test. 1. Reconnaissance (T1595: Active Scanning) Description: Adversaries probe victim networks and systems to identify potential vulnerabilities, open ports, and running services. This helps them map the target's external footprint before launching an attack. Detection Strategy: Identifies brute-force patterns by detecting a high volume of failed logins from a single IP, a common byproduct of active scanning. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1595.003 - Scanning IP Blocks 2. Initial Access (T1566: Phishing) Description: Attackers send fraudulent emails containing malicious attachments or links to gain a foothold in the network. Detection Strategy: Detects anomalous parent-child process relationships, such as an email client spawning a script or executable. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1566.001 - Spearphishing Attachment 3. Execution (T1059: Command and Scripting Interpreter) Description: Adversaries use command-line interfaces (like PowerShell) to execute malicious commands and scripts. Detection Strategy: Alerts on PowerShell execution using command-line flags ( -enc , -encodedcommand ) designed to run obfuscated or encoded commands. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1059 - Command and Scripting Interpreter 4. Persistence (T1547: Boot or Logon Autostart Execution) Description: Attackers configure malware to run automatically by modifying registry keys, startup folders, or logon scripts. Detection Strategy: Monitors for modifications to common registry \"Run\" keys. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1547 - Boot or Logon Autostart Execution 5. Privilege Escalation (T1548: Abuse Elevation Control Mechanism) Description: Adversaries exploit system mechanisms that manage user permissions, such as UAC on Windows, to gain higher-level privileges. Detection Strategy: Detects a known UAC bypass by identifying when fodhelper.exe anomalously spawns a command shell. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1548.001 - Setuid and Setgid 6. Defense Evasion (T1027: Obfuscated Files or Information) Description: Attackers conceal their malicious code to avoid detection, often using encryption, encoding, or packing. Detection Strategy: Flags the use of certutil.exe with the -decode flag. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1027 - Obfuscated Files or Information 7. Credential Access (T1003: OS Credential Dumping) Description: Extracting account login material from the OS, often by dumping memory from the LSASS process. Detection Strategy: Detects unauthorized processes attempting to access the memory of lsass.exe . Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1003 - OS Credential Dumping 8. Discovery (T1082: System Information Discovery) Description: Attackers collect detailed information about the compromised system. Detection Strategy: Looks for a rapid burst of system discovery commands from a single process. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1082 - System Information Discovery 9. Lateral Movement (T1021: Remote Services) Description: Adversaries use legitimate remote access tools like RDP to move between systems. Detection Strategy: Identifies non-standard RDP connections by flagging sessions not initiated by svchost.exe . Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1021.001 - Remote Desktop Protocol 10. Collection (T1119: Automated Collection) Description: Attackers use scripts to automatically search for and gather files containing sensitive data. Detection Strategy: Alerts on the rapid creation of numerous sensitive file types by a shell process. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1119 - Automated Collection 11. Command and Control (C2) (T1071: Application Layer Protocol) Description: Adversaries use common protocols like HTTP to blend C2 traffic with legitimate activity. Detection Strategy: Flags network connections from non-browser processes to common code-hosting sites. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1071 - Application Layer Protocol 12. Exfiltration (T1048: Exfiltration Over Alternative Protocol) Description: Data is stolen by transmitting it over an alternative protocol, such as DNS. Detection Strategy: Detects potential DNS tunneling by identifying abnormally long DNS queries. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1048 - Exfiltration Over Alternative Protocol","title":"APT lifecycle"},{"location":"apt_lifecycle/#apt-threat-lifecycle-detection-coverage","text":"This document outlines the stages of an Advanced Persistent Threat (APT) lifecycle, mapped to the MITRE ATT&CK framework. Each stage includes a description of the adversary's objective, a concise detection strategy, a placeholder for your rule, and a link to the relevant Atomic Red Team test.","title":"APT Threat Lifecycle &amp; Detection Coverage"},{"location":"apt_lifecycle/#1-reconnaissance-t1595-active-scanning","text":"Description: Adversaries probe victim networks and systems to identify potential vulnerabilities, open ports, and running services. This helps them map the target's external footprint before launching an attack. Detection Strategy: Identifies brute-force patterns by detecting a high volume of failed logins from a single IP, a common byproduct of active scanning. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1595.003 - Scanning IP Blocks","title":"1. Reconnaissance (T1595: Active Scanning)"},{"location":"apt_lifecycle/#2-initial-access-t1566-phishing","text":"Description: Attackers send fraudulent emails containing malicious attachments or links to gain a foothold in the network. Detection Strategy: Detects anomalous parent-child process relationships, such as an email client spawning a script or executable. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1566.001 - Spearphishing Attachment","title":"2. Initial Access (T1566: Phishing)"},{"location":"apt_lifecycle/#3-execution-t1059-command-and-scripting-interpreter","text":"Description: Adversaries use command-line interfaces (like PowerShell) to execute malicious commands and scripts. Detection Strategy: Alerts on PowerShell execution using command-line flags ( -enc , -encodedcommand ) designed to run obfuscated or encoded commands. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1059 - Command and Scripting Interpreter","title":"3. Execution (T1059: Command and Scripting Interpreter)"},{"location":"apt_lifecycle/#4-persistence-t1547-boot-or-logon-autostart-execution","text":"Description: Attackers configure malware to run automatically by modifying registry keys, startup folders, or logon scripts. Detection Strategy: Monitors for modifications to common registry \"Run\" keys. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1547 - Boot or Logon Autostart Execution","title":"4. Persistence (T1547: Boot or Logon Autostart Execution)"},{"location":"apt_lifecycle/#5-privilege-escalation-t1548-abuse-elevation-control-mechanism","text":"Description: Adversaries exploit system mechanisms that manage user permissions, such as UAC on Windows, to gain higher-level privileges. Detection Strategy: Detects a known UAC bypass by identifying when fodhelper.exe anomalously spawns a command shell. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1548.001 - Setuid and Setgid","title":"5. Privilege Escalation (T1548: Abuse Elevation Control Mechanism)"},{"location":"apt_lifecycle/#6-defense-evasion-t1027-obfuscated-files-or-information","text":"Description: Attackers conceal their malicious code to avoid detection, often using encryption, encoding, or packing. Detection Strategy: Flags the use of certutil.exe with the -decode flag. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1027 - Obfuscated Files or Information","title":"6. Defense Evasion (T1027: Obfuscated Files or Information)"},{"location":"apt_lifecycle/#7-credential-access-t1003-os-credential-dumping","text":"Description: Extracting account login material from the OS, often by dumping memory from the LSASS process. Detection Strategy: Detects unauthorized processes attempting to access the memory of lsass.exe . Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1003 - OS Credential Dumping","title":"7. Credential Access (T1003: OS Credential Dumping)"},{"location":"apt_lifecycle/#8-discovery-t1082-system-information-discovery","text":"Description: Attackers collect detailed information about the compromised system. Detection Strategy: Looks for a rapid burst of system discovery commands from a single process. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1082 - System Information Discovery","title":"8. Discovery (T1082: System Information Discovery)"},{"location":"apt_lifecycle/#9-lateral-movement-t1021-remote-services","text":"Description: Adversaries use legitimate remote access tools like RDP to move between systems. Detection Strategy: Identifies non-standard RDP connections by flagging sessions not initiated by svchost.exe . Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1021.001 - Remote Desktop Protocol","title":"9. Lateral Movement (T1021: Remote Services)"},{"location":"apt_lifecycle/#10-collection-t1119-automated-collection","text":"Description: Attackers use scripts to automatically search for and gather files containing sensitive data. Detection Strategy: Alerts on the rapid creation of numerous sensitive file types by a shell process. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1119 - Automated Collection","title":"10. Collection (T1119: Automated Collection)"},{"location":"apt_lifecycle/#11-command-and-control-c2-t1071-application-layer-protocol","text":"Description: Adversaries use common protocols like HTTP to blend C2 traffic with legitimate activity. Detection Strategy: Flags network connections from non-browser processes to common code-hosting sites. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1071 - Application Layer Protocol","title":"11. Command and Control (C2) (T1071: Application Layer Protocol)"},{"location":"apt_lifecycle/#12-exfiltration-t1048-exfiltration-over-alternative-protocol","text":"Description: Data is stolen by transmitting it over an alternative protocol, such as DNS. Detection Strategy: Detects potential DNS tunneling by identifying abnormally long DNS queries. Detection Rule (Windows & Ubuntu) Atomic Red Team Reference (Windows only): T1048 - Exfiltration Over Alternative Protocol","title":"12. Exfiltration (T1048: Exfiltration Over Alternative Protocol)"},{"location":"overall_workflow/","text":"Threat Detection Rule Development Workflow This project implements a structured, six-stage workflow for the end-to-end creation, testing, and validation of security detection rules across multiple operating systems. 1. Environment Setup & Integration This foundational stage involves preparing the complete analysis pipeline for both Windows and Ubuntu endpoints. Deploy Infrastructure : Set up the central ELK Stack and the target virtual machines (Windows 11 and Ubuntu). Install Agents : Deploy agents on the target systems to collect security logs (e.g., Winlogbeat for Windows, Elastic Agent for Ubuntu). Configure Data Pipeline : Ensure logs from both operating systems are successfully ingested and parsed by Logstash and Elasticsearch. 2. Threat Simulation & Log Generation This stage creates the necessary data by emulating adversary behavior on the appropriate target OS. Execute Tests : Run controlled attack simulations on the target systems, using Atomic Red Team for Windows and custom rules or scripts for Ubuntu. Generate Logs : Trigger the creation of detailed telemetry and security events on the target systems. 3. Log Analysis & Pattern Identification This stage focuses on finding the \"signal in the noise\" within the logs collected from all endpoints. Isolate Events : Use Kibana to query and filter logs, pinpointing the exact events generated by the simulation on either the Windows or Ubuntu host. Identify Indicators : Analyze key log fields (e.g., process command lines, file paths, user accounts) to find unique patterns that characterize the malicious activity. 4. KQL Rule Development This stage translates the analytical findings into a functional detection query. Translate Logic to KQL : Convert the identified patterns into a precise Kibana Query Language (KQL) query. Define Rule Logic : The KQL query forms the core logic that will be used to trigger a security alert, regardless of the source operating system. 5. Rule Validation & Finalization This final, iterative stage ensures the rule is accurate, reliable, and ready for a multi-OS operational environment. Iterative Tuning : Test the draft rule against historical log data from both Windows and Ubuntu. Refine the KQL query to minimize false positives (benign alerts) and eliminate false negatives (missed detections). Assign Risk Score : Once the rule is stable, apply a numerical score to classify its severity and aid in alert prioritization. Live Validation : Re-run the original simulation on the appropriate target\u2014the Atomic Red Team test on Windows or the custom rule on Ubuntu\u2014to confirm the finalized rule generates a real-time, accurate alert in the Kibana Security App.","title":"Overall Workflow"},{"location":"overall_workflow/#threat-detection-rule-development-workflow","text":"This project implements a structured, six-stage workflow for the end-to-end creation, testing, and validation of security detection rules across multiple operating systems.","title":"Threat Detection Rule Development Workflow"},{"location":"overall_workflow/#1-environment-setup-integration","text":"This foundational stage involves preparing the complete analysis pipeline for both Windows and Ubuntu endpoints. Deploy Infrastructure : Set up the central ELK Stack and the target virtual machines (Windows 11 and Ubuntu). Install Agents : Deploy agents on the target systems to collect security logs (e.g., Winlogbeat for Windows, Elastic Agent for Ubuntu). Configure Data Pipeline : Ensure logs from both operating systems are successfully ingested and parsed by Logstash and Elasticsearch.","title":"1. Environment Setup &amp; Integration"},{"location":"overall_workflow/#2-threat-simulation-log-generation","text":"This stage creates the necessary data by emulating adversary behavior on the appropriate target OS. Execute Tests : Run controlled attack simulations on the target systems, using Atomic Red Team for Windows and custom rules or scripts for Ubuntu. Generate Logs : Trigger the creation of detailed telemetry and security events on the target systems.","title":"2. Threat Simulation &amp; Log Generation"},{"location":"overall_workflow/#3-log-analysis-pattern-identification","text":"This stage focuses on finding the \"signal in the noise\" within the logs collected from all endpoints. Isolate Events : Use Kibana to query and filter logs, pinpointing the exact events generated by the simulation on either the Windows or Ubuntu host. Identify Indicators : Analyze key log fields (e.g., process command lines, file paths, user accounts) to find unique patterns that characterize the malicious activity.","title":"3. Log Analysis &amp; Pattern Identification"},{"location":"overall_workflow/#4-kql-rule-development","text":"This stage translates the analytical findings into a functional detection query. Translate Logic to KQL : Convert the identified patterns into a precise Kibana Query Language (KQL) query. Define Rule Logic : The KQL query forms the core logic that will be used to trigger a security alert, regardless of the source operating system.","title":"4. KQL Rule Development"},{"location":"overall_workflow/#5-rule-validation-finalization","text":"This final, iterative stage ensures the rule is accurate, reliable, and ready for a multi-OS operational environment. Iterative Tuning : Test the draft rule against historical log data from both Windows and Ubuntu. Refine the KQL query to minimize false positives (benign alerts) and eliminate false negatives (missed detections). Assign Risk Score : Once the rule is stable, apply a numerical score to classify its severity and aid in alert prioritization. Live Validation : Re-run the original simulation on the appropriate target\u2014the Atomic Red Team test on Windows or the custom rule on Ubuntu\u2014to confirm the finalized rule generates a real-time, accurate alert in the Kibana Security App.","title":"5. Rule Validation &amp; Finalization"},{"location":"rules/","text":"Detection Rule Repository This page serves as the central repository for all detection rules developed for this project. Each rule is mapped to a specific MITRE ATT&CK\u00ae tactic and technique, and the link will take you to a detailed page with the KQL query and implementation notes. All Rules Rule Name MITRE ATT&CK Tactic Technique ID Description Active Scanning Reconnaissance T1595 Detects brute-force patterns indicative of network scanning. Phishing Initial Access T1566 Identifies email clients spawning suspicious child processes. Command and Scripting Interpreter Execution T1059 Flags PowerShell execution with encoded command flags. Boot or Logon Autostart Execution Persistence T1547 Monitors for modifications to common registry \"Run\" keys. Abuse Elevation Control Mechanism Privilege Escalation T1548 Detects a known UAC bypass using fodhelper.exe . Obfuscated Files or Information Defense Evasion T1027 Alerts on the use of certutil.exe to decode files. OS Credential Dumping Credential Access T1003 Identifies unauthorized processes accessing lsass.exe memory. System Information Discovery Discovery T1082 Looks for a rapid burst of system discovery commands. Remote Services Lateral Movement T1021 Flags non-standard RDP connections. Automated Collection Collection T1119 Detects rapid creation of sensitive file types by a shell. Application Layer Protocol Command and Control T1071 Flags non-browser processes connecting to code-hosting sites. Exfiltration Over Alternative Protocol Exfiltration T1048 Detects abnormally long DNS queries indicative of tunneling. Note : Click on any rule name to view its detailed documentation, including the full KQL query, data source requirements, and validation steps.","title":"Rules"},{"location":"rules/#detection-rule-repository","text":"This page serves as the central repository for all detection rules developed for this project. Each rule is mapped to a specific MITRE ATT&CK\u00ae tactic and technique, and the link will take you to a detailed page with the KQL query and implementation notes.","title":"Detection Rule Repository"},{"location":"rules/#all-rules","text":"Rule Name MITRE ATT&CK Tactic Technique ID Description Active Scanning Reconnaissance T1595 Detects brute-force patterns indicative of network scanning. Phishing Initial Access T1566 Identifies email clients spawning suspicious child processes. Command and Scripting Interpreter Execution T1059 Flags PowerShell execution with encoded command flags. Boot or Logon Autostart Execution Persistence T1547 Monitors for modifications to common registry \"Run\" keys. Abuse Elevation Control Mechanism Privilege Escalation T1548 Detects a known UAC bypass using fodhelper.exe . Obfuscated Files or Information Defense Evasion T1027 Alerts on the use of certutil.exe to decode files. OS Credential Dumping Credential Access T1003 Identifies unauthorized processes accessing lsass.exe memory. System Information Discovery Discovery T1082 Looks for a rapid burst of system discovery commands. Remote Services Lateral Movement T1021 Flags non-standard RDP connections. Automated Collection Collection T1119 Detects rapid creation of sensitive file types by a shell. Application Layer Protocol Command and Control T1071 Flags non-browser processes connecting to code-hosting sites. Exfiltration Over Alternative Protocol Exfiltration T1048 Detects abnormally long DNS queries indicative of tunneling. Note : Click on any rule name to view its detailed documentation, including the full KQL query, data source requirements, and validation steps.","title":"All Rules"},{"location":"rules_created/abuse_elevation_control_mechanism/","text":"Detection Rule: Privilege Escalation via Fodhelper UAC Bypass Rule ID: 6727ae6d-21ee-40aa-b0a1-bbcb1c58f8cf Rule Name: Privilege Escalation (T1548: Abuse Elevation Control Mechanism) MITRE ATT&CK Tactic: Privilege Escalation MITRE ATT&CK Technique: T1548.002, Abuse Elevation Control Mechanism: Bypass User Account Control Description This rule detects adversaries abusing built-in elevation control mechanisms to execute code with higher privileges. This is a critical step for an attacker to move from a standard user context to an administrator or root context, granting them full control over the system. On Windows, a common technique is to bypass User Account Control (UAC) by exploiting legitimate applications that are allowed to auto-elevate, such as fodhelper.exe . On Linux, a precursor to privilege escalation is often discovering what permissions the current user has, which is frequently done using the sudo -l command. Rule Derivation from Log Analysis The logic for this rule is derived by identifying adversary actions that are highly indicative of an attempt to gain higher privileges. 1. Defining the Behavior : The goal is to detect either the active bypass of a security control or the reconnaissance that precedes it. Windows (Bypass) : The focus is on an untrusted process launching a trusted, auto-elevating executable like fodhelper.exe . This anomalous parent-child relationship is a strong indicator of a hijack. Linux (Discovery) : The focus is on an adversary checking what commands they can run with elevated privileges. The sudo -l command is a specific artifact of this discovery behavior. 2. Translating Behavior to Log Fields : Windows : The child process ( process.name ) and its parent ( process.parent.name ) are analyzed. Linux : The process ( process.name ) and its specific arguments ( process.args ) are inspected. 3. Constructing the Rule : The Windows query identifies the execution of fodhelper.exe and then excludes known legitimate parent processes, flagging any remaining instance as suspicious. The Ubuntu query looks for the specific combination of the sudo process being run with the -l argument, a high-fidelity indicator of privilege discovery. Detection Logic Windows: Fodhelper UAC Bypass This is a query-based rule that triggers on a single process creation event matching a specific parent-child relationship. Query : process.name : \"fodhelper.exe\" AND NOT (process.parent.name : \"explorer.exe\" OR process.parent.name : \"svchost.exe\") Query Explanation : The query logic identifies instances where fodhelper.exe is executed by a process other than its expected parent processes. - The process.name : \"fodhelper.exe\" clause selects all events where the fodhelper.exe process is created. - The AND NOT (...) clause then filters out these events if the parent process ( process.parent.name ) is either explorer.exe or svchost.exe , which are considered legitimate initiators. The rule triggers an alert for any fodhelper.exe process creation event that does not match the exclusion criteria, indicating a high probability of a UAC bypass attempt. Ubuntu: Sudo Permissions Discovery This query looks for a user attempting to list their sudo permissions, which is often a precursor to privilege escalation. Query : process.name:\"sudo\" and process.args:\"-l\" Explanation : This query alerts when the sudo command is run with the -l (list) flag. Before attempting to escalate privileges, an attacker will almost always use this command to discover what commands they are permitted to run as root. Simulation and Validation Windows This rule can be validated by simulating the registry hijack and execution flow used in this UAC bypass technique. Test Command (PowerShell) : reg add HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /v \"\" /d \"C:\\Windows\\System32\\cmd.exe\" /f reg add HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /v \"DelegateExecute\" /d \"\" /f fodhelper.exe This sequence of commands first modifies the registry key associated with the ms-settings URI handler, pointing it to the Command Prompt ( cmd.exe ). When fodhelper.exe is executed in the final step, it attempts to open the settings handler, but because of the registry modification, it launches cmd.exe with elevated privileges instead. This action, where cmd.exe (or another shell) becomes the parent of fodhelper.exe, matches the rule's logic and will generate an alert. Ubuntu This test simulates the discovery step an attacker takes after gaining initial access. Test Command : sudo -l This command uses the -l (list) option of sudo to show which commands the current user is permitted to run with elevated privileges. Running this command directly matches the rule's logic and will generate an alert.","title":"Abuse Elevation Control Mechanism"},{"location":"rules_created/abuse_elevation_control_mechanism/#detection-rule-privilege-escalation-via-fodhelper-uac-bypass","text":"Rule ID: 6727ae6d-21ee-40aa-b0a1-bbcb1c58f8cf Rule Name: Privilege Escalation (T1548: Abuse Elevation Control Mechanism) MITRE ATT&CK Tactic: Privilege Escalation MITRE ATT&CK Technique: T1548.002, Abuse Elevation Control Mechanism: Bypass User Account Control","title":"Detection Rule: Privilege Escalation via Fodhelper UAC Bypass"},{"location":"rules_created/abuse_elevation_control_mechanism/#description","text":"This rule detects adversaries abusing built-in elevation control mechanisms to execute code with higher privileges. This is a critical step for an attacker to move from a standard user context to an administrator or root context, granting them full control over the system. On Windows, a common technique is to bypass User Account Control (UAC) by exploiting legitimate applications that are allowed to auto-elevate, such as fodhelper.exe . On Linux, a precursor to privilege escalation is often discovering what permissions the current user has, which is frequently done using the sudo -l command.","title":"Description"},{"location":"rules_created/abuse_elevation_control_mechanism/#rule-derivation-from-log-analysis","text":"The logic for this rule is derived by identifying adversary actions that are highly indicative of an attempt to gain higher privileges.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/abuse_elevation_control_mechanism/#1-defining-the-behavior","text":"The goal is to detect either the active bypass of a security control or the reconnaissance that precedes it. Windows (Bypass) : The focus is on an untrusted process launching a trusted, auto-elevating executable like fodhelper.exe . This anomalous parent-child relationship is a strong indicator of a hijack. Linux (Discovery) : The focus is on an adversary checking what commands they can run with elevated privileges. The sudo -l command is a specific artifact of this discovery behavior.","title":"1. Defining the Behavior:"},{"location":"rules_created/abuse_elevation_control_mechanism/#2-translating-behavior-to-log-fields","text":"Windows : The child process ( process.name ) and its parent ( process.parent.name ) are analyzed. Linux : The process ( process.name ) and its specific arguments ( process.args ) are inspected.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/abuse_elevation_control_mechanism/#3-constructing-the-rule","text":"The Windows query identifies the execution of fodhelper.exe and then excludes known legitimate parent processes, flagging any remaining instance as suspicious. The Ubuntu query looks for the specific combination of the sudo process being run with the -l argument, a high-fidelity indicator of privilege discovery.","title":"3. Constructing the Rule:"},{"location":"rules_created/abuse_elevation_control_mechanism/#detection-logic","text":"","title":"Detection Logic"},{"location":"rules_created/abuse_elevation_control_mechanism/#windows-fodhelper-uac-bypass","text":"This is a query-based rule that triggers on a single process creation event matching a specific parent-child relationship. Query : process.name : \"fodhelper.exe\" AND NOT (process.parent.name : \"explorer.exe\" OR process.parent.name : \"svchost.exe\") Query Explanation : The query logic identifies instances where fodhelper.exe is executed by a process other than its expected parent processes. - The process.name : \"fodhelper.exe\" clause selects all events where the fodhelper.exe process is created. - The AND NOT (...) clause then filters out these events if the parent process ( process.parent.name ) is either explorer.exe or svchost.exe , which are considered legitimate initiators. The rule triggers an alert for any fodhelper.exe process creation event that does not match the exclusion criteria, indicating a high probability of a UAC bypass attempt.","title":"Windows: Fodhelper UAC Bypass"},{"location":"rules_created/abuse_elevation_control_mechanism/#ubuntu-sudo-permissions-discovery","text":"This query looks for a user attempting to list their sudo permissions, which is often a precursor to privilege escalation. Query : process.name:\"sudo\" and process.args:\"-l\" Explanation : This query alerts when the sudo command is run with the -l (list) flag. Before attempting to escalate privileges, an attacker will almost always use this command to discover what commands they are permitted to run as root.","title":"Ubuntu: Sudo Permissions Discovery"},{"location":"rules_created/abuse_elevation_control_mechanism/#simulation-and-validation","text":"","title":"Simulation and Validation"},{"location":"rules_created/abuse_elevation_control_mechanism/#windows","text":"This rule can be validated by simulating the registry hijack and execution flow used in this UAC bypass technique. Test Command (PowerShell) : reg add HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /v \"\" /d \"C:\\Windows\\System32\\cmd.exe\" /f reg add HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /v \"DelegateExecute\" /d \"\" /f fodhelper.exe This sequence of commands first modifies the registry key associated with the ms-settings URI handler, pointing it to the Command Prompt ( cmd.exe ). When fodhelper.exe is executed in the final step, it attempts to open the settings handler, but because of the registry modification, it launches cmd.exe with elevated privileges instead. This action, where cmd.exe (or another shell) becomes the parent of fodhelper.exe, matches the rule's logic and will generate an alert.","title":"Windows"},{"location":"rules_created/abuse_elevation_control_mechanism/#ubuntu","text":"This test simulates the discovery step an attacker takes after gaining initial access. Test Command : sudo -l This command uses the -l (list) option of sudo to show which commands the current user is permitted to run with elevated privileges. Running this command directly matches the rule's logic and will generate an alert.","title":"Ubuntu"},{"location":"rules_created/active_scanning/","text":"Detection Rule: Reconnaissance - Active Scanning Rule ID: 05e649fb-4bdf-4f4a-82ef-52b83a4c9090 Rule Name: Reconnaissance (T1595: Active Scanning) MITRE ATT&CK Tactic: Reconnaissance MITRE ATT&CK Technique: T1595, Active Scanning Description This rule detects a potential network port scan originating from an external IP address. Active scanning is a common reconnaissance technique used by adversaries to identify open ports, discover running services, and map potential vulnerabilities on target systems before launching an attack. This activity is analogous to a burglar checking every door and window of a building to find an unlocked entry point. An alert from this rule indicates that a single external source has attempted to connect to an abnormally high number of different ports across the network within a short time frame. Rule Derivation from Log Analysis The logic for this rule was developed by modeling the digital footprint of a port scan and translating it into a query. The process involved identifying key patterns in network logs that distinguish a scan from benign traffic. 1. Defining the Behavior : The primary goal was to identify an external actor systematically probing many network ports. The key characteristics of this behavior in raw log data are: A high volume of connection attempts. All attempts originate from a single source IP. The attempts target many different destination ports. The events occur within a condensed time frame. The source is external to our network. 2. Translating Behavior to Log Fields : These characteristics were then mapped to specific fields and logic available in our log data: The \"single source IP\" is represented by the source.ip field. The \"many different destination ports\" is identified by looking for a high number of unique values in the destination.port field. To focus on \"external\" traffic, we filter out all logs where the source.ip belongs to a known internal (private RFC 1918) address range. 3. Constructing the Rule : This analysis directly led to the rule's threshold-based design: First, we filter for only the relevant data: inbound TCP connections from external IPs. Next, we tell the system to group the events by source.ip , as we want to analyze the behavior of each external actor individually. Finally, we set a threshold: an alert is triggered if any single group (a unique source IP) has a count of unique destination.port values that exceeds 50 within the rule's time window. This numeric threshold is the critical piece that separates the systematic, broad nature of a scan from normal, targeted network communication. 4. Detection Logic Windows (Network-based) This is a threshold-based rule that analyzes network connection logs to identify patterns indicative of scanning behavior. Query : event.category:network and event.type:connection and network.transport:tcp and not source.ip:(10.0.0.0/8 or 172.16.0.0/12 or 192.168.0.0/16) The query filters logs to isolate inbound TCP connection events. Crucially, it excludes traffic originating from internal, private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to prevent false positives from legitimate internal network activity. Threshold : The rule groups events by the source IP address (winlog.event_data.SourceIp.keyword). It triggers an alert if the number of unique destination ports (winlog.event_data.DestinationPort.keyword) from a single source IP exceeds 50 within the rule's 5-minute evaluation window. In summary, the rule alerts when a single external IP address attempts to connect to 50 or more unique ports on the network in under five minutes. Ubuntu (Host-based) This rule focuses on detecting the execution of common scanning tools on the host itself, which can indicate that a compromised machine is being used for internal reconnaissance. Query : event.dataset:auditd.log and event.action:\"executed\" and (process.args:\"nmap\" or process.args:\"masscan\") This query looks for audit logs showing that the nmap or masscan process was executed. Simulation and Validation To validate that these rules work correctly, a port scan can be simulated against a monitored endpoint. Windows (External Scan) Test Command (PowerShell) : nmap -sT -p- <target_IP> This command initiates a TCP connect scan (-sT) against all 65,535 ports (-p-) of the . This will generate a large volume of connection attempts from a single source to many distinct ports, satisfying the rule's threshold condition and triggering an alert. Ubuntu (Local Scan) This command simulates a scan being run from the Ubuntu machine itself, which tests the host-based detection logic. Test Command : sudo nmap -sS localhost This command uses nmap to perform a TCP SYN scan (-sS), a common and fast scanning technique, against the local machine (localhost). This action will be logged by auditd, triggering the host-based rule that detects the execution of the nmap process.","title":"Active Scanning"},{"location":"rules_created/active_scanning/#detection-rule-reconnaissance-active-scanning","text":"Rule ID: 05e649fb-4bdf-4f4a-82ef-52b83a4c9090 Rule Name: Reconnaissance (T1595: Active Scanning) MITRE ATT&CK Tactic: Reconnaissance MITRE ATT&CK Technique: T1595, Active Scanning","title":"Detection Rule: Reconnaissance - Active Scanning"},{"location":"rules_created/active_scanning/#description","text":"This rule detects a potential network port scan originating from an external IP address. Active scanning is a common reconnaissance technique used by adversaries to identify open ports, discover running services, and map potential vulnerabilities on target systems before launching an attack. This activity is analogous to a burglar checking every door and window of a building to find an unlocked entry point. An alert from this rule indicates that a single external source has attempted to connect to an abnormally high number of different ports across the network within a short time frame.","title":"Description"},{"location":"rules_created/active_scanning/#rule-derivation-from-log-analysis","text":"The logic for this rule was developed by modeling the digital footprint of a port scan and translating it into a query. The process involved identifying key patterns in network logs that distinguish a scan from benign traffic.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/active_scanning/#1-defining-the-behavior","text":"The primary goal was to identify an external actor systematically probing many network ports. The key characteristics of this behavior in raw log data are: A high volume of connection attempts. All attempts originate from a single source IP. The attempts target many different destination ports. The events occur within a condensed time frame. The source is external to our network.","title":"1. Defining the Behavior:"},{"location":"rules_created/active_scanning/#2-translating-behavior-to-log-fields","text":"These characteristics were then mapped to specific fields and logic available in our log data: The \"single source IP\" is represented by the source.ip field. The \"many different destination ports\" is identified by looking for a high number of unique values in the destination.port field. To focus on \"external\" traffic, we filter out all logs where the source.ip belongs to a known internal (private RFC 1918) address range.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/active_scanning/#3-constructing-the-rule","text":"This analysis directly led to the rule's threshold-based design: First, we filter for only the relevant data: inbound TCP connections from external IPs. Next, we tell the system to group the events by source.ip , as we want to analyze the behavior of each external actor individually. Finally, we set a threshold: an alert is triggered if any single group (a unique source IP) has a count of unique destination.port values that exceeds 50 within the rule's time window. This numeric threshold is the critical piece that separates the systematic, broad nature of a scan from normal, targeted network communication.","title":"3. Constructing the Rule:"},{"location":"rules_created/active_scanning/#4-detection-logic","text":"","title":"4. Detection Logic"},{"location":"rules_created/active_scanning/#windows-network-based","text":"This is a threshold-based rule that analyzes network connection logs to identify patterns indicative of scanning behavior. Query : event.category:network and event.type:connection and network.transport:tcp and not source.ip:(10.0.0.0/8 or 172.16.0.0/12 or 192.168.0.0/16) The query filters logs to isolate inbound TCP connection events. Crucially, it excludes traffic originating from internal, private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to prevent false positives from legitimate internal network activity. Threshold : The rule groups events by the source IP address (winlog.event_data.SourceIp.keyword). It triggers an alert if the number of unique destination ports (winlog.event_data.DestinationPort.keyword) from a single source IP exceeds 50 within the rule's 5-minute evaluation window. In summary, the rule alerts when a single external IP address attempts to connect to 50 or more unique ports on the network in under five minutes.","title":"Windows (Network-based)"},{"location":"rules_created/active_scanning/#ubuntu-host-based","text":"This rule focuses on detecting the execution of common scanning tools on the host itself, which can indicate that a compromised machine is being used for internal reconnaissance. Query : event.dataset:auditd.log and event.action:\"executed\" and (process.args:\"nmap\" or process.args:\"masscan\") This query looks for audit logs showing that the nmap or masscan process was executed.","title":"Ubuntu (Host-based)"},{"location":"rules_created/active_scanning/#simulation-and-validation","text":"To validate that these rules work correctly, a port scan can be simulated against a monitored endpoint.","title":"Simulation and Validation"},{"location":"rules_created/active_scanning/#windows-external-scan","text":"Test Command (PowerShell) : nmap -sT -p- <target_IP> This command initiates a TCP connect scan (-sT) against all 65,535 ports (-p-) of the . This will generate a large volume of connection attempts from a single source to many distinct ports, satisfying the rule's threshold condition and triggering an alert.","title":"Windows (External Scan)"},{"location":"rules_created/active_scanning/#ubuntu-local-scan","text":"This command simulates a scan being run from the Ubuntu machine itself, which tests the host-based detection logic. Test Command : sudo nmap -sS localhost This command uses nmap to perform a TCP SYN scan (-sS), a common and fast scanning technique, against the local machine (localhost). This action will be logged by auditd, triggering the host-based rule that detects the execution of the nmap process.","title":"Ubuntu (Local Scan)"},{"location":"rules_created/application_layer_protocol/","text":"Detection Rule: C2 via Application Layer Protocol Rule ID: a2b74aea-b267-4ddd-9a51-bac87083d306 Rule Name: Command and Control (T1071: Application Layer Protocol) MITRE ATT&CK Tactic: Command and Control MITRE ATT&CK Technique: T1071, Application Layer Protocol Description This rule detects adversaries using common protocols like HTTP or HTTPS for their command and control (C2) communications to blend in with legitimate network traffic. This is a common method for malware to \"beacon\" out for instructions. To spot this, we look for anomalies. On Windows , this rule identifies network connections to standard web ports (80/443) that originate from non-browser processes . On Linux , it identifies outbound network connections from processes running out of suspicious locations , such as the /tmp directory. Rule Derivation from Log Analysis The logic for this rule was developed by baselining normal traffic and then hunting for high-fidelity outliers that indicate malicious C2 activity. 1. Defining the Behavior : The goal is to find C2 traffic hiding in plain sight. The key differentiators are the source of the traffic. Windows : Legitimate web traffic originates from a browser. Malicious C2 traffic often originates from malware, droppers, or script interpreters (like powershell.exe ). Linux : Legitimate applications are installed in standard locations like /usr/bin . Malware is often dropped and executed from world-writable directories like /tmp . 2. Translating Behavior to Log Fields : This behavior is observed in network connection and process logs. Windows : We inspect the destination.port and the source process.name . Linux : We inspect the source process.executable path and the network.direction . Detection Logic Windows: Non-Browser Web Traffic This is a query-based rule that triggers on a single network connection event. Query : event.category:network and destination.port:(80 or 443) and not process.name:(\"chrome.exe\" or \"firefox.exe\" or \"msedge.exe\" or \"iexplore.exe\" or \"svchost.exe\") Query Explanation : The query identifies network traffic from non-standard applications to web ports. event.category:network : This clause filters events to only include network connections. destination.port:(80 or 443) : This filters for traffic directed to the standard ports for HTTP (80) and HTTPS (443). not process.name:(...) : This is the core logic, which excludes traffic originating from common web browsers and the Windows Service Host (svchost.exe). Ubuntu: Outbound Connection from /tmp This query looks for network connections from a process running out of a suspicious, temporary location. Query : process.executable:\"/tmp/*\" and network.direction:\"outbound\" Explanation : Legitimate applications do not typically run from the /tmp directory. This query alerts on any process running from /tmp that is making an outbound network connection, which is a strong indicator of a C2 beacon. Simulation and Validation Windows This rule can be validated by initiating a web request from a non-browser application, such as PowerShell. Test Command (PowerShell) : Invoke-WebRequest -Uri https://www.google.com This command uses PowerShell's Invoke-WebRequest cmdlet to download the homepage of Google. This creates a network connection from the powershell.exe process to a destination on port 443 (HTTPS). Since powershell.exe is not in the rule's exclusion list, this action directly matches the rule's logic and will generate an alert. Ubuntu This test simulates an attacker downloading and executing their tool from /tmp to establish a C2 channel. Test Command : cp /usr/bin/curl /tmp/legit_process && /tmp/legit_process http://example.com -o /dev/null Description : This command copies the curl utility to /tmp and then runs it from that location to make an outbound web request. This action of a process in /tmp making an outbound connection perfectly matches the rule's logic and will generate an alert.","title":"Application Layer Protocol"},{"location":"rules_created/application_layer_protocol/#detection-rule-c2-via-application-layer-protocol","text":"Rule ID: a2b74aea-b267-4ddd-9a51-bac87083d306 Rule Name: Command and Control (T1071: Application Layer Protocol) MITRE ATT&CK Tactic: Command and Control MITRE ATT&CK Technique: T1071, Application Layer Protocol","title":"Detection Rule: C2 via Application Layer Protocol"},{"location":"rules_created/application_layer_protocol/#description","text":"This rule detects adversaries using common protocols like HTTP or HTTPS for their command and control (C2) communications to blend in with legitimate network traffic. This is a common method for malware to \"beacon\" out for instructions. To spot this, we look for anomalies. On Windows , this rule identifies network connections to standard web ports (80/443) that originate from non-browser processes . On Linux , it identifies outbound network connections from processes running out of suspicious locations , such as the /tmp directory.","title":"Description"},{"location":"rules_created/application_layer_protocol/#rule-derivation-from-log-analysis","text":"The logic for this rule was developed by baselining normal traffic and then hunting for high-fidelity outliers that indicate malicious C2 activity.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/application_layer_protocol/#1-defining-the-behavior","text":"The goal is to find C2 traffic hiding in plain sight. The key differentiators are the source of the traffic. Windows : Legitimate web traffic originates from a browser. Malicious C2 traffic often originates from malware, droppers, or script interpreters (like powershell.exe ). Linux : Legitimate applications are installed in standard locations like /usr/bin . Malware is often dropped and executed from world-writable directories like /tmp .","title":"1. Defining the Behavior:"},{"location":"rules_created/application_layer_protocol/#2-translating-behavior-to-log-fields","text":"This behavior is observed in network connection and process logs. Windows : We inspect the destination.port and the source process.name . Linux : We inspect the source process.executable path and the network.direction .","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/application_layer_protocol/#detection-logic","text":"","title":"Detection Logic"},{"location":"rules_created/application_layer_protocol/#windows-non-browser-web-traffic","text":"This is a query-based rule that triggers on a single network connection event. Query : event.category:network and destination.port:(80 or 443) and not process.name:(\"chrome.exe\" or \"firefox.exe\" or \"msedge.exe\" or \"iexplore.exe\" or \"svchost.exe\") Query Explanation : The query identifies network traffic from non-standard applications to web ports. event.category:network : This clause filters events to only include network connections. destination.port:(80 or 443) : This filters for traffic directed to the standard ports for HTTP (80) and HTTPS (443). not process.name:(...) : This is the core logic, which excludes traffic originating from common web browsers and the Windows Service Host (svchost.exe).","title":"Windows: Non-Browser Web Traffic"},{"location":"rules_created/application_layer_protocol/#ubuntu-outbound-connection-from-tmp","text":"This query looks for network connections from a process running out of a suspicious, temporary location. Query : process.executable:\"/tmp/*\" and network.direction:\"outbound\" Explanation : Legitimate applications do not typically run from the /tmp directory. This query alerts on any process running from /tmp that is making an outbound network connection, which is a strong indicator of a C2 beacon.","title":"Ubuntu: Outbound Connection from /tmp"},{"location":"rules_created/application_layer_protocol/#simulation-and-validation","text":"","title":"Simulation and Validation"},{"location":"rules_created/application_layer_protocol/#windows","text":"This rule can be validated by initiating a web request from a non-browser application, such as PowerShell. Test Command (PowerShell) : Invoke-WebRequest -Uri https://www.google.com This command uses PowerShell's Invoke-WebRequest cmdlet to download the homepage of Google. This creates a network connection from the powershell.exe process to a destination on port 443 (HTTPS). Since powershell.exe is not in the rule's exclusion list, this action directly matches the rule's logic and will generate an alert.","title":"Windows"},{"location":"rules_created/application_layer_protocol/#ubuntu","text":"This test simulates an attacker downloading and executing their tool from /tmp to establish a C2 channel. Test Command : cp /usr/bin/curl /tmp/legit_process && /tmp/legit_process http://example.com -o /dev/null Description : This command copies the curl utility to /tmp and then runs it from that location to make an outbound web request. This action of a process in /tmp making an outbound connection perfectly matches the rule's logic and will generate an alert.","title":"Ubuntu"},{"location":"rules_created/automated_collection/","text":"Detection Rule: Automated Collection and Archiving Rule ID: 3f756498-01bb-435e-92d1-5e19468abe64 Rule Name: Collection (T1119: Automated Collection) MITRE ATT&CK Tactic: Collection MITRE ATT&CK Technique: T1119, Automated Collection & T1560.001, Archive Collected Data: Archive via Utility Description This rule detects the two primary stages of data collection: finding sensitive data and staging it for exfiltration. First, attackers often use scripts or built-in tools to automatically search a system for files of interest (e.g., .doc , .pdf , .xls ). Next, they frequently compress this data into a single, often password-protected, archive file. This makes it easier for an attacker to exfiltrate a large volume of information in one go while evading simple content inspection. Rule Derivation from Log Analysis The logic for this rule was developed by identifying the command-line footprint of data being staged for exfiltration. 1. Defining the Behavior : Automated Collection (Linux) : The behavior is an attacker using a command-line tool like find to systematically search for files with sensitive extensions. Archiving Data (Windows) : The behavior is an attacker using a command-line utility ( 7z , rar , etc.) to compress document files into a password-protected archive. 2. Translating Behavior to Log Fields : These actions are captured in process creation logs. The key fields are the process name ( process.name ) and the full command line ( process.command_line ), which contains the file types and specific switches being used. Detection Logic Windows: Archiving Collected Data This is a query-based rule that triggers on a single process creation event. Query : process.name:(\"7z.exe\" or \"rar.exe\" or \"zip.exe\") and process.command_line:(\"*.doc*\" or \"*.xls*\" or \"*.pdf*\" or \"*.txt*\") and process.command_line:(\"-p*\" or \"-hp*\") Query Explanation : The query identifies the use of common archiving tools to create password-protected archives of document files. process.name:(...) : This clause filters for events where a common archiving utility (7z.exe, rar.exe, zip.exe) is executed. process.command_line:(\"*.doc*\"...) : This clause checks that the command line contains references to common document file types. process.command_line:(\"-p*\" or \"-hp*\") : This clause checks for the presence of command-line switches used to set a password (-p for 7-Zip/Zip, -hp for RAR). Ubuntu: Automated File Search This query looks for the use of the find command to search for files with common sensitive extensions, indicating an initial data discovery phase. Query : process.name:\"find\" and process.command_line:(\"*.doc*\" or \"*.xls*\" or \"*.pdf*\" or \"*.txt*\" or \"*.bak*\") Explanation : This query alerts when the find command is used to locate documents, spreadsheets, backups, or other potentially sensitive files, a common first step before data is staged for exfiltration. Simulation and Validation Windows This rule can be validated by creating dummy document files and then using an archiving tool to compress them with a password. Test Command (PowerShell) : echo \"secret\" > file.doc 7z.exe a -pSuperSecret collected.zip *.doc This test first creates a dummy document file named file.doc. It then uses the 7-Zip utility ( 7z.exe ) to create a new archive named collected.zip, protecting it with a password ( -pSuperSecret ), and adds all files with a .doc extension to it. This action perfectly matches the rule's logic and will generate an alert. Ubuntu This test simulates the initial data discovery phase by searching the file system for a specific file type. Test Command: Step 1: Create a dummy file for the test touch ~/Documents/sensitive_data.doc Step 2: Run the collection command find /home -name \"*.doc\" Description : This test first creates a target file and then uses the find command to search for all files with a .doc extension. This simulates an attacker's script searching the file system for valuable documents and will trigger the detection rule.","title":"Automated Collection"},{"location":"rules_created/automated_collection/#detection-rule-automated-collection-and-archiving","text":"Rule ID: 3f756498-01bb-435e-92d1-5e19468abe64 Rule Name: Collection (T1119: Automated Collection) MITRE ATT&CK Tactic: Collection MITRE ATT&CK Technique: T1119, Automated Collection & T1560.001, Archive Collected Data: Archive via Utility","title":"Detection Rule: Automated Collection and Archiving"},{"location":"rules_created/automated_collection/#description","text":"This rule detects the two primary stages of data collection: finding sensitive data and staging it for exfiltration. First, attackers often use scripts or built-in tools to automatically search a system for files of interest (e.g., .doc , .pdf , .xls ). Next, they frequently compress this data into a single, often password-protected, archive file. This makes it easier for an attacker to exfiltrate a large volume of information in one go while evading simple content inspection.","title":"Description"},{"location":"rules_created/automated_collection/#rule-derivation-from-log-analysis","text":"The logic for this rule was developed by identifying the command-line footprint of data being staged for exfiltration.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/automated_collection/#1-defining-the-behavior","text":"Automated Collection (Linux) : The behavior is an attacker using a command-line tool like find to systematically search for files with sensitive extensions. Archiving Data (Windows) : The behavior is an attacker using a command-line utility ( 7z , rar , etc.) to compress document files into a password-protected archive.","title":"1. Defining the Behavior:"},{"location":"rules_created/automated_collection/#2-translating-behavior-to-log-fields","text":"These actions are captured in process creation logs. The key fields are the process name ( process.name ) and the full command line ( process.command_line ), which contains the file types and specific switches being used.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/automated_collection/#detection-logic","text":"","title":"Detection Logic"},{"location":"rules_created/automated_collection/#windows-archiving-collected-data","text":"This is a query-based rule that triggers on a single process creation event. Query : process.name:(\"7z.exe\" or \"rar.exe\" or \"zip.exe\") and process.command_line:(\"*.doc*\" or \"*.xls*\" or \"*.pdf*\" or \"*.txt*\") and process.command_line:(\"-p*\" or \"-hp*\") Query Explanation : The query identifies the use of common archiving tools to create password-protected archives of document files. process.name:(...) : This clause filters for events where a common archiving utility (7z.exe, rar.exe, zip.exe) is executed. process.command_line:(\"*.doc*\"...) : This clause checks that the command line contains references to common document file types. process.command_line:(\"-p*\" or \"-hp*\") : This clause checks for the presence of command-line switches used to set a password (-p for 7-Zip/Zip, -hp for RAR).","title":"Windows: Archiving Collected Data"},{"location":"rules_created/automated_collection/#ubuntu-automated-file-search","text":"This query looks for the use of the find command to search for files with common sensitive extensions, indicating an initial data discovery phase. Query : process.name:\"find\" and process.command_line:(\"*.doc*\" or \"*.xls*\" or \"*.pdf*\" or \"*.txt*\" or \"*.bak*\") Explanation : This query alerts when the find command is used to locate documents, spreadsheets, backups, or other potentially sensitive files, a common first step before data is staged for exfiltration.","title":"Ubuntu: Automated File Search"},{"location":"rules_created/automated_collection/#simulation-and-validation","text":"","title":"Simulation and Validation"},{"location":"rules_created/automated_collection/#windows","text":"This rule can be validated by creating dummy document files and then using an archiving tool to compress them with a password. Test Command (PowerShell) : echo \"secret\" > file.doc 7z.exe a -pSuperSecret collected.zip *.doc This test first creates a dummy document file named file.doc. It then uses the 7-Zip utility ( 7z.exe ) to create a new archive named collected.zip, protecting it with a password ( -pSuperSecret ), and adds all files with a .doc extension to it. This action perfectly matches the rule's logic and will generate an alert.","title":"Windows"},{"location":"rules_created/automated_collection/#ubuntu","text":"This test simulates the initial data discovery phase by searching the file system for a specific file type. Test Command: Step 1: Create a dummy file for the test touch ~/Documents/sensitive_data.doc Step 2: Run the collection command find /home -name \"*.doc\" Description : This test first creates a target file and then uses the find command to search for all files with a .doc extension. This simulates an attacker's script searching the file system for valuable documents and will trigger the detection rule.","title":"Ubuntu"},{"location":"rules_created/boot_or_logon_autostart_execution/","text":"Detection Rule: Persistence via Registry Run Keys Rule ID: 5a51e164-aaae-42a4-9537-00406b2f85ba Rule Name: Persistence (T1547: Boot or Logon Autostart Execution) MITRE ATT&CK Tactic: Persistence MITRE ATT&CK Technique: T1547.001, Boot or Logon Autostart Execution: Registry Run Keys Description This rule detects when a program establishes persistence by creating an entry in a common autostart location. After gaining access, an adversary uses persistence mechanisms to ensure their malicious software automatically executes every time the computer is booted or a user logs on. This is one of the most common methods for maintaining a foothold. On Windows, this is typically done by adding an entry to the Registry Run Keys. On Linux, this is achieved by placing a script or service file in an autostart directory such as /etc/cron.d/ or /etc/systemd/system/ . By writing to these specific locations, the attacker guarantees their code will survive a system reboot. Rule Derivation from Log Analysis The logic for this rule was developed by targeting a well-documented and high-fidelity persistence method within Windows. 1. Defining the Behavior : The goal was to detect the act of creating or modifying an auto-start entry. This could be a new value added to a Windows Registry Run key or a new file placed in a Linux autostart directory.. 2. Translating Behavior to Log Fields : This action is captured by system monitoring tools that log registry or file system modifications. The critical log fields are: Windows : event.category:registry and registry.path . Linux : file.path and event.action (looking for \"created\" or \"updated\"). 3. Constructing the Rule : The query was built to be highly specific. It filters all system events for only those that are registry or file modifications and then checks if the path of the modification falls within a list of known autostart locations. The wildcard (*) is used to match any new program entry. This approach is effective because changes to these locations are relatively infrequent during normal operations, making any modification a noteworthy event. Detection Logic This is a query-based rule that triggers on a single registry modification event matching the specified criteria. Windows Query : event.category:registry and registry.path:(\"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\*\" or \"HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\*\") Explanation : The query identifies events where a value is created or modified within the specified Windows Registry Run keys. The event.category:registry clause filters events to only include operations involving the Windows Registry . The registry.path:(...) clause matches events where the modified path is located in one of two keys: HKEY_CURRENT_USER\\...\\Run\\* : This key contains programs that execute upon the current user's logon. HKEY_LOCAL_MACHINE\\...\\Run\\* : This key contains programs that execute for any user upon system startup. The logic triggers an alert when any registry modification event occurs within these specific auto-start execution paths. Ubuntu: Autostart Directories & Services Query : file.path: (\"/etc/systemd/system/*\" or \"/home/*/.config/autostart/*\" or \"/etc/cron.d/*\" or \"/etc/rc.local\") and event.action: (\"created\" or \"updated\") Explanation : This query alerts on the creation or modification of files in common Linux directories that are used for autostarting applications and services, such as systemd unit files, user autostart directories, and cron job directories. Simulation and Validation Windows This rule can be validated by using the built-in Windows Registry Editor (reg.exe) to add a new startup entry. Test Command (PowerShell) : reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v \"AtomicPersistence\" /t REG_SZ /d \"C:\\Windows\\System32\\calc.exe\" /f This command adds a new registry value named AtomicPersistence to the current user's Run key. It instructs Windows to launch the Calculator (calc.exe) every time the user logs in. This action directly modifies one of the paths monitored by the rule and will immediately generate an alert. Ubuntu This test creates a new file in a cron.d directory, a common location for cron-based persistence. Test Command : sudo touch /etc/cron.d/malicious_persistence Creating a file in the /etc/cron.d directory is a common persistence technique. This simple touch command creates a new file in a monitored location and should trigger a file integrity monitoring alert based on the rule's logic. The file can be removed afterward with sudo rm /etc/cron.d/malicious_persistence .","title":"Boot or Logon Autostart Execution"},{"location":"rules_created/boot_or_logon_autostart_execution/#detection-rule-persistence-via-registry-run-keys","text":"Rule ID: 5a51e164-aaae-42a4-9537-00406b2f85ba Rule Name: Persistence (T1547: Boot or Logon Autostart Execution) MITRE ATT&CK Tactic: Persistence MITRE ATT&CK Technique: T1547.001, Boot or Logon Autostart Execution: Registry Run Keys","title":"Detection Rule: Persistence via Registry Run Keys"},{"location":"rules_created/boot_or_logon_autostart_execution/#description","text":"This rule detects when a program establishes persistence by creating an entry in a common autostart location. After gaining access, an adversary uses persistence mechanisms to ensure their malicious software automatically executes every time the computer is booted or a user logs on. This is one of the most common methods for maintaining a foothold. On Windows, this is typically done by adding an entry to the Registry Run Keys. On Linux, this is achieved by placing a script or service file in an autostart directory such as /etc/cron.d/ or /etc/systemd/system/ . By writing to these specific locations, the attacker guarantees their code will survive a system reboot.","title":"Description"},{"location":"rules_created/boot_or_logon_autostart_execution/#rule-derivation-from-log-analysis","text":"The logic for this rule was developed by targeting a well-documented and high-fidelity persistence method within Windows.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/boot_or_logon_autostart_execution/#1-defining-the-behavior","text":"The goal was to detect the act of creating or modifying an auto-start entry. This could be a new value added to a Windows Registry Run key or a new file placed in a Linux autostart directory..","title":"1. Defining the Behavior:"},{"location":"rules_created/boot_or_logon_autostart_execution/#2-translating-behavior-to-log-fields","text":"This action is captured by system monitoring tools that log registry or file system modifications. The critical log fields are: Windows : event.category:registry and registry.path . Linux : file.path and event.action (looking for \"created\" or \"updated\").","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/boot_or_logon_autostart_execution/#3-constructing-the-rule","text":"The query was built to be highly specific. It filters all system events for only those that are registry or file modifications and then checks if the path of the modification falls within a list of known autostart locations. The wildcard (*) is used to match any new program entry. This approach is effective because changes to these locations are relatively infrequent during normal operations, making any modification a noteworthy event.","title":"3. Constructing the Rule:"},{"location":"rules_created/boot_or_logon_autostart_execution/#detection-logic","text":"This is a query-based rule that triggers on a single registry modification event matching the specified criteria.","title":"Detection Logic"},{"location":"rules_created/boot_or_logon_autostart_execution/#windows","text":"Query : event.category:registry and registry.path:(\"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\*\" or \"HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\*\") Explanation : The query identifies events where a value is created or modified within the specified Windows Registry Run keys. The event.category:registry clause filters events to only include operations involving the Windows Registry . The registry.path:(...) clause matches events where the modified path is located in one of two keys: HKEY_CURRENT_USER\\...\\Run\\* : This key contains programs that execute upon the current user's logon. HKEY_LOCAL_MACHINE\\...\\Run\\* : This key contains programs that execute for any user upon system startup. The logic triggers an alert when any registry modification event occurs within these specific auto-start execution paths.","title":"Windows"},{"location":"rules_created/boot_or_logon_autostart_execution/#ubuntu-autostart-directories-services","text":"Query : file.path: (\"/etc/systemd/system/*\" or \"/home/*/.config/autostart/*\" or \"/etc/cron.d/*\" or \"/etc/rc.local\") and event.action: (\"created\" or \"updated\") Explanation : This query alerts on the creation or modification of files in common Linux directories that are used for autostarting applications and services, such as systemd unit files, user autostart directories, and cron job directories.","title":"Ubuntu: Autostart Directories &amp; Services"},{"location":"rules_created/boot_or_logon_autostart_execution/#simulation-and-validation","text":"","title":"Simulation and Validation"},{"location":"rules_created/boot_or_logon_autostart_execution/#windows_1","text":"This rule can be validated by using the built-in Windows Registry Editor (reg.exe) to add a new startup entry. Test Command (PowerShell) : reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v \"AtomicPersistence\" /t REG_SZ /d \"C:\\Windows\\System32\\calc.exe\" /f This command adds a new registry value named AtomicPersistence to the current user's Run key. It instructs Windows to launch the Calculator (calc.exe) every time the user logs in. This action directly modifies one of the paths monitored by the rule and will immediately generate an alert.","title":"Windows"},{"location":"rules_created/boot_or_logon_autostart_execution/#ubuntu","text":"This test creates a new file in a cron.d directory, a common location for cron-based persistence. Test Command : sudo touch /etc/cron.d/malicious_persistence Creating a file in the /etc/cron.d directory is a common persistence technique. This simple touch command creates a new file in a monitored location and should trigger a file integrity monitoring alert based on the rule's logic. The file can be removed afterward with sudo rm /etc/cron.d/malicious_persistence .","title":"Ubuntu"},{"location":"rules_created/command_and_scripting_interpreter/","text":"Detection Rule: Execution via PowerShell Download Rule ID: c99f9f9a-b0bd-49dc-b3af-3d837cfb64e1 Rule Name: Execution (T1059: Command and Scripting Interpreter) MITRE ATT&CK Tactic: Execution MITRE ATT&CK Technique: T1059.001, Command and Scripting Interpreter: PowerShell Description This rule detects adversaries using native command and scripting interpreters, such as PowerShell on Windows or Bash on Linux , to execute malicious code. Because these tools are installed by default and used for legitimate administration, attackers favor them for \"living off the land\" to download payloads, run obfuscated commands, and evade defenses. On Windows, this often involves using PowerShell to download malware from a command-and-control (C2) server. On Linux, a common technique is to use Bash to decode and execute obfuscated scripts to hide the true payload. An alert from this rule is a strong indicator of malicious execution on a host. Rule Derivation from Log Analysis This rule's logic was derived by identifying specific, high-fidelity artifacts left in the command line when an interpreter is used for malicious activity. 1. Defining the Behavior : The core behavior is the execution of an interpreter ( powershell.exe , bash ) with command-line arguments that instruct it to perform a suspicious action, such as downloading a file or decoding an obfuscated string. 2.Translating Behavior to Log Fields : This activity is captured entirely within process execution logs: The process being run is identified in the process.name field (i.e., powershell.exe). The specific download instructions are found in the process.command_line field. 3. Constructing the Rule : We identified common cmdlets, classes, and keywords used for these malicious activities. The rule logic was then built to search for the execution of a target interpreter where these specific strings are present in the command line. Detection Logic Windows: Detecting PowerShell Downloads This is a query-based rule that triggers on a single process creation event. Query : process.name:powershell.exe and process.command_line:(*System.Net.WebClient* or *DownloadFile* or *DownloadString* or *iwr* or *wget*) Breakdown : process.name:powershell.exe : The rule first looks for any event where the powershell.exe process is started. and : It then requires the second condition to also be true. process.command_line:(...) : The rule inspects the full command line used to launch PowerShell. It triggers if it finds any of the following keywords, which are commonly used to download files: System.Net.WebClient, DownloadFile, DownloadString: Methods from the .NET Framework for web requests. iwr: A standard alias for the Invoke-WebRequest cmdlet. wget: A common alias for the Invoke-WebRequest cmdlet, familiar to Linux users. In short, the rule alerts whenever PowerShell is launched with a command that explicitly instructs it to download content from the internet. Ubuntu: Detecting Obfuscated Bash Commands Query : process.name:\"bash\" and process.command_line:\"*base64*\" and process.command_line:\"*decode*\" Breakdown : This query searches for instances where the bash shell is used with command-line arguments to decode a Base64 encoded string. Attackers use this encoding (obfuscation) technique to hide their malicious scripts from simple keyword detection. Simulation and Validation This rule can be validated by running a simple PowerShell command to download a benign file from the internet. Windows Test Command (PowerShell) : powershell.exe -Command \"Invoke-WebRequest -Uri https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/LICENSE.txt -OutFile C:\\Users\\Public\\license.txt\" This command starts PowerShell and uses the Invoke-WebRequest cmdlet (iwr) to download the LICENSE.txt file from the official Atomic Red Team GitHub repository and save it to the public user's directory. This action directly matches the process.name and process.command_line logic in the rule and will generate an alert. Ubuntu This test executes a Base64-encoded version of the whoami command, mimicking how attackers hide commands. Test Command : echo \"d2hvYW1p\" | base64 --decode | bash In this command, d2hvYW1p is the Base64 encoding for \"whoami\". The echo command sends this string to the base64 --decode command, which translates it back to \"whoami\". The result is then piped directly into bash for execution. This simulates the technique of running deobfuscated code and is designed to be caught by rules monitoring for this behavior.","title":"Command and Scripting Interpreter"},{"location":"rules_created/command_and_scripting_interpreter/#detection-rule-execution-via-powershell-download","text":"Rule ID: c99f9f9a-b0bd-49dc-b3af-3d837cfb64e1 Rule Name: Execution (T1059: Command and Scripting Interpreter) MITRE ATT&CK Tactic: Execution MITRE ATT&CK Technique: T1059.001, Command and Scripting Interpreter: PowerShell","title":"Detection Rule: Execution via PowerShell Download"},{"location":"rules_created/command_and_scripting_interpreter/#description","text":"This rule detects adversaries using native command and scripting interpreters, such as PowerShell on Windows or Bash on Linux , to execute malicious code. Because these tools are installed by default and used for legitimate administration, attackers favor them for \"living off the land\" to download payloads, run obfuscated commands, and evade defenses. On Windows, this often involves using PowerShell to download malware from a command-and-control (C2) server. On Linux, a common technique is to use Bash to decode and execute obfuscated scripts to hide the true payload. An alert from this rule is a strong indicator of malicious execution on a host.","title":"Description"},{"location":"rules_created/command_and_scripting_interpreter/#rule-derivation-from-log-analysis","text":"This rule's logic was derived by identifying specific, high-fidelity artifacts left in the command line when an interpreter is used for malicious activity.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/command_and_scripting_interpreter/#1-defining-the-behavior","text":"The core behavior is the execution of an interpreter ( powershell.exe , bash ) with command-line arguments that instruct it to perform a suspicious action, such as downloading a file or decoding an obfuscated string.","title":"1. Defining the Behavior:"},{"location":"rules_created/command_and_scripting_interpreter/#2translating-behavior-to-log-fields","text":"This activity is captured entirely within process execution logs: The process being run is identified in the process.name field (i.e., powershell.exe). The specific download instructions are found in the process.command_line field.","title":"2.Translating Behavior to Log Fields:"},{"location":"rules_created/command_and_scripting_interpreter/#3-constructing-the-rule","text":"We identified common cmdlets, classes, and keywords used for these malicious activities. The rule logic was then built to search for the execution of a target interpreter where these specific strings are present in the command line.","title":"3. Constructing the Rule:"},{"location":"rules_created/command_and_scripting_interpreter/#detection-logic","text":"","title":"Detection Logic"},{"location":"rules_created/command_and_scripting_interpreter/#windows-detecting-powershell-downloads","text":"This is a query-based rule that triggers on a single process creation event. Query : process.name:powershell.exe and process.command_line:(*System.Net.WebClient* or *DownloadFile* or *DownloadString* or *iwr* or *wget*) Breakdown : process.name:powershell.exe : The rule first looks for any event where the powershell.exe process is started. and : It then requires the second condition to also be true. process.command_line:(...) : The rule inspects the full command line used to launch PowerShell. It triggers if it finds any of the following keywords, which are commonly used to download files: System.Net.WebClient, DownloadFile, DownloadString: Methods from the .NET Framework for web requests. iwr: A standard alias for the Invoke-WebRequest cmdlet. wget: A common alias for the Invoke-WebRequest cmdlet, familiar to Linux users. In short, the rule alerts whenever PowerShell is launched with a command that explicitly instructs it to download content from the internet.","title":"Windows: Detecting PowerShell Downloads"},{"location":"rules_created/command_and_scripting_interpreter/#ubuntu-detecting-obfuscated-bash-commands","text":"Query : process.name:\"bash\" and process.command_line:\"*base64*\" and process.command_line:\"*decode*\" Breakdown : This query searches for instances where the bash shell is used with command-line arguments to decode a Base64 encoded string. Attackers use this encoding (obfuscation) technique to hide their malicious scripts from simple keyword detection.","title":"Ubuntu: Detecting Obfuscated Bash Commands"},{"location":"rules_created/command_and_scripting_interpreter/#simulation-and-validation","text":"This rule can be validated by running a simple PowerShell command to download a benign file from the internet.","title":"Simulation and Validation"},{"location":"rules_created/command_and_scripting_interpreter/#windows","text":"Test Command (PowerShell) : powershell.exe -Command \"Invoke-WebRequest -Uri https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/LICENSE.txt -OutFile C:\\Users\\Public\\license.txt\" This command starts PowerShell and uses the Invoke-WebRequest cmdlet (iwr) to download the LICENSE.txt file from the official Atomic Red Team GitHub repository and save it to the public user's directory. This action directly matches the process.name and process.command_line logic in the rule and will generate an alert.","title":"Windows"},{"location":"rules_created/command_and_scripting_interpreter/#ubuntu","text":"This test executes a Base64-encoded version of the whoami command, mimicking how attackers hide commands. Test Command : echo \"d2hvYW1p\" | base64 --decode | bash In this command, d2hvYW1p is the Base64 encoding for \"whoami\". The echo command sends this string to the base64 --decode command, which translates it back to \"whoami\". The result is then piped directly into bash for execution. This simulates the technique of running deobfuscated code and is designed to be caught by rules monitoring for this behavior.","title":"Ubuntu"},{"location":"rules_created/exfiltration_over_alternative_protocol/","text":"Detection Rule: Exfiltration Over DNS Tunneling Rule ID: 21890b79-0173-4afc-a46e-338635db2a75 Rule Name: Exfiltration (T1048: Exfiltration Over Alternative Protocol) MITRE ATT&CK Tactic: Exfiltration MITRE ATT&CK Technique: T1048.003, Exfiltration Over Alternative Protocol: DNS Description This rule detects adversaries stealing data by transmitting it over the network. To evade security controls, attackers often use protocols that are different from their primary Command and Control (C2) channel. A common covert technique is DNS tunneling , where stolen data is encoded into a large volume of unique DNS queries. Because DNS is a fundamental protocol that is almost always allowed through firewalls, it provides a stealthy channel for exfiltration. A more overt method, common on Linux, is to use standard file transfer utilities like scp (secure copy) to send data directly to an attacker-controlled machine. Rule Derivation from Log Analysis The logic for these rules was developed by identifying the unique footprints of different exfiltration methods. 1. Defining the Behavior : DNS Tunneling (Windows) : This behavior is a \"DNS storm\" from a single host, characterized by both a very high volume of total DNS queries and a high number of unique subdomains being queried. Secure Copy (Ubuntu ): This behavior is the execution of the scp command with syntax indicating a file is being sent to a remote destination (i.e., user@host ). 2. Translating Behavior to Log Fields : Windows : The detection uses DNS logs, grouping by the source host and counting both total queries and unique domains ( winlog.event_data.TargetDomainName ). Ubuntu : The detection uses process logs, inspecting the process.name and the process.command_line for specific patterns. Detection Logic Windows: DNS Tunneling This is a threshold-based rule that triggers when the volume and variety of DNS queries from a single host exceed a defined limit within the rule's time window. Query : event.category:network and event.dataset:dns Threshold : Group By : The rule groups DNS queries by the source host ( host.hostname.keyword or winlog.event_data.SourceIp.keyword ). Condition 1 (Volume) : The total number of DNS queries from a single host must be greater than or equal to 200. Condition 2 (Variety) : Within those queries, the number of unique domain names must be greater than or equal to 100. Query Explanation : The rule's logic is: \"Alert if any single host makes more than 200 DNS queries to at least 100 different domain names within a five-minute window.\" This is a strong indicator of automated data exfiltration using DNS. Ubuntu: Exfiltration via scp This query looks for the use of scp to copy files to a remote destination. Query : process.name:\"scp\" and process.command_line:\"*@*\" Explanation : This query looks for any use of the scp command that includes the user@host syntax (indicated by the @ symbol), which signifies that a file is being copied to a remote system. Simulation and Validation Windows This rule can be validated by running a script that generates a high volume of DNS lookups for unique, non-existent subdomains. Test Command (PowerShell) : 1..200 | ForEach-Object { $subdomain = -join ((65..90) + (97..122) | Get-Random -Count 15 | ForEach-Object { [char]$_ }); try { Resolve-DnsName -Name \"$subdomain.example.com\" -ErrorAction SilentlyContinue } catch {} } This PowerShell one-liner runs a loop 200 times. In each iteration, it generates a random 15-character string to act as a unique subdomain and performs a DNS lookup for [random_string].example.com. This activity generates 200 DNS queries for 200 unique subdomains from a single host, which will satisfy both threshold conditions and trigger the alert. Ubuntu This test simulates data exfiltration by using scp to send a file to a remote location (simulated using localhost). Test Command : Step 1: Create a dummy file to exfiltrate echo \"secret stuff\" > ~/exfil_this_file.txt Step 2: Exfiltrate the file using scp scp ~/exfil_this_file.txt $(whoami)@localhost:/tmp Description : This command uses scp with the user@host syntax ( $(whoami)@localhost ). This action simulates data being copied off the system and perfectly matches the rule's logic.","title":"Exfiltration Over Alternative Protocol"},{"location":"rules_created/exfiltration_over_alternative_protocol/#detection-rule-exfiltration-over-dns-tunneling","text":"Rule ID: 21890b79-0173-4afc-a46e-338635db2a75 Rule Name: Exfiltration (T1048: Exfiltration Over Alternative Protocol) MITRE ATT&CK Tactic: Exfiltration MITRE ATT&CK Technique: T1048.003, Exfiltration Over Alternative Protocol: DNS","title":"Detection Rule: Exfiltration Over DNS Tunneling"},{"location":"rules_created/exfiltration_over_alternative_protocol/#description","text":"This rule detects adversaries stealing data by transmitting it over the network. To evade security controls, attackers often use protocols that are different from their primary Command and Control (C2) channel. A common covert technique is DNS tunneling , where stolen data is encoded into a large volume of unique DNS queries. Because DNS is a fundamental protocol that is almost always allowed through firewalls, it provides a stealthy channel for exfiltration. A more overt method, common on Linux, is to use standard file transfer utilities like scp (secure copy) to send data directly to an attacker-controlled machine.","title":"Description"},{"location":"rules_created/exfiltration_over_alternative_protocol/#rule-derivation-from-log-analysis","text":"The logic for these rules was developed by identifying the unique footprints of different exfiltration methods.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/exfiltration_over_alternative_protocol/#1-defining-the-behavior","text":"DNS Tunneling (Windows) : This behavior is a \"DNS storm\" from a single host, characterized by both a very high volume of total DNS queries and a high number of unique subdomains being queried. Secure Copy (Ubuntu ): This behavior is the execution of the scp command with syntax indicating a file is being sent to a remote destination (i.e., user@host ).","title":"1. Defining the Behavior:"},{"location":"rules_created/exfiltration_over_alternative_protocol/#2-translating-behavior-to-log-fields","text":"Windows : The detection uses DNS logs, grouping by the source host and counting both total queries and unique domains ( winlog.event_data.TargetDomainName ). Ubuntu : The detection uses process logs, inspecting the process.name and the process.command_line for specific patterns.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/exfiltration_over_alternative_protocol/#detection-logic","text":"","title":"Detection Logic"},{"location":"rules_created/exfiltration_over_alternative_protocol/#windows-dns-tunneling","text":"This is a threshold-based rule that triggers when the volume and variety of DNS queries from a single host exceed a defined limit within the rule's time window. Query : event.category:network and event.dataset:dns Threshold : Group By : The rule groups DNS queries by the source host ( host.hostname.keyword or winlog.event_data.SourceIp.keyword ). Condition 1 (Volume) : The total number of DNS queries from a single host must be greater than or equal to 200. Condition 2 (Variety) : Within those queries, the number of unique domain names must be greater than or equal to 100. Query Explanation : The rule's logic is: \"Alert if any single host makes more than 200 DNS queries to at least 100 different domain names within a five-minute window.\" This is a strong indicator of automated data exfiltration using DNS.","title":"Windows: DNS Tunneling"},{"location":"rules_created/exfiltration_over_alternative_protocol/#ubuntu-exfiltration-via-scp","text":"This query looks for the use of scp to copy files to a remote destination. Query : process.name:\"scp\" and process.command_line:\"*@*\" Explanation : This query looks for any use of the scp command that includes the user@host syntax (indicated by the @ symbol), which signifies that a file is being copied to a remote system.","title":"Ubuntu: Exfiltration via scp"},{"location":"rules_created/exfiltration_over_alternative_protocol/#simulation-and-validation","text":"","title":"Simulation and Validation"},{"location":"rules_created/exfiltration_over_alternative_protocol/#windows","text":"This rule can be validated by running a script that generates a high volume of DNS lookups for unique, non-existent subdomains. Test Command (PowerShell) : 1..200 | ForEach-Object { $subdomain = -join ((65..90) + (97..122) | Get-Random -Count 15 | ForEach-Object { [char]$_ }); try { Resolve-DnsName -Name \"$subdomain.example.com\" -ErrorAction SilentlyContinue } catch {} } This PowerShell one-liner runs a loop 200 times. In each iteration, it generates a random 15-character string to act as a unique subdomain and performs a DNS lookup for [random_string].example.com. This activity generates 200 DNS queries for 200 unique subdomains from a single host, which will satisfy both threshold conditions and trigger the alert.","title":"Windows"},{"location":"rules_created/exfiltration_over_alternative_protocol/#ubuntu","text":"This test simulates data exfiltration by using scp to send a file to a remote location (simulated using localhost). Test Command : Step 1: Create a dummy file to exfiltrate echo \"secret stuff\" > ~/exfil_this_file.txt Step 2: Exfiltrate the file using scp scp ~/exfil_this_file.txt $(whoami)@localhost:/tmp Description : This command uses scp with the user@host syntax ( $(whoami)@localhost ). This action simulates data being copied off the system and perfectly matches the rule's logic.","title":"Ubuntu"},{"location":"rules_created/obfuscated_files_or_information/","text":"Detection Rule: Defense Evasion via Encoded PowerShell Command Rule ID: 9ddec47a-5d4c-465c-be29-ea27ce6340b8 Rule Name: Defense Evasion (T1027: Obfuscated Files or Information) MITRE ATT&CK Tactic: Defense Evasion MITRE ATT&CK Technique: T1027, Obfuscated Files or Information Description This rule detects attackers using obfuscation techniques to hide their commands, tools, or data from security software. By encoding commands or hiding files, adversaries can evade signature-based scanners and manual inspection. An alert from this rule is a strong indicator of intentional evasion. On Windows, a classic technique is using Base64-encoded PowerShell commands . This abuses a legitimate feature to hide malicious keywords from detection. On Linux, evasion can involve hiding data in less common locations like alternate data streams or simply storing tools and payloads in hidden \"dotfiles\" . Rule Derivation from Log Analysis The logic for this rule focuses on the specific artifacts of the obfuscation method, rather than the unreadable obfuscated content itself. 1. Defining the Behavior : The goal is to detect the execution of a command or tool that is specifically designed to handle obfuscated data. Windows : The key behavior is the execution of powershell.exe with a specific command-line switch ( -EncodedCommand ) that instructs it to decode and run a Base64 string. Linux : The behavior involves using a powerful utility like dd with a specific syntax ( of=*:* ) that indicates writing to a non-standard file stream. 2. Translating Behavior to Log Fields : This information is found within process creation logs: The executed process is in process.name (e.g., powershell.exe , dd ). The specific switches or arguments are in process.args or process.command_line . 3. Constructing the Rule : We identified the unique command-line arguments used for these techniques. The rule triggers when it sees a process launched with these high-fidelity indicators. While these features have legitimate uses, they are far more common in malicious and unauthorized activity. Detection Logic Windows This is a query-based rule that triggers on a single process creation event. Query : process.name : \"powershell.exe\" AND (process.args:\"-e\" OR process.args:\"-en\" OR process.args:\"-enc\" OR process.args:\"-encodedcommand\") Query Explanation : The query identifies events where the PowerShell interpreter is launched with arguments that specify an encoded command. The process.name : \"powershell.exe\" clause filters for events where the PowerShell process is started. The AND (...) clause provides the core logic, checking if the process arguments ( process.args ) contain any of the switches used to pass a Base64-encoded command string: -e, -en, -enc, or the full -encodedcommand. The rule triggers an alert if powershell.exe is executed with any of these specific command-line switches. Ubuntu: Hiding Data with dd Query : process.name:\"dd\" and process.command_line: \"*of=*:*\" This query looks for the use of the dd utility with a command line that contains of=*:* . This syntax can be used to write to an alternate data stream on certain file systems, a technique for hiding malicious data from normal view. Simulation and Validation Windows This rule can be validated by encoding a simple command into Base64 and executing it using the -EncodedCommand switch. Test Command (PowerShell) : powershell.exe -EncodedCommand dwBoAG8AYQBtAGkA This command executes PowerShell and instructs it to run an encoded command. The Base64 string dwBoAG8AYQBtAGkA decodes to the simple command whoami. The PowerShell process decodes the string and executes whoami in memory. This action, which uses powershell.exe and the -EncodedCommand switch (which can be shortened to -e, -en, or -enc ), directly matches the rule's logic and will generate an alert. Ubuntu This test simulates a simple but effective evasion technique: hiding a file by naming it with a leading dot. Test Command : echo \"hidden malware\" > ~/.im_not_a_virus This command creates a new file named .im_not_a_virus in the user's home directory. In Linux, files starting with a dot ( . ) are hidden from standard directory listings (like ls ). This simulates an attacker trying to hide their artifacts on the system and is a common form of defense evasion.","title":"Obfuscated Files or Information"},{"location":"rules_created/obfuscated_files_or_information/#detection-rule-defense-evasion-via-encoded-powershell-command","text":"Rule ID: 9ddec47a-5d4c-465c-be29-ea27ce6340b8 Rule Name: Defense Evasion (T1027: Obfuscated Files or Information) MITRE ATT&CK Tactic: Defense Evasion MITRE ATT&CK Technique: T1027, Obfuscated Files or Information","title":"Detection Rule: Defense Evasion via Encoded PowerShell Command"},{"location":"rules_created/obfuscated_files_or_information/#description","text":"This rule detects attackers using obfuscation techniques to hide their commands, tools, or data from security software. By encoding commands or hiding files, adversaries can evade signature-based scanners and manual inspection. An alert from this rule is a strong indicator of intentional evasion. On Windows, a classic technique is using Base64-encoded PowerShell commands . This abuses a legitimate feature to hide malicious keywords from detection. On Linux, evasion can involve hiding data in less common locations like alternate data streams or simply storing tools and payloads in hidden \"dotfiles\" .","title":"Description"},{"location":"rules_created/obfuscated_files_or_information/#rule-derivation-from-log-analysis","text":"The logic for this rule focuses on the specific artifacts of the obfuscation method, rather than the unreadable obfuscated content itself.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/obfuscated_files_or_information/#1-defining-the-behavior","text":"The goal is to detect the execution of a command or tool that is specifically designed to handle obfuscated data. Windows : The key behavior is the execution of powershell.exe with a specific command-line switch ( -EncodedCommand ) that instructs it to decode and run a Base64 string. Linux : The behavior involves using a powerful utility like dd with a specific syntax ( of=*:* ) that indicates writing to a non-standard file stream.","title":"1. Defining the Behavior:"},{"location":"rules_created/obfuscated_files_or_information/#2-translating-behavior-to-log-fields","text":"This information is found within process creation logs: The executed process is in process.name (e.g., powershell.exe , dd ). The specific switches or arguments are in process.args or process.command_line .","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/obfuscated_files_or_information/#3-constructing-the-rule","text":"We identified the unique command-line arguments used for these techniques. The rule triggers when it sees a process launched with these high-fidelity indicators. While these features have legitimate uses, they are far more common in malicious and unauthorized activity.","title":"3. Constructing the Rule:"},{"location":"rules_created/obfuscated_files_or_information/#detection-logic","text":"","title":"Detection Logic"},{"location":"rules_created/obfuscated_files_or_information/#windows","text":"This is a query-based rule that triggers on a single process creation event. Query : process.name : \"powershell.exe\" AND (process.args:\"-e\" OR process.args:\"-en\" OR process.args:\"-enc\" OR process.args:\"-encodedcommand\") Query Explanation : The query identifies events where the PowerShell interpreter is launched with arguments that specify an encoded command. The process.name : \"powershell.exe\" clause filters for events where the PowerShell process is started. The AND (...) clause provides the core logic, checking if the process arguments ( process.args ) contain any of the switches used to pass a Base64-encoded command string: -e, -en, -enc, or the full -encodedcommand. The rule triggers an alert if powershell.exe is executed with any of these specific command-line switches.","title":"Windows"},{"location":"rules_created/obfuscated_files_or_information/#ubuntu-hiding-data-with-dd","text":"Query : process.name:\"dd\" and process.command_line: \"*of=*:*\" This query looks for the use of the dd utility with a command line that contains of=*:* . This syntax can be used to write to an alternate data stream on certain file systems, a technique for hiding malicious data from normal view.","title":"Ubuntu: Hiding Data with dd"},{"location":"rules_created/obfuscated_files_or_information/#simulation-and-validation","text":"","title":"Simulation and Validation"},{"location":"rules_created/obfuscated_files_or_information/#windows_1","text":"This rule can be validated by encoding a simple command into Base64 and executing it using the -EncodedCommand switch. Test Command (PowerShell) : powershell.exe -EncodedCommand dwBoAG8AYQBtAGkA This command executes PowerShell and instructs it to run an encoded command. The Base64 string dwBoAG8AYQBtAGkA decodes to the simple command whoami. The PowerShell process decodes the string and executes whoami in memory. This action, which uses powershell.exe and the -EncodedCommand switch (which can be shortened to -e, -en, or -enc ), directly matches the rule's logic and will generate an alert.","title":"Windows"},{"location":"rules_created/obfuscated_files_or_information/#ubuntu","text":"This test simulates a simple but effective evasion technique: hiding a file by naming it with a leading dot. Test Command : echo \"hidden malware\" > ~/.im_not_a_virus This command creates a new file named .im_not_a_virus in the user's home directory. In Linux, files starting with a dot ( . ) are hidden from standard directory listings (like ls ). This simulates an attacker trying to hide their artifacts on the system and is a common form of defense evasion.","title":"Ubuntu"},{"location":"rules_created/os_credential_dumping/","text":"Detection Rule: OS Credential Dumping via LSASS Rule ID: 49fcd163-9359-4472-8f27-47315023d94a Rule Name: Credential Access (T1003: OS Credential Dumping) MITRE ATT&CK Tactic: Credential Access MITRE ATT&CK Technique: T1003, OS Credential Dumping Description This rule detects adversaries attempting to extract account login and credential material directly from the operating system. This is a critical step for attackers to escalate privileges and move laterally across a network. On Windows , a primary target for this is the Local Security Authority Subsystem Service (LSASS) process memory, which stores valuable credentials like password hashes for active users. On Linux , the equivalent is the /etc/shadow file, which contains the hashed passwords for all local user accounts. Rule Derivation from Log Analysis The logic for this rule is based on identifying highly suspicious activities directed at these critical credential stores. 1. Defining the Behavior : The goal is to detect unauthorized access to credential storage locations. Windows (Masquerading) : The provided rule detects a common precursor or accompanying technique where malware masquerades as the LSASS process to hide its activity. Any creation of lsass.exe by an unexpected parent process is a strong indicator of malicious intent. Linux (Direct Access) : The logic focuses on detecting direct, unauthorized access to the /etc/shadow file. Legitimate access to this file is rare and performed only by a few known system utilities. 2. Translating Behavior to Log Fields : Windows : The detection uses process creation logs, focusing on process.name and the parent process source.process.executable . Linux : The detection uses file access logs, focusing on file.path, event.action, and the process.name that is accessing the file. 3. Constructing the Rule : The query is constructed to specifically look for the creation of lsass.exe while excluding a shortlist of common system processes that might be false positives. Any other parent process is flagged as suspicious, providing a high-fidelity alert for this masquerading technique. Detection Logic Windows: LSASS Process Masquerading This is a query-based rule that triggers on a single process creation event. Query : event.category:process and event.action:\"Process Create\" and process.name:lsass.exe and source.process.executable:* and not source.process.executable:(\"C:\\\\Windows\\\\System32\\\\svchost.exe\" or \"C:\\\\Windows\\\\System32\\\\services.exe\") Query Explanation : The query identifies events where a process named lsass.exe is created by an unauthorized parent process. event.category:process and event.action:\"Process Create\" : This clause filters events to only include new process creations. process.name:lsass.exe : This specifically looks for the creation of a process with the name lsass.exe. not source.process.executable:(...) : This clause excludes legitimate system processes (svchost.exe, services.exe) from being flagged as the parent, reducing potential noise. The rule triggers an alert if lsass.exe is created by any process not on the exclusion list, which is highly anomalous behavior. Ubuntu: Unauthorized /etc/shadow Access This query alerts when a process other than a standard system utility attempts to read the /etc/shadow file. Query : file.path:\"/etc/shadow\" and event.action:\"opened\" and not process.name:(\"passwd\" or \"chage\" or \"useradd\" or \"login\") Direct access to /etc/shadow is highly suspicious. This query looks for any process reading this file that isn't a known, legitimate utility for managing passwords and users. Simulation and Validation Windows This rule can be validated by simulating a malware masquerading technique where a common utility is renamed to lsass.exe and executed. Test Command (PowerShell) : copy C:\\Windows\\System32\\whoami.exe C:\\Users\\Public\\lsass.exe C:\\Users\\Public\\lsass.exe This test first copies a harmless utility, whoami.exe, to a new location and renames it to lsass.exe . When the renamed file is executed, a new process named lsass.exe is created. The parent process will be the shell that executed the command (e.g., cmd.exe or powershell.exe), which is not on the rule's exclusion list. This action directly matches the rule's logic and will generate an alert. Ubuntu This test simulates a direct attempt to read the credential file. Test Command : sudo cat /etc/shadow This command uses cat to attempt to read the /etc/shadow file. Since cat is not a standard password management utility on the exclusion list, this action directly matches the rule's logic and will generate an alert.","title":"OS Credential Dumping"},{"location":"rules_created/os_credential_dumping/#detection-rule-os-credential-dumping-via-lsass","text":"Rule ID: 49fcd163-9359-4472-8f27-47315023d94a Rule Name: Credential Access (T1003: OS Credential Dumping) MITRE ATT&CK Tactic: Credential Access MITRE ATT&CK Technique: T1003, OS Credential Dumping","title":"Detection Rule: OS Credential Dumping via LSASS"},{"location":"rules_created/os_credential_dumping/#description","text":"This rule detects adversaries attempting to extract account login and credential material directly from the operating system. This is a critical step for attackers to escalate privileges and move laterally across a network. On Windows , a primary target for this is the Local Security Authority Subsystem Service (LSASS) process memory, which stores valuable credentials like password hashes for active users. On Linux , the equivalent is the /etc/shadow file, which contains the hashed passwords for all local user accounts.","title":"Description"},{"location":"rules_created/os_credential_dumping/#rule-derivation-from-log-analysis","text":"The logic for this rule is based on identifying highly suspicious activities directed at these critical credential stores.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/os_credential_dumping/#1-defining-the-behavior","text":"The goal is to detect unauthorized access to credential storage locations. Windows (Masquerading) : The provided rule detects a common precursor or accompanying technique where malware masquerades as the LSASS process to hide its activity. Any creation of lsass.exe by an unexpected parent process is a strong indicator of malicious intent. Linux (Direct Access) : The logic focuses on detecting direct, unauthorized access to the /etc/shadow file. Legitimate access to this file is rare and performed only by a few known system utilities.","title":"1. Defining the Behavior:"},{"location":"rules_created/os_credential_dumping/#2-translating-behavior-to-log-fields","text":"Windows : The detection uses process creation logs, focusing on process.name and the parent process source.process.executable . Linux : The detection uses file access logs, focusing on file.path, event.action, and the process.name that is accessing the file.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/os_credential_dumping/#3-constructing-the-rule","text":"The query is constructed to specifically look for the creation of lsass.exe while excluding a shortlist of common system processes that might be false positives. Any other parent process is flagged as suspicious, providing a high-fidelity alert for this masquerading technique.","title":"3. Constructing the Rule:"},{"location":"rules_created/os_credential_dumping/#detection-logic","text":"","title":"Detection Logic"},{"location":"rules_created/os_credential_dumping/#windows-lsass-process-masquerading","text":"This is a query-based rule that triggers on a single process creation event. Query : event.category:process and event.action:\"Process Create\" and process.name:lsass.exe and source.process.executable:* and not source.process.executable:(\"C:\\\\Windows\\\\System32\\\\svchost.exe\" or \"C:\\\\Windows\\\\System32\\\\services.exe\") Query Explanation : The query identifies events where a process named lsass.exe is created by an unauthorized parent process. event.category:process and event.action:\"Process Create\" : This clause filters events to only include new process creations. process.name:lsass.exe : This specifically looks for the creation of a process with the name lsass.exe. not source.process.executable:(...) : This clause excludes legitimate system processes (svchost.exe, services.exe) from being flagged as the parent, reducing potential noise. The rule triggers an alert if lsass.exe is created by any process not on the exclusion list, which is highly anomalous behavior.","title":"Windows: LSASS Process Masquerading"},{"location":"rules_created/os_credential_dumping/#ubuntu-unauthorized-etcshadow-access","text":"This query alerts when a process other than a standard system utility attempts to read the /etc/shadow file. Query : file.path:\"/etc/shadow\" and event.action:\"opened\" and not process.name:(\"passwd\" or \"chage\" or \"useradd\" or \"login\") Direct access to /etc/shadow is highly suspicious. This query looks for any process reading this file that isn't a known, legitimate utility for managing passwords and users.","title":"Ubuntu: Unauthorized /etc/shadow Access"},{"location":"rules_created/os_credential_dumping/#simulation-and-validation","text":"","title":"Simulation and Validation"},{"location":"rules_created/os_credential_dumping/#windows","text":"This rule can be validated by simulating a malware masquerading technique where a common utility is renamed to lsass.exe and executed. Test Command (PowerShell) : copy C:\\Windows\\System32\\whoami.exe C:\\Users\\Public\\lsass.exe C:\\Users\\Public\\lsass.exe This test first copies a harmless utility, whoami.exe, to a new location and renames it to lsass.exe . When the renamed file is executed, a new process named lsass.exe is created. The parent process will be the shell that executed the command (e.g., cmd.exe or powershell.exe), which is not on the rule's exclusion list. This action directly matches the rule's logic and will generate an alert.","title":"Windows"},{"location":"rules_created/os_credential_dumping/#ubuntu","text":"This test simulates a direct attempt to read the credential file. Test Command : sudo cat /etc/shadow This command uses cat to attempt to read the /etc/shadow file. Since cat is not a standard password management utility on the exclusion list, this action directly matches the rule's logic and will generate an alert.","title":"Ubuntu"},{"location":"rules_created/phishing/","text":"Detection Rule: Initial Access via Phishing Rule ID: 51bac7dd-1389-4819-8812-50dc46744934 Rule Name: Initial Access (T1566: Phishing) MITRE ATT&CK Tactic: Initial Access MITRE ATT&CK Technique: T1566, Phishing Description This rule detects a common initial access pattern where a Microsoft Office application (Word, Excel, etc.) launches a command-line or scripting interpreter. This behavior is highly indicative of a successful phishing attack where a user has opened a malicious document containing embedded macros or exploits. Adversaries use this technique to gain an initial foothold on a system. The script executed by the Office application typically serves as a \"dropper\" or \"downloader\" to fetch the next stage of the malware payload from an external server. Rule Derivation from Log Analysis The logic for this rule is based on identifying anomalous parent-child process relationships . Benign usage of Microsoft Office almost never involves the direct creation of a script interpreter. 1. Defining the Behavior : The core of the attack is an application executing malicious code. In system process logs, this is recorded as the application process (e.g., winword.exe or soffice.bin ) starting a new, separate process, such as powershell.exe or bash . The application is the parent, and the script interpreter is the child. 2. Translating Behavior to Log Fields : This relationship is directly observable in log data: The parent process is identified by the process.parent.name field. The child process is identified by the process.name field. 3. Constructing the Rule : The query was built to find this specific, high-fidelity malicious pattern. We created a list of common Office parent processes and a list of powerful script interpreters that are frequently abused by attackers. The rule then triggers an alert only when a process from the first list spawns a process from the second list. This specific parent-child combination is a very strong indicator of compromise. Detection Logic This is a query-based rule that triggers on a single event matching the specified process creation pattern. Windows Query : process.parent.name:(\"winword.exe\" or \"excel.exe\" or \"powerpnt.exe\" or \"outlook.exe\") and process.name:(\"powershell.exe\" or \"cmd.exe\" or \"wscript.exe\" or \"mshta.exe\") Breakdown : process.parent.name:(...): This part of the query looks for an event where the parent (creating) process is a Microsoft Office application like Word, Excel, PowerPoint, or Outlook. and: This logical operator requires both conditions to be true. process.name:(...): This part looks for the child (created) process being a common script interpreter such as PowerShell, Command Prompt, Windows Script Host, or MSHTA (which executes HTML application files). In short, the rule alerts when an Office application is used to launch a command shell or script engine. Ubuntu Query : process.parent.name:(\"thunderbird\" or \"soffice.bin\" or \"evince\") and process.name:(\"bash\" or \"sh\" or \"python\" or \"perl\") Breakdown : This query identifies when a common email client (thunderbird), office suite (soffice.bin for LibreOffice), or document viewer (evince) on Ubuntu spawns a shell or scripting interpreter (bash, python, etc.). Simulation and Validation Windows This rule can be validated by creating a macro-enabled Microsoft Word document that executes a simple command. Test Command (PowerShell) : Open Microsoft Word and create a new blank document. Press ALT + F11 to open the Visual Basic for Applications (VBA) editor. In the project window, double-click ThisDocument and paste the following code: VBA Sub AutoOpen() ` This macro will run automatically when the document is opened and macros are enabled. ` It launches PowerShell to execute the 'whoami command. CreateObject(\"WScript.Shell\").Run powershell.exe -c whoami, 0, True End Sub Save the document as a \"Word Macro-Enabled Document\" (.docm). Close and reopen the document on a monitored endpoint. When prompted, click \"Enable Content\". This action will cause winword.exe to spawn powershell.exe, which precisely matches the rule's logic and should trigger an alert. Ubuntu This command simulates the final stage of a phishing attack where a malicious script payload is executed after a user interacts with a malicious document or link. Test Command : `/bin/bash -c \"echo 'Malicious payload simulation'\"` This directly executes a command using /bin/bash . While this test doesn't spawn bash from a parent application like LibreOffice, it effectively mimics how a payload would be launched. It validates that the monitoring system can detect the execution of the malicious child process, which is a critical component of the overall detection","title":"Phishing"},{"location":"rules_created/phishing/#detection-rule-initial-access-via-phishing","text":"Rule ID: 51bac7dd-1389-4819-8812-50dc46744934 Rule Name: Initial Access (T1566: Phishing) MITRE ATT&CK Tactic: Initial Access MITRE ATT&CK Technique: T1566, Phishing","title":"Detection Rule: Initial Access via Phishing"},{"location":"rules_created/phishing/#description","text":"This rule detects a common initial access pattern where a Microsoft Office application (Word, Excel, etc.) launches a command-line or scripting interpreter. This behavior is highly indicative of a successful phishing attack where a user has opened a malicious document containing embedded macros or exploits. Adversaries use this technique to gain an initial foothold on a system. The script executed by the Office application typically serves as a \"dropper\" or \"downloader\" to fetch the next stage of the malware payload from an external server.","title":"Description"},{"location":"rules_created/phishing/#rule-derivation-from-log-analysis","text":"The logic for this rule is based on identifying anomalous parent-child process relationships . Benign usage of Microsoft Office almost never involves the direct creation of a script interpreter.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/phishing/#1-defining-the-behavior","text":"The core of the attack is an application executing malicious code. In system process logs, this is recorded as the application process (e.g., winword.exe or soffice.bin ) starting a new, separate process, such as powershell.exe or bash . The application is the parent, and the script interpreter is the child.","title":"1. Defining the Behavior:"},{"location":"rules_created/phishing/#2-translating-behavior-to-log-fields","text":"This relationship is directly observable in log data: The parent process is identified by the process.parent.name field. The child process is identified by the process.name field.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/phishing/#3-constructing-the-rule","text":"The query was built to find this specific, high-fidelity malicious pattern. We created a list of common Office parent processes and a list of powerful script interpreters that are frequently abused by attackers. The rule then triggers an alert only when a process from the first list spawns a process from the second list. This specific parent-child combination is a very strong indicator of compromise.","title":"3. Constructing the Rule:"},{"location":"rules_created/phishing/#detection-logic","text":"This is a query-based rule that triggers on a single event matching the specified process creation pattern.","title":"Detection Logic"},{"location":"rules_created/phishing/#windows","text":"Query : process.parent.name:(\"winword.exe\" or \"excel.exe\" or \"powerpnt.exe\" or \"outlook.exe\") and process.name:(\"powershell.exe\" or \"cmd.exe\" or \"wscript.exe\" or \"mshta.exe\") Breakdown : process.parent.name:(...): This part of the query looks for an event where the parent (creating) process is a Microsoft Office application like Word, Excel, PowerPoint, or Outlook. and: This logical operator requires both conditions to be true. process.name:(...): This part looks for the child (created) process being a common script interpreter such as PowerShell, Command Prompt, Windows Script Host, or MSHTA (which executes HTML application files). In short, the rule alerts when an Office application is used to launch a command shell or script engine.","title":"Windows"},{"location":"rules_created/phishing/#ubuntu","text":"Query : process.parent.name:(\"thunderbird\" or \"soffice.bin\" or \"evince\") and process.name:(\"bash\" or \"sh\" or \"python\" or \"perl\") Breakdown : This query identifies when a common email client (thunderbird), office suite (soffice.bin for LibreOffice), or document viewer (evince) on Ubuntu spawns a shell or scripting interpreter (bash, python, etc.).","title":"Ubuntu"},{"location":"rules_created/phishing/#simulation-and-validation","text":"","title":"Simulation and Validation"},{"location":"rules_created/phishing/#windows_1","text":"This rule can be validated by creating a macro-enabled Microsoft Word document that executes a simple command. Test Command (PowerShell) : Open Microsoft Word and create a new blank document. Press ALT + F11 to open the Visual Basic for Applications (VBA) editor. In the project window, double-click ThisDocument and paste the following code: VBA Sub AutoOpen() ` This macro will run automatically when the document is opened and macros are enabled. ` It launches PowerShell to execute the 'whoami command. CreateObject(\"WScript.Shell\").Run powershell.exe -c whoami, 0, True End Sub Save the document as a \"Word Macro-Enabled Document\" (.docm). Close and reopen the document on a monitored endpoint. When prompted, click \"Enable Content\". This action will cause winword.exe to spawn powershell.exe, which precisely matches the rule's logic and should trigger an alert.","title":"Windows"},{"location":"rules_created/phishing/#ubuntu_1","text":"This command simulates the final stage of a phishing attack where a malicious script payload is executed after a user interacts with a malicious document or link. Test Command : `/bin/bash -c \"echo 'Malicious payload simulation'\"` This directly executes a command using /bin/bash . While this test doesn't spawn bash from a parent application like LibreOffice, it effectively mimics how a payload would be launched. It validates that the monitoring system can detect the execution of the malicious child process, which is a critical component of the overall detection","title":"Ubuntu"},{"location":"rules_created/remote_services/","text":"Detection Rule: Lateral Movement via PsExec Rule ID: ec5fb1d6-1f59-428e-bfb0-0086cb81fded Rule Name: Lateral Movement (T1021: Remote Services) MITRE ATT&CK Tactic: Lateral Movement MITRE ATT&CK Technique: T1021.002, Remote Services: SMB/Windows Admin Shares Description This rule detects adversaries using legitimate remote access tools to move laterally from one compromised system to another within a network. By using built-in or common administrative tools, attackers can blend in with normal network traffic. On Windows , a classic and powerful tool for this is PsExec , which uses the SMB protocol to execute commands on remote hosts. On Linux , the universal tool for remote access is SSH (Secure Shell). This rule is designed to identify suspicious usage patterns of these tools that indicate lateral movement by an attacker. Rule Derivation from Log Analysis The logic for this rule is based on identifying the unique and predictable artifact created by PsExec on a target system. 1. Defining the Behavior : The goal is to detect a remote administration tool being used to access a system. Windows (PsExec) : When PsExec connects to a target, it copies and runs a temporary service executable named PSEXESVC.exe . The creation of this process is the unique footprint. Linux (SSH) : When a user logs in via SSH, an authentication event is generated. A successful login from an internal IP address using a password is a noteworthy event, as it could indicate an attacker reusing compromised credentials. 2. Translating Behavior to Log Fields : Windows : The detection uses process creation logs, focusing on the process.name. Linux : The detection uses authentication logs, focusing on event.action, ssh.method, and source.ip. Detection Logic Windows: PsExec Execution This is a query-based rule that triggers on a single process creation event. Query : event.category:process and process.name:PSEXESVC.exe Query Explanation : The query identifies the execution of the PsExec service executable. event.category:process :This clause filters events to only include process creations. and process.name:PSEXESVC.exe : This clause provides the core logic, triggering an alert if the name of the process being created is exactly PSEXESVC.exe. Ubuntu: Internal SSH with Password This query looks for interactive SSH sessions that use password authentication and originate from within the local network. Query : event.category:\"authentication\" and event.action:\"ssh_login\" and ssh.method:\"password\" and source.ip:\"10.0.0.0/8\" Explanation : This query looks for successful SSH logins that use a password and originate from an internal IP address . While this can be legitimate, security best practices often recommend key-based authentication for internal systems. An alert for password-based logins could indicate an attacker moving laterally with stolen credentials. Simulation and Validation Windows This rule can be validated by using PsExec from one machine to run a command on a monitored target machine. Test Command (PowerShell) : PsExec.exe \\\\<target_machine_ip> -s cmd.exe /c \"whoami\" Description : This command uses PsExec to connect to the target machine and run the whoami command with SYSTEM (-s) privileges. This will cause the PSEXESVC.exe process to be created and run on the , which directly matches the rule's logic and will generate an alert on the target. Ubuntu This test simulates lateral movement by using SSH to log in to the local machine. Test Command : ssh $(whoami)@localhost Description : This command initiates an SSH connection to localhost as the current user. If you authenticate with a password, this action will generate a log entry for a successful SSH login that matches the rule's logic, triggering an alert.","title":"Remote Services"},{"location":"rules_created/remote_services/#detection-rule-lateral-movement-via-psexec","text":"Rule ID: ec5fb1d6-1f59-428e-bfb0-0086cb81fded Rule Name: Lateral Movement (T1021: Remote Services) MITRE ATT&CK Tactic: Lateral Movement MITRE ATT&CK Technique: T1021.002, Remote Services: SMB/Windows Admin Shares","title":"Detection Rule: Lateral Movement via PsExec"},{"location":"rules_created/remote_services/#description","text":"This rule detects adversaries using legitimate remote access tools to move laterally from one compromised system to another within a network. By using built-in or common administrative tools, attackers can blend in with normal network traffic. On Windows , a classic and powerful tool for this is PsExec , which uses the SMB protocol to execute commands on remote hosts. On Linux , the universal tool for remote access is SSH (Secure Shell). This rule is designed to identify suspicious usage patterns of these tools that indicate lateral movement by an attacker.","title":"Description"},{"location":"rules_created/remote_services/#rule-derivation-from-log-analysis","text":"The logic for this rule is based on identifying the unique and predictable artifact created by PsExec on a target system.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/remote_services/#1-defining-the-behavior","text":"The goal is to detect a remote administration tool being used to access a system. Windows (PsExec) : When PsExec connects to a target, it copies and runs a temporary service executable named PSEXESVC.exe . The creation of this process is the unique footprint. Linux (SSH) : When a user logs in via SSH, an authentication event is generated. A successful login from an internal IP address using a password is a noteworthy event, as it could indicate an attacker reusing compromised credentials.","title":"1. Defining the Behavior:"},{"location":"rules_created/remote_services/#2-translating-behavior-to-log-fields","text":"Windows : The detection uses process creation logs, focusing on the process.name. Linux : The detection uses authentication logs, focusing on event.action, ssh.method, and source.ip.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/remote_services/#detection-logic","text":"","title":"Detection Logic"},{"location":"rules_created/remote_services/#windows-psexec-execution","text":"This is a query-based rule that triggers on a single process creation event. Query : event.category:process and process.name:PSEXESVC.exe Query Explanation : The query identifies the execution of the PsExec service executable. event.category:process :This clause filters events to only include process creations. and process.name:PSEXESVC.exe : This clause provides the core logic, triggering an alert if the name of the process being created is exactly PSEXESVC.exe.","title":"Windows: PsExec Execution"},{"location":"rules_created/remote_services/#ubuntu-internal-ssh-with-password","text":"This query looks for interactive SSH sessions that use password authentication and originate from within the local network. Query : event.category:\"authentication\" and event.action:\"ssh_login\" and ssh.method:\"password\" and source.ip:\"10.0.0.0/8\" Explanation : This query looks for successful SSH logins that use a password and originate from an internal IP address . While this can be legitimate, security best practices often recommend key-based authentication for internal systems. An alert for password-based logins could indicate an attacker moving laterally with stolen credentials.","title":"Ubuntu: Internal SSH with Password"},{"location":"rules_created/remote_services/#simulation-and-validation","text":"","title":"Simulation and Validation"},{"location":"rules_created/remote_services/#windows","text":"This rule can be validated by using PsExec from one machine to run a command on a monitored target machine. Test Command (PowerShell) : PsExec.exe \\\\<target_machine_ip> -s cmd.exe /c \"whoami\" Description : This command uses PsExec to connect to the target machine and run the whoami command with SYSTEM (-s) privileges. This will cause the PSEXESVC.exe process to be created and run on the , which directly matches the rule's logic and will generate an alert on the target.","title":"Windows"},{"location":"rules_created/remote_services/#ubuntu","text":"This test simulates lateral movement by using SSH to log in to the local machine. Test Command : ssh $(whoami)@localhost Description : This command initiates an SSH connection to localhost as the current user. If you authenticate with a password, this action will generate a log entry for a successful SSH login that matches the rule's logic, triggering an alert.","title":"Ubuntu"},{"location":"rules_created/system_information_discovery/","text":"Detection Rule: System Information Discovery Rule ID: 623df799-a310-464a-8294-15a0c7c7e1d8 Rule Name: Discovery (T1082: System Information Discovery) MITRE ATT&CK Tactic: Discovery MITRE ATT&CK Technique: T1082, System Information Discovery Description This rule detects post-compromise reconnaissance. Attackers run a series of built-in Windows utilities to gather information about the system (its identity, network, etc.) to plan their next move. While a single one of these commands is normal, a cluster of them in a short period strongly indicates an attacker is actively and manually exploring the compromised machine. Rule Derivation from Log Analysis The logic for this rule was derived by identifying a \"basket\" of legitimate Windows tools that are overwhelmingly favored by attackers for initial system reconnaissance. 1. Defining the Behavior : The goal is to detect an actor, having just landed on a machine, trying to orient themselves. They typically run a series of commands to answer basic questions: Who am I ( whoami )? What is this machine ( systeminfo )? What is its IP address ( ipconfig )? What network connections exist ( net )? What is running ( tasklist )? 2. Translating Behavior to Log Fields : This behavior is captured directly in process execution logs. The key field is process.name , which records the name of the executable that was launched. 3. Constructing the Rule : The query was built as a simple list of these key discovery-related executables. The rule's core value is not in flagging a single command, but in generating alerts that can be correlated. When multiple alerts from this rule fire from the same host in a short time window, it strongly suggests a manual discovery phase of an attack. Detection Logic Windows: Common Discovery Utilities This is a query-based rule that triggers on a single process creation event. Query : event.category : \"process\" AND process.name : (\"whoami.exe\" OR \"systeminfo.exe\" OR \"ipconfig.exe\" OR \"net.exe\" OR \"tasklist.exe\") Query Explanation : The query identifies the execution of specific system discovery commands. event.category : \"process\" : This clause filters events to only include process creations. AND process.name : (...) : This clause triggers if the name of the process being executed is one of the following common discovery tools: whoami.exe : Displays the current user's identity. systeminfo.exe : Displays detailed OS and hardware information. ipconfig.exe : Displays the host's IP configuration. net.exe : Used for a wide range of network information gathering. tasklist.exe : Lists currently running processes. Ubuntu: Common Discovery Utilities Query : event.action:\"executed\" and process.name:(\"whoami\" or \"hostname\" or \"uname\" or \"ifconfig\" or \"ip\" or \"netstat\") This query alerts on the execution of common Linux discovery tools used to find the current user ( whoami ), system information ( hostname , uname ), and network configuration ( ifconfig , ip , netstat ). Simulation and Validation Windows This rule can be validated by executing the targeted commands from a Command Prompt or PowerShell session. Test Command (PowerShell) : whoami hostname systeminfo ipconfig /all netstat -an tasklist This sequence of commands mimics an attacker performing initial reconnaissance on a host. Each command execution creates a process event that matches one of the names in the rule's query ( whoami.exe, systeminfo.exe , etc.), which will generate a corresponding alert. Ubuntu This test simulates an attacker efficiently chaining multiple discovery commands together in a single line. Test Command : whoami && hostname && uname -a && ip a This chain of commands is a common attacker shortcut that quickly provides the current username, system hostname, kernel version, and network interface configuration, triggering multiple alerts in rapid succession.","title":"System Information Discovery"},{"location":"rules_created/system_information_discovery/#detection-rule-system-information-discovery","text":"Rule ID: 623df799-a310-464a-8294-15a0c7c7e1d8 Rule Name: Discovery (T1082: System Information Discovery) MITRE ATT&CK Tactic: Discovery MITRE ATT&CK Technique: T1082, System Information Discovery","title":"Detection Rule: System Information Discovery"},{"location":"rules_created/system_information_discovery/#description","text":"This rule detects post-compromise reconnaissance. Attackers run a series of built-in Windows utilities to gather information about the system (its identity, network, etc.) to plan their next move. While a single one of these commands is normal, a cluster of them in a short period strongly indicates an attacker is actively and manually exploring the compromised machine.","title":"Description"},{"location":"rules_created/system_information_discovery/#rule-derivation-from-log-analysis","text":"The logic for this rule was derived by identifying a \"basket\" of legitimate Windows tools that are overwhelmingly favored by attackers for initial system reconnaissance.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/system_information_discovery/#1-defining-the-behavior","text":"The goal is to detect an actor, having just landed on a machine, trying to orient themselves. They typically run a series of commands to answer basic questions: Who am I ( whoami )? What is this machine ( systeminfo )? What is its IP address ( ipconfig )? What network connections exist ( net )? What is running ( tasklist )?","title":"1. Defining the Behavior:"},{"location":"rules_created/system_information_discovery/#2-translating-behavior-to-log-fields","text":"This behavior is captured directly in process execution logs. The key field is process.name , which records the name of the executable that was launched.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/system_information_discovery/#3-constructing-the-rule","text":"The query was built as a simple list of these key discovery-related executables. The rule's core value is not in flagging a single command, but in generating alerts that can be correlated. When multiple alerts from this rule fire from the same host in a short time window, it strongly suggests a manual discovery phase of an attack.","title":"3. Constructing the Rule:"},{"location":"rules_created/system_information_discovery/#detection-logic","text":"","title":"Detection Logic"},{"location":"rules_created/system_information_discovery/#windows-common-discovery-utilities","text":"This is a query-based rule that triggers on a single process creation event. Query : event.category : \"process\" AND process.name : (\"whoami.exe\" OR \"systeminfo.exe\" OR \"ipconfig.exe\" OR \"net.exe\" OR \"tasklist.exe\") Query Explanation : The query identifies the execution of specific system discovery commands. event.category : \"process\" : This clause filters events to only include process creations. AND process.name : (...) : This clause triggers if the name of the process being executed is one of the following common discovery tools: whoami.exe : Displays the current user's identity. systeminfo.exe : Displays detailed OS and hardware information. ipconfig.exe : Displays the host's IP configuration. net.exe : Used for a wide range of network information gathering. tasklist.exe : Lists currently running processes.","title":"Windows: Common Discovery Utilities"},{"location":"rules_created/system_information_discovery/#ubuntu-common-discovery-utilities","text":"Query : event.action:\"executed\" and process.name:(\"whoami\" or \"hostname\" or \"uname\" or \"ifconfig\" or \"ip\" or \"netstat\") This query alerts on the execution of common Linux discovery tools used to find the current user ( whoami ), system information ( hostname , uname ), and network configuration ( ifconfig , ip , netstat ).","title":"Ubuntu: Common Discovery Utilities"},{"location":"rules_created/system_information_discovery/#simulation-and-validation","text":"","title":"Simulation and Validation"},{"location":"rules_created/system_information_discovery/#windows","text":"This rule can be validated by executing the targeted commands from a Command Prompt or PowerShell session. Test Command (PowerShell) : whoami hostname systeminfo ipconfig /all netstat -an tasklist This sequence of commands mimics an attacker performing initial reconnaissance on a host. Each command execution creates a process event that matches one of the names in the rule's query ( whoami.exe, systeminfo.exe , etc.), which will generate a corresponding alert.","title":"Windows"},{"location":"rules_created/system_information_discovery/#ubuntu","text":"This test simulates an attacker efficiently chaining multiple discovery commands together in a single line. Test Command : whoami && hostname && uname -a && ip a This chain of commands is a common attacker shortcut that quickly provides the current username, system hostname, kernel version, and network interface configuration, triggering multiple alerts in rapid succession.","title":"Ubuntu"},{"location":"setup/art_setup/","text":"Atomic Red Team Setup and Execution Guide for Windows Introduction Atomic Red Team is an open-source library of tests mapped to the MITRE ATT&CK framework, used to safely simulate adversary behavior. This guide covers its installation and execution on a Windows VM. Note on Applicability: This guide is exclusively for setting up and running Atomic Red Team in a Microsoft Windows environment. All commands and procedures use Windows PowerShell and are not intended for Linux or macOS. Prerequisites Before you begin, ensure your Windows VM meets the following requirements: Administrator Access : You must be able to run commands with administrative - privileges. PowerShell : Windows PowerShell 5.1 or later is required. This is installed by default on modern Windows versions (Windows 10/11, Server 2016+). Internet Connection : Required for the initial download and installation of the framework and atomic tests. Installation and Setup The installation process involves setting up the PowerShell execution policy, installing the framework module, and downloading the library of atomic tests. Open PowerShell as an Administrator Click the Start Menu. Type PowerShell. Right-click on Windows PowerShell and select Run as administrator. Set the PowerShell Execution Policy This command lowers the security policy for the current session to allow locally-run scripts, which is necessary to install and run the Atomic Red Team framework. In the administrative PowerShell window, run the following command: Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope CurrentUser-Force Install the Atomic Red Team PowerShell Module This command downloads and installs the core execution engine from the official PowerShell Gallery. Run the following command. When prompted to install from an untrusted repository, type Y and press Enter. Install-Module -Name AtomicRedTeam -Scope CurrentUser-Force Import the Module and Download Atomics After installing the engine, this step loads its commands into your PowerShell session and downloads the actual test files (\"atomics\") from the official GitHub repository. Run these two commands in sequence: 1. Import the module : Import-Module AtomicRedTeam 2. Download the atomic tests : Install-AtomicRedTeam -getAtomics This will download the tests to your local machine, typically into the C:\\AtomicRedTeam directory. You have now successfully installed Atomic Red Team! Executing Atomic Tests With the framework installed, you can now simulate adversary techniques. The primary command you will use is Invoke-AtomicTest. 1. List Available Tests for a Technique Before running an attack, it's best to see what specific tests are available for a given MITRE ATT&CK technique. We'll use T1059.001: Command and Scripting Interpreter: PowerShell as an example. Run the following command to see a brief list of available tests for this technique: Invoke-AtomicTest T1059.001 -ShowDetailsBrief You will see an output listing the different atomic tests available, each with a unique test number, name, and supported platform. 2. Check for Test Prerequisites Some tests require specific software or configurations to be in place before they can run. This command checks for those dependencies. Let's check the prerequisites for T1548.002: Abuse Elevation Control Mechanism: Bypass User Account Control : Invoke-AtomicTest T1548.002 -GetPrereqs If any prerequisites are missing, the framework will provide commands to help you install or configure them. 3. Run a Specific Atomic Test This is the core command that executes the simulated attack. We will run a test for T1003.001: OS Credential Dumping: LSASS Memory , which simulates an attacker dumping credentials from memory. Run the following command: Invoke-AtomicTest T1003.001 The framework will execute the test defined in the T1003.001 YAML file. You will see output describing the command being run. If you have a security tool (like Sysmon or an EDR) running, this is the action it should detect and alert on. 4. Clean Up After a Test Many tests have corresponding cleanup commands to revert any changes made to the system, such as removing created files or registry keys. To revert the changes made by the previous test (if any), run the same command with the -Cleanup flag: Invoke-AtomicTest T1003.001 -Cleanup This ensures your VM is returned to its original state.","title":"Atomic Red Team"},{"location":"setup/art_setup/#atomic-red-team-setup-and-execution-guide-for-windows","text":"","title":"Atomic Red Team Setup and Execution Guide for Windows"},{"location":"setup/art_setup/#introduction","text":"Atomic Red Team is an open-source library of tests mapped to the MITRE ATT&CK framework, used to safely simulate adversary behavior. This guide covers its installation and execution on a Windows VM.","title":"Introduction"},{"location":"setup/art_setup/#note-on-applicability","text":"This guide is exclusively for setting up and running Atomic Red Team in a Microsoft Windows environment.","title":"Note on Applicability:"},{"location":"setup/art_setup/#all-commands-and-procedures-use-windows-powershell-and-are-not-intended-for-linux-or-macos","text":"","title":"All commands and procedures use Windows PowerShell and are not intended for Linux or macOS."},{"location":"setup/art_setup/#prerequisites","text":"Before you begin, ensure your Windows VM meets the following requirements: Administrator Access : You must be able to run commands with administrative - privileges. PowerShell : Windows PowerShell 5.1 or later is required. This is installed by default on modern Windows versions (Windows 10/11, Server 2016+). Internet Connection : Required for the initial download and installation of the framework and atomic tests.","title":"Prerequisites"},{"location":"setup/art_setup/#installation-and-setup","text":"The installation process involves setting up the PowerShell execution policy, installing the framework module, and downloading the library of atomic tests.","title":"Installation and Setup"},{"location":"setup/art_setup/#open-powershell-as-an-administrator","text":"Click the Start Menu. Type PowerShell. Right-click on Windows PowerShell and select Run as administrator.","title":"Open PowerShell as an Administrator"},{"location":"setup/art_setup/#set-the-powershell-execution-policy","text":"This command lowers the security policy for the current session to allow locally-run scripts, which is necessary to install and run the Atomic Red Team framework. In the administrative PowerShell window, run the following command: Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope CurrentUser-Force","title":"Set the PowerShell Execution Policy"},{"location":"setup/art_setup/#install-the-atomic-red-team-powershell-module","text":"This command downloads and installs the core execution engine from the official PowerShell Gallery. Run the following command. When prompted to install from an untrusted repository, type Y and press Enter. Install-Module -Name AtomicRedTeam -Scope CurrentUser-Force","title":"Install the Atomic Red Team PowerShell Module"},{"location":"setup/art_setup/#import-the-module-and-download-atomics","text":"After installing the engine, this step loads its commands into your PowerShell session and downloads the actual test files (\"atomics\") from the official GitHub repository. Run these two commands in sequence: 1. Import the module : Import-Module AtomicRedTeam 2. Download the atomic tests : Install-AtomicRedTeam -getAtomics This will download the tests to your local machine, typically into the C:\\AtomicRedTeam directory. You have now successfully installed Atomic Red Team!","title":"Import the Module and Download Atomics"},{"location":"setup/art_setup/#executing-atomic-tests","text":"With the framework installed, you can now simulate adversary techniques. The primary command you will use is Invoke-AtomicTest.","title":"Executing Atomic Tests"},{"location":"setup/art_setup/#1-list-available-tests-for-a-technique","text":"Before running an attack, it's best to see what specific tests are available for a given MITRE ATT&CK technique. We'll use T1059.001: Command and Scripting Interpreter: PowerShell as an example. Run the following command to see a brief list of available tests for this technique: Invoke-AtomicTest T1059.001 -ShowDetailsBrief You will see an output listing the different atomic tests available, each with a unique test number, name, and supported platform.","title":"1. List Available Tests for a Technique"},{"location":"setup/art_setup/#2-check-for-test-prerequisites","text":"Some tests require specific software or configurations to be in place before they can run. This command checks for those dependencies. Let's check the prerequisites for T1548.002: Abuse Elevation Control Mechanism: Bypass User Account Control : Invoke-AtomicTest T1548.002 -GetPrereqs If any prerequisites are missing, the framework will provide commands to help you install or configure them.","title":"2. Check for Test Prerequisites"},{"location":"setup/art_setup/#3-run-a-specific-atomic-test","text":"This is the core command that executes the simulated attack. We will run a test for T1003.001: OS Credential Dumping: LSASS Memory , which simulates an attacker dumping credentials from memory. Run the following command: Invoke-AtomicTest T1003.001 The framework will execute the test defined in the T1003.001 YAML file. You will see output describing the command being run. If you have a security tool (like Sysmon or an EDR) running, this is the action it should detect and alert on.","title":"3. Run a Specific Atomic Test"},{"location":"setup/art_setup/#4-clean-up-after-a-test","text":"Many tests have corresponding cleanup commands to revert any changes made to the system, such as removing created files or registry keys. To revert the changes made by the previous test (if any), run the same command with the -Cleanup flag: Invoke-AtomicTest T1003.001 -Cleanup This ensures your VM is returned to its original state.","title":"4. Clean Up After a Test"},{"location":"setup/elk_setup/","text":"ELK Stack Setup and Configuration Guide Introduction This document provides a detailed guide for deploying the ELK Stack \u2014 (Elasticsearch, Logstash, Kibana) \u2014 using Docker Compose . The ELK Stack is a powerful open-source platform for searching, analyzing, and visualizing log data in real-time. Components Elasticsearch : A distributed search and analytics engine. Logstash : A server-side data processing pipeline that ingests data from multiple sources, transforms it, and sends it to a \"stash\" like Elasticsearch. Kibana : A visualization layer that works on top of Elasticsearch, providing users with tools to explore their data through charts, tables, and dashboards. This guide prioritizes a secure-by-default setup, including the generation and use of passwords for all built-in users. Architecture Overview: Component Roles This guide sets up a central ELK stack that can receive data from various sources, including both Windows and Ubuntu VMs. Elasticsearch and Kibana are the core components and are required for both Windows and Ubuntu . They store, index, and visualize all incoming data. Logstash is included in this stack specifically to serve as a data processor for log shippers like Winlogbeat , which is the method used for the Windows VM setup . Modern solutions like Elastic Agent (used for the Ubuntu VM) can send data directly to Elasticsearch, bypassing the need for a separate Logstash instance for that data path Prerequisites: Docker and Docker Compose Installation Before you begin, you must have Docker Engine and Docker Compose installed on your system. Please follow the official instructions to download and install both components for your specific operating system. Official Documentation Project Structure For a clean setup, organize your files in a root directory (e.g., my-elk-stack) like this: my-elk-stack/ \u251c\u2500\u2500 docker-compose.yml \u2514\u2500\u2500 logstash/ \u2514\u2500\u2500 pipeline/ \u2514\u2500\u2500 logstash.conf docker-compose.yml : Defines the three services, their configurations, networks, and volumes. logstash/pipeline/logstash.conf : Contains the configuration for the Logstash pipeline. Installation and Configuration with Docker Compose Follow these steps sequentially to build and secure your stack. Create the Logstash Pipeline Configuration (For processing Windows logs) This file defines how Logstash receives data, what to do with it, and where to send it. Create the file logstash/pipeline/logstash.conf and add the following configuration: ./logstash/pipeline/logstash.conf input { beats { port => 5044 } tcp { port => 5000 codec => json_lines } } output { elasticsearch { hosts => [\"http://elasticsearch:9200\"] index => \"logstash-%{+YYYY.MM.dd}\" # Use environment variables for secure credential management user => \"${ELASTICSEARCH_USERNAME}\" password => \"${ELASTICSEARCH_PASSWORD}\" } } Create the Initial docker-compose.yml This file outlines the ELK services (Elasticsearch, Logstash, Kibana) without any sensitive passwords yet. Create the docker-compose.yml file in your project's root directory: ./docker-compose.yml ```yaml version: '3.8' services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:8.12.2 container_name: elasticsearch environment: - discovery.type=single-node - \"ES_JAVA_OPTS=-Xms1g -Xmx1g\" - xpack.security.enabled=true volumes: - esdata:/usr/share/elasticsearch/data ports: - \"9200:9200\" - \"9300:9300\" networks: - elknet logstash: image: docker.elastic.co/logstash/logstash:8.12.2 container_name: logstash volumes: - ./logstash/pipeline:/usr/share/logstash/pipeline:ro ports: - \"5044:5044\" - \"5000:5000/tcp\" - \"5000:5000/udp\" networks: - elknet depends_on: - elasticsearch kibana: image: docker.elastic.co/kibana/kibana:8.12.2 container_name: kibana environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 ports: - \"5601:5601\" networks: - elknet depends_on: - elasticsearch volumes: esdata: driver: local networks: elknet: driver: bridge Generate Passwords for Built-in Users This crucial security step creates unique, secure passwords for all internal ELK users. Start only the Elasticsearch container: bash docker-compose up -d elasticsearch Run the password generation script and save the output : bash docker exec -it elasticsearch /usr/share/elasticsearch/bin/elasticsearch-setup-passwords auto Stop the container: bash docker-compose down Generate a Kibana Encryption Key This key encrypts sensitive data saved within Kibana, such as alerting configurations. Generate a 32-character key using one of the commands below and save the output: Bash For Linux/macOS/WSL bash openssl rand -hex 16 Alternative command bash head /dev/urandom | tr -dc A-Za-z0-9 | head -c 32 Update docker-compose.yml with Credentials and Keys Here, you embed the generated passwords and keys into your service definitions to secure the stack. Edit your docker-compose.yml file and add the environment variables shown below. Replace the placeholder values (e.g., your_elastic_password) with the actual credentials you saved. ./docker-compose.yml (Final Version) version: '3.8' services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:8.12.2 container_name: elasticsearch environment: - discovery.type=single-node - \"ES_JAVA_OPTS=-Xms1g -Xmx1g\" - xpack.security.enabled=true # --- ADD PASSWORD FOR THE 'elastic' SUPERUSER --- - ELASTIC_PASSWORD=your_elastic_password volumes: - esdata:/usr/share/elasticsearch/data ports: - \"9200:9200\" - \"9300:9300\" networks: - elknet logstash: image: docker.elastic.co/logstash/logstash:8.12.2 container_name: logstash volumes: - ./logstash/pipeline:/usr/share/logstash/pipeline:ro ports: - \"5044:5044\" - \"5000:5000/tcp\" - \"5000:5000/udp\" # --- ADD CREDENTIALS FOR LOGSTASH TO CONNECT TO ELASTICSEARCH --- environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 - ELASTICSEARCH_USERNAME=logstash_system - ELASTICSEARCH_PASSWORD=your_logstash_system_password networks: - elknet depends_on: - elasticsearch kibana: image: docker.elastic.co/kibana/kibana:8.12.2 container_name: kibana environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 # --- ADD CREDENTIALS FOR KIBANA TO CONNECT TO ELASTICSEARCH --- - ELASTICSEARCH_USERNAME=kibana_system - ELASTICSEARCH_PASSWORD=your_kibana_system_password # --- ADD THE KIBANA ENCRYPTION KEY --- - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=your_generated_32_character_key ports: - \"5601:5601\" networks: - elknet depends_on: - elasticsearch volumes: esdata: driver: local networks: elknet: driver: bridge Launch the Full ELK Stack This command reads your final docker-compose.yml file and starts all the configured containers. bash docker-compose up -d Access Kibana This is the final step to log in and access the ELK Stack's powerful user interface. URL Username : elastic Password : The your_elastic_password you saved in Step 4.3. Post-Setup: Basic Configuration in Kibana Creating a Data View This tells Kibana which Elasticsearch index pattern to use for discovering and analyzing your data. Navigate to Stack Management > Kibana > Data Views. Click Create data view. For the Name, enter logstash-*. Select a Timestamp field (usually @timestamp). Click Create data view. Creating Visualizations and Dashboards This is where you build charts, graphs, and unified dashboards to visualize your log data. Navigate to the Visualize Library and click Create visualization. Choose a visualization type (e.g., Pie, Bar Chart) and select your logstash-* data view. Configure and save the visualization. Navigate to the Dashboard section, create a new dashboard, and add your saved visualizations from the library.","title":"ELK"},{"location":"setup/elk_setup/#elk-stack-setup-and-configuration-guide","text":"","title":"ELK Stack Setup and Configuration Guide"},{"location":"setup/elk_setup/#introduction","text":"This document provides a detailed guide for deploying the ELK Stack \u2014 (Elasticsearch, Logstash, Kibana) \u2014 using Docker Compose . The ELK Stack is a powerful open-source platform for searching, analyzing, and visualizing log data in real-time.","title":"Introduction"},{"location":"setup/elk_setup/#components","text":"Elasticsearch : A distributed search and analytics engine. Logstash : A server-side data processing pipeline that ingests data from multiple sources, transforms it, and sends it to a \"stash\" like Elasticsearch. Kibana : A visualization layer that works on top of Elasticsearch, providing users with tools to explore their data through charts, tables, and dashboards. This guide prioritizes a secure-by-default setup, including the generation and use of passwords for all built-in users.","title":"Components"},{"location":"setup/elk_setup/#architecture-overview-component-roles","text":"This guide sets up a central ELK stack that can receive data from various sources, including both Windows and Ubuntu VMs. Elasticsearch and Kibana are the core components and are required for both Windows and Ubuntu . They store, index, and visualize all incoming data. Logstash is included in this stack specifically to serve as a data processor for log shippers like Winlogbeat , which is the method used for the Windows VM setup . Modern solutions like Elastic Agent (used for the Ubuntu VM) can send data directly to Elasticsearch, bypassing the need for a separate Logstash instance for that data path","title":"Architecture Overview: Component Roles"},{"location":"setup/elk_setup/#prerequisites-docker-and-docker-compose-installation","text":"Before you begin, you must have Docker Engine and Docker Compose installed on your system. Please follow the official instructions to download and install both components for your specific operating system. Official Documentation","title":"Prerequisites: Docker and Docker Compose Installation"},{"location":"setup/elk_setup/#project-structure","text":"For a clean setup, organize your files in a root directory (e.g., my-elk-stack) like this: my-elk-stack/ \u251c\u2500\u2500 docker-compose.yml \u2514\u2500\u2500 logstash/ \u2514\u2500\u2500 pipeline/ \u2514\u2500\u2500 logstash.conf docker-compose.yml : Defines the three services, their configurations, networks, and volumes. logstash/pipeline/logstash.conf : Contains the configuration for the Logstash pipeline.","title":"Project Structure"},{"location":"setup/elk_setup/#installation-and-configuration-with-docker-compose","text":"Follow these steps sequentially to build and secure your stack.","title":"Installation and Configuration with Docker Compose"},{"location":"setup/elk_setup/#create-the-logstash-pipeline-configuration-for-processing-windows-logs","text":"This file defines how Logstash receives data, what to do with it, and where to send it. Create the file logstash/pipeline/logstash.conf and add the following configuration: ./logstash/pipeline/logstash.conf input { beats { port => 5044 } tcp { port => 5000 codec => json_lines } } output { elasticsearch { hosts => [\"http://elasticsearch:9200\"] index => \"logstash-%{+YYYY.MM.dd}\" # Use environment variables for secure credential management user => \"${ELASTICSEARCH_USERNAME}\" password => \"${ELASTICSEARCH_PASSWORD}\" } }","title":"Create the Logstash Pipeline Configuration (For processing Windows logs)"},{"location":"setup/elk_setup/#create-the-initial-docker-composeyml","text":"This file outlines the ELK services (Elasticsearch, Logstash, Kibana) without any sensitive passwords yet. Create the docker-compose.yml file in your project's root directory: ./docker-compose.yml ```yaml version: '3.8' services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:8.12.2 container_name: elasticsearch environment: - discovery.type=single-node - \"ES_JAVA_OPTS=-Xms1g -Xmx1g\" - xpack.security.enabled=true volumes: - esdata:/usr/share/elasticsearch/data ports: - \"9200:9200\" - \"9300:9300\" networks: - elknet logstash: image: docker.elastic.co/logstash/logstash:8.12.2 container_name: logstash volumes: - ./logstash/pipeline:/usr/share/logstash/pipeline:ro ports: - \"5044:5044\" - \"5000:5000/tcp\" - \"5000:5000/udp\" networks: - elknet depends_on: - elasticsearch kibana: image: docker.elastic.co/kibana/kibana:8.12.2 container_name: kibana environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 ports: - \"5601:5601\" networks: - elknet depends_on: - elasticsearch volumes: esdata: driver: local networks: elknet: driver: bridge","title":"Create the Initial docker-compose.yml"},{"location":"setup/elk_setup/#generate-passwords-for-built-in-users","text":"This crucial security step creates unique, secure passwords for all internal ELK users. Start only the Elasticsearch container: bash docker-compose up -d elasticsearch Run the password generation script and save the output : bash docker exec -it elasticsearch /usr/share/elasticsearch/bin/elasticsearch-setup-passwords auto Stop the container: bash docker-compose down","title":"Generate Passwords for Built-in Users"},{"location":"setup/elk_setup/#generate-a-kibana-encryption-key","text":"This key encrypts sensitive data saved within Kibana, such as alerting configurations. Generate a 32-character key using one of the commands below and save the output: Bash","title":"Generate a Kibana Encryption Key"},{"location":"setup/elk_setup/#for-linuxmacoswsl","text":"bash openssl rand -hex 16","title":"For Linux/macOS/WSL"},{"location":"setup/elk_setup/#alternative-command","text":"bash head /dev/urandom | tr -dc A-Za-z0-9 | head -c 32","title":"Alternative command"},{"location":"setup/elk_setup/#update-docker-composeyml-with-credentials-and-keys","text":"Here, you embed the generated passwords and keys into your service definitions to secure the stack. Edit your docker-compose.yml file and add the environment variables shown below. Replace the placeholder values (e.g., your_elastic_password) with the actual credentials you saved. ./docker-compose.yml (Final Version) version: '3.8' services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:8.12.2 container_name: elasticsearch environment: - discovery.type=single-node - \"ES_JAVA_OPTS=-Xms1g -Xmx1g\" - xpack.security.enabled=true # --- ADD PASSWORD FOR THE 'elastic' SUPERUSER --- - ELASTIC_PASSWORD=your_elastic_password volumes: - esdata:/usr/share/elasticsearch/data ports: - \"9200:9200\" - \"9300:9300\" networks: - elknet logstash: image: docker.elastic.co/logstash/logstash:8.12.2 container_name: logstash volumes: - ./logstash/pipeline:/usr/share/logstash/pipeline:ro ports: - \"5044:5044\" - \"5000:5000/tcp\" - \"5000:5000/udp\" # --- ADD CREDENTIALS FOR LOGSTASH TO CONNECT TO ELASTICSEARCH --- environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 - ELASTICSEARCH_USERNAME=logstash_system - ELASTICSEARCH_PASSWORD=your_logstash_system_password networks: - elknet depends_on: - elasticsearch kibana: image: docker.elastic.co/kibana/kibana:8.12.2 container_name: kibana environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 # --- ADD CREDENTIALS FOR KIBANA TO CONNECT TO ELASTICSEARCH --- - ELASTICSEARCH_USERNAME=kibana_system - ELASTICSEARCH_PASSWORD=your_kibana_system_password # --- ADD THE KIBANA ENCRYPTION KEY --- - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=your_generated_32_character_key ports: - \"5601:5601\" networks: - elknet depends_on: - elasticsearch volumes: esdata: driver: local networks: elknet: driver: bridge","title":"Update docker-compose.yml with Credentials and Keys"},{"location":"setup/elk_setup/#launch-the-full-elk-stack","text":"This command reads your final docker-compose.yml file and starts all the configured containers. bash docker-compose up -d","title":"Launch the Full ELK Stack"},{"location":"setup/elk_setup/#access-kibana","text":"This is the final step to log in and access the ELK Stack's powerful user interface. URL Username : elastic Password : The your_elastic_password you saved in Step 4.3.","title":"Access Kibana"},{"location":"setup/elk_setup/#post-setup-basic-configuration-in-kibana","text":"","title":"Post-Setup: Basic Configuration in Kibana"},{"location":"setup/elk_setup/#creating-a-data-view","text":"This tells Kibana which Elasticsearch index pattern to use for discovering and analyzing your data. Navigate to Stack Management > Kibana > Data Views. Click Create data view. For the Name, enter logstash-*. Select a Timestamp field (usually @timestamp). Click Create data view.","title":"Creating a Data View"},{"location":"setup/elk_setup/#creating-visualizations-and-dashboards","text":"This is where you build charts, graphs, and unified dashboards to visualize your log data. Navigate to the Visualize Library and click Create visualization. Choose a visualization type (e.g., Pie, Bar Chart) and select your logstash-* data view. Configure and save the visualization. Navigate to the Dashboard section, create a new dashboard, and add your saved visualizations from the library.","title":"Creating Visualizations and Dashboards"},{"location":"setup/vm_setup/","text":"Environment Setup Guide This guide provides step-by-step instructions to configure the complete lab environment required for this project. Following these steps ensures that you have a functional ELK Stack ready to receive and analyze logs for threat detection. Pre-installation for Windows VM This phase involves gathering all the necessary software before starting the installation process. Windows 11 Disk Image (ISO) This is the operating system that will serve as our target endpoint. Description: A Windows 11 ISO file is a complete copy of the Windows 11 installation media, required by the virtual machine manager to install the OS. Instructions: Navigate to the official Microsoft Windows 11 Download page . Under the \"Download Windows 11 Disk Image (ISO)\" section, select \"Windows 11 (multi-edition ISO)\". Click \"Download\", choose your product language, and click \"Confirm\". Click the \"64-bit Download\" button to save the ISO file to your computer. VirtIO Drivers These are specialized drivers that boost the performance of your virtual machine. Description: VirtIO provides a set of high-performance drivers for virtualized hardware, such as network cards and disk controllers. Using them allows the guest OS (Windows) to communicate more efficiently with the host hypervisor (QEMU/KVM), resulting in significantly better I/O performance. Instructions: Go to the Proxmox VE Wiki for Windows VirtIO Drivers . Download the latest stable VirtIO driver ISO file. The direct link is typically named virtio-win-x.x.xxx.iso. Installation for Windows VM This phase covers the setup of the virtualization platform and the installation of the Windows 11 guest OS. QEMU/KVM & Virtual Machine Manager This is the software that will create and run your virtual machine. Description: QEMU is an emulator, and KVM (Kernel-based Virtual Machine) is a Linux kernel module that allows the kernel to act as a hypervisor. Together, they provide an efficient, hardware-accelerated virtualization solution. virt-manager provides a user-friendly graphical interface to manage them. Instructions: Check for Virtualization Support : Open a terminal on your Linux host and run egrep -c '(vmx|svm)' /proc/cpuinfo . A result greater than 0 means your CPU supports virtualization. Ensure it is enabled in your BIOS/UEFI. Install Packages (for Debian/Ubuntu-based systems): sudo apt update sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virt-manager Restart and Enable Services : After installation, restart, enable, and start the virtualization service. sudo systemctl restart libvirt.service sudo systemctl enable libvirt.service It is also a good practice to log out and log back in, or reboot your machine, to ensure all changes are applied. Windows 11 VM Creation and Driver Setup Now you'll create the VM and install Windows along with the performance drivers. Instructions: Launch Virtual Machine Manager ( virt-manager ) from your applications menu or terminal. Click the \"Create a new virtual machine\" icon. Select \"Local install media (ISO image or CDROM)\" and click \"Forward\". Click \"Browse Local\" and select the Windows 11 ISO you downloaded. Click \"Forward\". Allocate at least 4 GB (4096 MB) of RAM and 2 CPU cores. Click \"Forward\". Create a virtual disk of at least 64 GB. Click \"Forward\". On the final screen, check the box for \"Customize configuration before install\" and click \"Finish\". In the customization window, click \"Add Hardware\". Select \"Storage\", choose \"CDROM device\", and click \"Manage\". Click \"Browse Local\" and select the VirtIO driver ISO you downloaded. Click \"Finish\". Click \"Begin Installation\" . During the Windows setup, when you reach the \"Where do you want to install Windows?\" screen, your disk will likely not be visible. Click \"Load driver\" , then \"Browse\". Navigate to the VirtIO CD drive, find the amd64\\w11 folder inside the viostor directory, and select it. Click \"OK\". The storage driver will load, and your virtual disk will appear. You can now proceed with the Windows installation as usual. After Windows is installed and running, open File Explorer, go to the VirtIO CD drive, and run the virtio-win-guest-tools installer to install all remaining drivers automatically. Post-installation: Fleet Server and Agent Deployment After the Windows VM is running, you will deploy and configure the security agents needed for log collection. Got it. Here is the guide restructured into three parts, with the Fleet Server and agent deployments combined into logical subparts under \"Post-installation.\" Part 1: Pre-installation for Windows 11 VM This phase involves gathering all the necessary software before starting the Windows 11 installation process. Windows 11 Disk Image (ISO) This is the operating system that will serve as our target endpoint. Description: A Windows 11 ISO file is a complete copy of the Windows 11 installation media, required by the virtual machine manager to install the OS. Instructions: Navigate to the official Microsoft Windows 11 Download page. Under the \"Download Windows 11 Disk Image (ISO)\" section, select \"Windows 11 (multi-edition ISO)\". Click \"Download\", choose your product language, and click \"Confirm\". Click the \"64-bit Download\" button to save the ISO file to your computer. VirtIO Drivers These are specialized drivers that boost the performance of your Windows virtual machine. Description: VirtIO provides a set of high-performance drivers for virtualized hardware, such as network cards and disk controllers. Using them allows the guest OS (Windows) to communicate more efficiently with the host hypervisor (QEMU/KVM), resulting in significantly better I/O performance. Instructions: Go to the Proxmox VE Wiki for Windows VirtIO Drivers. Download the latest stable VirtIO driver ISO file. The direct link is typically named virtio-win-x.x.xxx.iso. Part 2: Installation of Windows 11 VM This phase covers the setup of the virtualization platform and the installation of the Windows 11 guest OS. QEMU/KVM & Virtual Machine Manager This is the software that will create and run your virtual machine. Description: QEMU is an emulator, and KVM (Kernel-based Virtual Machine) is a Linux kernel module that allows the kernel to act as a hypervisor. Together, they provide an efficient, hardware-accelerated virtualization solution. virt-manager provides a user-friendly graphical interface to manage them. Instructions: Check for Virtualization Support: Open a terminal on your Linux host and run egrep -c '(vmx|svm)' /proc/cpuinfo. A result greater than 0 means your CPU supports virtualization. Ensure it is enabled in your BIOS/UEFI. Install Packages (for Debian/Ubuntu-based systems): Bash sudo apt update sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virt-manager Restart and Enable Services: After installation, restart, enable, and start the virtualization service. Bash sudo systemctl restart libvirt.service sudo systemctl enable libvirt.service It is also a good practice to log out and log back in, or reboot your machine, to ensure all changes are applied. Windows 11 VM Creation and Driver Setup Now you'll create the VM and install Windows along with the performance drivers. Instructions: Launch Virtual Machine Manager (virt-manager). Create a new VM using your Windows 11 ISO, allocating at least 4 GB of RAM and 2 CPU cores, with a virtual disk of at least 64 GB. On the final screen, check the box for \"Customize configuration before install\". In the customization window, add a new CDROM device and load the VirtIO driver ISO into it. Begin the installation. When asked where to install Windows, the disk will be missing. Click \"Load driver\", browse to the VirtIO CD, navigate to amd64\\w11 in the viostor directory, and select it. Your virtual disk will now appear. Proceed with the installation. After Windows is running, run the virtio-win-guest-tools installer from the VirtIO CD drive to install all remaining drivers. Part 3: Post-installation: Fleet Server and Agent Deployment After the VMs are running, you will set up the central management server (Fleet) and deploy the agents needed for log collection. 1. Ubuntu & Fleet Server Setup This section covers setting up the Fleet Server and then deploying the Elastic Agent to an Ubuntu VM. 1. Set up the Fleet Server The Fleet Server is the control plane that manages all your Elastic Agents. Description : Agents check in with the Fleet Server for policy updates and send their data through it. It must be reachable by all your agents. For this guide, we'll install it on the same Linux host where your Elastic Stack is running. Instructions : Log in to Kibana and navigate to Management > Fleet. Click Add Fleet Server. You will be guided to create a policy and will be presented with an installation script. Specify the Host URL for your Fleet Server (e.g., https://<your_host_ip>:8220 ). Kibana will generate a customized command. Copy the command provided in your UI, as it contains unique keys. Open a terminal on your host, paste the command, and execute it. The script will download, install, and start the Elastic Agent in \"Fleet Server mode\". Verify in the Fleet UI that the agent appears online. 2. Deploy the Elastic Agent to an Ubuntu VM With the Fleet Server running, you can now enroll agents from your endpoint VMs. Instructions : In Kibana, go to Management > Fleet > Agents and click the \"Add agent\" button. Follow the on-screen prompts, selecting an agent policy (e.g., the default policy with \"System\" and \"Elastic Defend\" integrations). Kibana will generate a simple enrollment command. Copy this command and run it in the terminal on your Ubuntu VM. It will automatically install the agent, enroll it with your Fleet Server, and start sending data. 2. Windows 11 VM: Security Agent Setup This section covers the classic setup for deep security visibility on Windows using Sysmon and Winlogbeat. 1. Enable Group Policy Editor ( gpedit.msc ) and Advanced Logging This tool allows you to enable detailed system auditing that isn't on by default. Description : The Group Policy Editor (gpedit.msc) is a Windows administration tool used to configure system and user settings. We will use it to enable Advanced Audit Policies that generate high-value security events, such as detailed process creation logs with command-line arguments. Note: gpedit.msc is not available on Windows Home editions, but can be enabled with a script. Instructions : 1. Enable gpedit.msc (if using Windows Home) : - Open Notepad and paste the following code: @echo off echo Checking for permissions... net session >nul 2>&1 if %errorlevel% neq 0 ( echo Administrator permissions required. echo Please run this script as an administrator. pause exit ) echo Enabling Group Policy Editor... pushd \"%~dp0\" set \"package_path=%SystemRoot%\\servicing\\Packages\" set \"search_pattern1=Microsoft-Windows-GroupPolicy-ClientTools-Package~*.mum\" set \"search_pattern2=Microsoft-Windows-GroupPolicy-ClientExtensions-Package~*.mum\" echo Searching for packages... dir /b \"%package_path%\\%search_pattern1%\" > gpedit_list.txt dir /b \"%package_path%\\%search_pattern2%\" >> gpedit_list.txt echo Installing packages... for /f %%i in ('findstr /i . gpedit_list.txt 2^>nul') do ( echo Installing %%i dism /online /norestart /add-package:\"%package_path%\\%%i\" ) echo Cleaning up... del gpedit_list.txt echo Process completed. You can now try running gpedit.msc. pause Save the file as gpedit-enabler.bat and run it as an Administrator. 2. Enable Advanced Audit Policies : Press Win + R, type gpedit.msc, and press Enter. Navigate to Computer Configuration -> Windows Settings -> Security Settings -> Advanced Audit Policy Configuration -> System Audit Policies. Go to Detailed Tracking and double-click \"Audit Process Creation\". Check the boxes for both \"Success\" and \"Failure\" and click \"OK\". This will enable logging for Event ID 4688, which includes command-line details. 2. Sysmon (System Monitor) Setup Sysmon is a powerful tool that provides deep visibility into system activity. Description : Sysmon is a free tool from Microsoft Sysinternals that monitors and logs system activity to the Windows Event Log. It provides highly detailed information about process creation, network connections, file changes, and more, which are invaluable for threat detection. Instructions : Download Sysmon from the Microsoft Sysinternals page . Download a trusted, community-vetted configuration file. The SwiftOnSecurity configuration is an excellent starting point. Download the sysmonconfig-export.xml file. Place both the Sysmon64.exe executable and the configuration file ( sysmonconfig-export.xml ) in the same directory (e.g., C:\\Sysmon ). Open PowerShell as an Administrator, navigate to the directory, and run the installation command: .\\Sysmon64.exe -accepteula -i sysmonconfig-export.xml Sysmon is now installed and actively logging events to Applications and Services Logs/Microsoft/Windows/Sysmon/Operational . 3. Winlogbeat Setup This agent will collect all your logs and send them to your analysis server. Description : Winlogbeat is a lightweight data shipper from Elastic that is installed on your Windows VM. It tails Windows event logs (including the ones generated by Sysmon), and forwards them to a central Logstash or Elasticsearch server for analysis and visualization. Instructions : Download Winlogbeat from the Elastic downloads page . Unzip the file to a location like C:\\Program Files\\Winlogbeat . Navigate to the Winlogbeat directory and open the winlogbeat.yml configuration file in a text editor like Notepad++. Configure the input: Ensure Winlogbeat collects the Sysmon logs. winlogbeat.event_logs: - name: Application - name: Security - name: System - name: Microsoft-Windows-Sysmon/Operational ignore_older: 72h Configure the output: Point it to your Logstash or Elasticsearch instance. Replace the IP address accordingly. output.logstash: hosts: [\"192.168.1.100:5044\"] Example for Elasticsearch (comment out the Logstash section if using this) output.elasticsearch: hosts: [\"192.168.1.100:9200\"] Save the winlogbeat.yml file. Open PowerShell as an Administrator, navigate to the Winlogbeat directory, and run the following scripts to install and start the service: .\\install-service-winlogbeat.ps1 Start-Service winlogbeat Winlogbeat is now running as a service and forwarding logs from your Windows 11 VM.","title":"Virtual Machine"},{"location":"setup/vm_setup/#environment-setup-guide","text":"This guide provides step-by-step instructions to configure the complete lab environment required for this project. Following these steps ensures that you have a functional ELK Stack ready to receive and analyze logs for threat detection.","title":"Environment Setup Guide"},{"location":"setup/vm_setup/#pre-installation-for-windows-vm","text":"This phase involves gathering all the necessary software before starting the installation process.","title":"Pre-installation for Windows VM"},{"location":"setup/vm_setup/#windows-11-disk-image-iso","text":"This is the operating system that will serve as our target endpoint.","title":"Windows 11 Disk Image (ISO)"},{"location":"setup/vm_setup/#description","text":"A Windows 11 ISO file is a complete copy of the Windows 11 installation media, required by the virtual machine manager to install the OS.","title":"Description:"},{"location":"setup/vm_setup/#instructions","text":"Navigate to the official Microsoft Windows 11 Download page . Under the \"Download Windows 11 Disk Image (ISO)\" section, select \"Windows 11 (multi-edition ISO)\". Click \"Download\", choose your product language, and click \"Confirm\". Click the \"64-bit Download\" button to save the ISO file to your computer.","title":"Instructions:"},{"location":"setup/vm_setup/#virtio-drivers","text":"These are specialized drivers that boost the performance of your virtual machine.","title":"VirtIO Drivers"},{"location":"setup/vm_setup/#description_1","text":"VirtIO provides a set of high-performance drivers for virtualized hardware, such as network cards and disk controllers. Using them allows the guest OS (Windows) to communicate more efficiently with the host hypervisor (QEMU/KVM), resulting in significantly better I/O performance.","title":"Description:"},{"location":"setup/vm_setup/#instructions_1","text":"Go to the Proxmox VE Wiki for Windows VirtIO Drivers . Download the latest stable VirtIO driver ISO file. The direct link is typically named virtio-win-x.x.xxx.iso.","title":"Instructions:"},{"location":"setup/vm_setup/#installation-for-windows-vm","text":"This phase covers the setup of the virtualization platform and the installation of the Windows 11 guest OS.","title":"Installation for Windows VM"},{"location":"setup/vm_setup/#qemukvm-virtual-machine-manager","text":"This is the software that will create and run your virtual machine.","title":"QEMU/KVM &amp; Virtual Machine Manager"},{"location":"setup/vm_setup/#description_2","text":"QEMU is an emulator, and KVM (Kernel-based Virtual Machine) is a Linux kernel module that allows the kernel to act as a hypervisor. Together, they provide an efficient, hardware-accelerated virtualization solution. virt-manager provides a user-friendly graphical interface to manage them.","title":"Description:"},{"location":"setup/vm_setup/#instructions_2","text":"Check for Virtualization Support : Open a terminal on your Linux host and run egrep -c '(vmx|svm)' /proc/cpuinfo . A result greater than 0 means your CPU supports virtualization. Ensure it is enabled in your BIOS/UEFI. Install Packages (for Debian/Ubuntu-based systems): sudo apt update sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virt-manager Restart and Enable Services : After installation, restart, enable, and start the virtualization service. sudo systemctl restart libvirt.service sudo systemctl enable libvirt.service It is also a good practice to log out and log back in, or reboot your machine, to ensure all changes are applied.","title":"Instructions:"},{"location":"setup/vm_setup/#windows-11-vm-creation-and-driver-setup","text":"Now you'll create the VM and install Windows along with the performance drivers.","title":"Windows 11 VM Creation and Driver Setup"},{"location":"setup/vm_setup/#instructions_3","text":"Launch Virtual Machine Manager ( virt-manager ) from your applications menu or terminal. Click the \"Create a new virtual machine\" icon. Select \"Local install media (ISO image or CDROM)\" and click \"Forward\". Click \"Browse Local\" and select the Windows 11 ISO you downloaded. Click \"Forward\". Allocate at least 4 GB (4096 MB) of RAM and 2 CPU cores. Click \"Forward\". Create a virtual disk of at least 64 GB. Click \"Forward\". On the final screen, check the box for \"Customize configuration before install\" and click \"Finish\". In the customization window, click \"Add Hardware\". Select \"Storage\", choose \"CDROM device\", and click \"Manage\". Click \"Browse Local\" and select the VirtIO driver ISO you downloaded. Click \"Finish\". Click \"Begin Installation\" . During the Windows setup, when you reach the \"Where do you want to install Windows?\" screen, your disk will likely not be visible. Click \"Load driver\" , then \"Browse\". Navigate to the VirtIO CD drive, find the amd64\\w11 folder inside the viostor directory, and select it. Click \"OK\". The storage driver will load, and your virtual disk will appear. You can now proceed with the Windows installation as usual. After Windows is installed and running, open File Explorer, go to the VirtIO CD drive, and run the virtio-win-guest-tools installer to install all remaining drivers automatically.","title":"Instructions:"},{"location":"setup/vm_setup/#post-installation-fleet-server-and-agent-deployment","text":"After the Windows VM is running, you will deploy and configure the security agents needed for log collection. Got it. Here is the guide restructured into three parts, with the Fleet Server and agent deployments combined into logical subparts under \"Post-installation.\"","title":"Post-installation: Fleet Server and Agent Deployment"},{"location":"setup/vm_setup/#part-1-pre-installation-for-windows-11-vm","text":"This phase involves gathering all the necessary software before starting the Windows 11 installation process. Windows 11 Disk Image (ISO) This is the operating system that will serve as our target endpoint. Description: A Windows 11 ISO file is a complete copy of the Windows 11 installation media, required by the virtual machine manager to install the OS. Instructions: Navigate to the official Microsoft Windows 11 Download page. Under the \"Download Windows 11 Disk Image (ISO)\" section, select \"Windows 11 (multi-edition ISO)\". Click \"Download\", choose your product language, and click \"Confirm\". Click the \"64-bit Download\" button to save the ISO file to your computer. VirtIO Drivers These are specialized drivers that boost the performance of your Windows virtual machine. Description: VirtIO provides a set of high-performance drivers for virtualized hardware, such as network cards and disk controllers. Using them allows the guest OS (Windows) to communicate more efficiently with the host hypervisor (QEMU/KVM), resulting in significantly better I/O performance. Instructions: Go to the Proxmox VE Wiki for Windows VirtIO Drivers. Download the latest stable VirtIO driver ISO file. The direct link is typically named virtio-win-x.x.xxx.iso.","title":"Part 1: Pre-installation for Windows 11 VM"},{"location":"setup/vm_setup/#part-2-installation-of-windows-11-vm","text":"This phase covers the setup of the virtualization platform and the installation of the Windows 11 guest OS. QEMU/KVM & Virtual Machine Manager This is the software that will create and run your virtual machine. Description: QEMU is an emulator, and KVM (Kernel-based Virtual Machine) is a Linux kernel module that allows the kernel to act as a hypervisor. Together, they provide an efficient, hardware-accelerated virtualization solution. virt-manager provides a user-friendly graphical interface to manage them. Instructions: Check for Virtualization Support: Open a terminal on your Linux host and run egrep -c '(vmx|svm)' /proc/cpuinfo. A result greater than 0 means your CPU supports virtualization. Ensure it is enabled in your BIOS/UEFI. Install Packages (for Debian/Ubuntu-based systems): Bash sudo apt update sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virt-manager Restart and Enable Services: After installation, restart, enable, and start the virtualization service. Bash sudo systemctl restart libvirt.service sudo systemctl enable libvirt.service It is also a good practice to log out and log back in, or reboot your machine, to ensure all changes are applied. Windows 11 VM Creation and Driver Setup Now you'll create the VM and install Windows along with the performance drivers. Instructions: Launch Virtual Machine Manager (virt-manager). Create a new VM using your Windows 11 ISO, allocating at least 4 GB of RAM and 2 CPU cores, with a virtual disk of at least 64 GB. On the final screen, check the box for \"Customize configuration before install\". In the customization window, add a new CDROM device and load the VirtIO driver ISO into it. Begin the installation. When asked where to install Windows, the disk will be missing. Click \"Load driver\", browse to the VirtIO CD, navigate to amd64\\w11 in the viostor directory, and select it. Your virtual disk will now appear. Proceed with the installation. After Windows is running, run the virtio-win-guest-tools installer from the VirtIO CD drive to install all remaining drivers.","title":"Part 2: Installation of Windows 11 VM"},{"location":"setup/vm_setup/#part-3-post-installation-fleet-server-and-agent-deployment","text":"After the VMs are running, you will set up the central management server (Fleet) and deploy the agents needed for log collection.","title":"Part 3: Post-installation: Fleet Server and Agent Deployment"},{"location":"setup/vm_setup/#1-ubuntu-fleet-server-setup","text":"This section covers setting up the Fleet Server and then deploying the Elastic Agent to an Ubuntu VM. 1. Set up the Fleet Server The Fleet Server is the control plane that manages all your Elastic Agents. Description : Agents check in with the Fleet Server for policy updates and send their data through it. It must be reachable by all your agents. For this guide, we'll install it on the same Linux host where your Elastic Stack is running. Instructions : Log in to Kibana and navigate to Management > Fleet. Click Add Fleet Server. You will be guided to create a policy and will be presented with an installation script. Specify the Host URL for your Fleet Server (e.g., https://<your_host_ip>:8220 ). Kibana will generate a customized command. Copy the command provided in your UI, as it contains unique keys. Open a terminal on your host, paste the command, and execute it. The script will download, install, and start the Elastic Agent in \"Fleet Server mode\". Verify in the Fleet UI that the agent appears online. 2. Deploy the Elastic Agent to an Ubuntu VM With the Fleet Server running, you can now enroll agents from your endpoint VMs. Instructions : In Kibana, go to Management > Fleet > Agents and click the \"Add agent\" button. Follow the on-screen prompts, selecting an agent policy (e.g., the default policy with \"System\" and \"Elastic Defend\" integrations). Kibana will generate a simple enrollment command. Copy this command and run it in the terminal on your Ubuntu VM. It will automatically install the agent, enroll it with your Fleet Server, and start sending data.","title":"1. Ubuntu &amp; Fleet Server Setup"},{"location":"setup/vm_setup/#2-windows-11-vm-security-agent-setup","text":"This section covers the classic setup for deep security visibility on Windows using Sysmon and Winlogbeat.","title":"2. Windows 11 VM: Security Agent Setup"},{"location":"setup/vm_setup/#1-enable-group-policy-editor-gpeditmsc-and-advanced-logging","text":"This tool allows you to enable detailed system auditing that isn't on by default. Description : The Group Policy Editor (gpedit.msc) is a Windows administration tool used to configure system and user settings. We will use it to enable Advanced Audit Policies that generate high-value security events, such as detailed process creation logs with command-line arguments. Note: gpedit.msc is not available on Windows Home editions, but can be enabled with a script. Instructions : 1. Enable gpedit.msc (if using Windows Home) : - Open Notepad and paste the following code: @echo off echo Checking for permissions... net session >nul 2>&1 if %errorlevel% neq 0 ( echo Administrator permissions required. echo Please run this script as an administrator. pause exit ) echo Enabling Group Policy Editor... pushd \"%~dp0\" set \"package_path=%SystemRoot%\\servicing\\Packages\" set \"search_pattern1=Microsoft-Windows-GroupPolicy-ClientTools-Package~*.mum\" set \"search_pattern2=Microsoft-Windows-GroupPolicy-ClientExtensions-Package~*.mum\" echo Searching for packages... dir /b \"%package_path%\\%search_pattern1%\" > gpedit_list.txt dir /b \"%package_path%\\%search_pattern2%\" >> gpedit_list.txt echo Installing packages... for /f %%i in ('findstr /i . gpedit_list.txt 2^>nul') do ( echo Installing %%i dism /online /norestart /add-package:\"%package_path%\\%%i\" ) echo Cleaning up... del gpedit_list.txt echo Process completed. You can now try running gpedit.msc. pause Save the file as gpedit-enabler.bat and run it as an Administrator. 2. Enable Advanced Audit Policies : Press Win + R, type gpedit.msc, and press Enter. Navigate to Computer Configuration -> Windows Settings -> Security Settings -> Advanced Audit Policy Configuration -> System Audit Policies. Go to Detailed Tracking and double-click \"Audit Process Creation\". Check the boxes for both \"Success\" and \"Failure\" and click \"OK\". This will enable logging for Event ID 4688, which includes command-line details.","title":"1. Enable Group Policy Editor (gpedit.msc) and Advanced Logging"},{"location":"setup/vm_setup/#2-sysmon-system-monitor-setup","text":"Sysmon is a powerful tool that provides deep visibility into system activity. Description : Sysmon is a free tool from Microsoft Sysinternals that monitors and logs system activity to the Windows Event Log. It provides highly detailed information about process creation, network connections, file changes, and more, which are invaluable for threat detection. Instructions : Download Sysmon from the Microsoft Sysinternals page . Download a trusted, community-vetted configuration file. The SwiftOnSecurity configuration is an excellent starting point. Download the sysmonconfig-export.xml file. Place both the Sysmon64.exe executable and the configuration file ( sysmonconfig-export.xml ) in the same directory (e.g., C:\\Sysmon ). Open PowerShell as an Administrator, navigate to the directory, and run the installation command: .\\Sysmon64.exe -accepteula -i sysmonconfig-export.xml Sysmon is now installed and actively logging events to Applications and Services Logs/Microsoft/Windows/Sysmon/Operational .","title":"2. Sysmon (System Monitor) Setup"},{"location":"setup/vm_setup/#3-winlogbeat-setup","text":"This agent will collect all your logs and send them to your analysis server. Description : Winlogbeat is a lightweight data shipper from Elastic that is installed on your Windows VM. It tails Windows event logs (including the ones generated by Sysmon), and forwards them to a central Logstash or Elasticsearch server for analysis and visualization. Instructions : Download Winlogbeat from the Elastic downloads page . Unzip the file to a location like C:\\Program Files\\Winlogbeat . Navigate to the Winlogbeat directory and open the winlogbeat.yml configuration file in a text editor like Notepad++. Configure the input: Ensure Winlogbeat collects the Sysmon logs. winlogbeat.event_logs: - name: Application - name: Security - name: System - name: Microsoft-Windows-Sysmon/Operational ignore_older: 72h Configure the output: Point it to your Logstash or Elasticsearch instance. Replace the IP address accordingly. output.logstash: hosts: [\"192.168.1.100:5044\"] Example for Elasticsearch (comment out the Logstash section if using this) output.elasticsearch: hosts: [\"192.168.1.100:9200\"] Save the winlogbeat.yml file. Open PowerShell as an Administrator, navigate to the Winlogbeat directory, and run the following scripts to install and start the service: .\\install-service-winlogbeat.ps1 Start-Service winlogbeat Winlogbeat is now running as a service and forwarding logs from your Windows 11 VM.","title":"3. Winlogbeat Setup"}]}