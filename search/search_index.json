{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the APT Detection Project This project provides a comprehensive and validated set of threat detection rules for the ELK Stack (Elasticsearch, Logstash, & Kibana) , designed to identify adversary behaviors across the entire Advanced Persistent Threat (APT) lifecycle. The primary goal is to equip security analysts and threat hunters with practical, high-fidelity detection logic mapped directly to the MITRE ATT&CK\u00ae framework . Each rule is built from a structured workflow of threat simulation, log analysis, and rigorous validation to ensure accuracy and minimize false positives. Getting Started If you're new to the project, here's the recommended path: Understand the Methodology : Read the Project Workflow page to learn about the structured process used to create and validate each detection rule. Explore the Lifecycle : Browse the APT Threat Lifecycle to see how detections are mapped to specific adversary tactics. Find a Rule : Go to the Rules Created section for a complete list of all detection rules with their KQL queries. \ud83d\udcd6 Documentation Structure This documentation is organized into four main sections to help you find what you need quickly. Environment Setup This section provides detailed instructions and configurations for setting up the entire lab environment. * Virtual Machine Setup ELK Setup Atomic Red Team Setup Project Workflow This section details the end-to-end methodology for rule development. It covers the complete cycle from threat simulation with Atomic Red Team to log analysis, KQL rule creation, and final validation. View the Full Workflow APT Threat Lifecycle This is the strategic overview of the project. It breaks down a sophisticated cyberattack into 12 distinct stages based on the MITRE ATT&CK framework and links to the relevant detections for each stage. Explore the Lifecycle Rules Created This is the central repository for all detection logic. It contains a list of every finalized rule, its purpose, and the KQL query ready for deployment in Kibana. Browse All Rules","title":"Introduction"},{"location":"#welcome-to-the-apt-detection-project","text":"This project provides a comprehensive and validated set of threat detection rules for the ELK Stack (Elasticsearch, Logstash, & Kibana) , designed to identify adversary behaviors across the entire Advanced Persistent Threat (APT) lifecycle. The primary goal is to equip security analysts and threat hunters with practical, high-fidelity detection logic mapped directly to the MITRE ATT&CK\u00ae framework . Each rule is built from a structured workflow of threat simulation, log analysis, and rigorous validation to ensure accuracy and minimize false positives.","title":"Welcome to the APT Detection Project"},{"location":"#getting-started","text":"If you're new to the project, here's the recommended path: Understand the Methodology : Read the Project Workflow page to learn about the structured process used to create and validate each detection rule. Explore the Lifecycle : Browse the APT Threat Lifecycle to see how detections are mapped to specific adversary tactics. Find a Rule : Go to the Rules Created section for a complete list of all detection rules with their KQL queries.","title":"Getting Started"},{"location":"#documentation-structure","text":"This documentation is organized into four main sections to help you find what you need quickly.","title":"\ud83d\udcd6 Documentation Structure"},{"location":"#environment-setup","text":"This section provides detailed instructions and configurations for setting up the entire lab environment. * Virtual Machine Setup ELK Setup Atomic Red Team Setup","title":"Environment Setup"},{"location":"#project-workflow","text":"This section details the end-to-end methodology for rule development. It covers the complete cycle from threat simulation with Atomic Red Team to log analysis, KQL rule creation, and final validation. View the Full Workflow","title":"Project Workflow"},{"location":"#apt-threat-lifecycle","text":"This is the strategic overview of the project. It breaks down a sophisticated cyberattack into 12 distinct stages based on the MITRE ATT&CK framework and links to the relevant detections for each stage. Explore the Lifecycle","title":"APT Threat Lifecycle"},{"location":"#rules-created","text":"This is the central repository for all detection logic. It contains a list of every finalized rule, its purpose, and the KQL query ready for deployment in Kibana. Browse All Rules","title":"Rules Created"},{"location":"apt_lifecycle/","text":"APT Threat Lifecycle & Detection Coverage This document outlines the stages of an Advanced Persistent Threat (APT) lifecycle, mapped to the MITRE ATT&CK framework. Each stage includes a description of the adversary's objective, a concise detection strategy, a placeholder for your rule, and a link to the relevant Atomic Red Team test. 1. Reconnaissance (T1595: Active Scanning) Description: Adversaries probe victim networks and systems to identify potential vulnerabilities, open ports, and running services. This helps them map the target's external footprint before launching an attack. Detection Strategy: Identifies brute-force patterns by detecting a high volume of failed logins from a single IP, a common byproduct of active scanning. Detection Rule Atomic Red Team Reference: T1595.003 - Scanning IP Blocks 2. Initial Access (T1566: Phishing) Description: Attackers send fraudulent emails containing malicious attachments or links to gain a foothold in the network. Detection Strategy: Detects anomalous parent-child process relationships, such as an email client spawning a script or executable. Detection Rule Atomic Red Team Reference: T1566.001 - Spearphishing Attachment 3. Execution (T1059: Command and Scripting Interpreter) Description: Adversaries use command-line interfaces (like PowerShell) to execute malicious commands and scripts. Detection Strategy: Alerts on PowerShell execution using command-line flags ( -enc , -encodedcommand ) designed to run obfuscated or encoded commands. Detection Rule Atomic Red Team Reference: T1059 - Command and Scripting Interpreter 4. Persistence (T1547: Boot or Logon Autostart Execution) Description: Attackers configure malware to run automatically by modifying registry keys, startup folders, or logon scripts. Detection Strategy: Monitors for modifications to common registry \"Run\" keys. Detection Rule Atomic Red Team Reference: T1547 - Boot or Logon Autostart Execution 5. Privilege Escalation (T1548: Abuse Elevation Control Mechanism) Description: Adversaries exploit system mechanisms that manage user permissions, such as UAC on Windows, to gain higher-level privileges. Detection Strategy: Detects a known UAC bypass by identifying when fodhelper.exe anomalously spawns a command shell. Detection Rule Atomic Red Team Reference: T1548.001 - Setuid and Setgid 6. Defense Evasion (T1027: Obfuscated Files or Information) Description: Attackers conceal their malicious code to avoid detection, often using encryption, encoding, or packing. Detection Strategy: Flags the use of certutil.exe with the -decode flag. Detection Rule Atomic Red Team Reference: T1027 - Obfuscated Files or Information 7. Credential Access (T1003: OS Credential Dumping) Description: Extracting account login material from the OS, often by dumping memory from the LSASS process. Detection Strategy: Detects unauthorized processes attempting to access the memory of lsass.exe . Detection Rule Atomic Red Team Reference: T1003 - OS Credential Dumping 8. Discovery (T1082: System Information Discovery) Description: Attackers collect detailed information about the compromised system. Detection Strategy: Looks for a rapid burst of system discovery commands from a single process. Detection Rule Atomic Red Team Reference: T1082 - System Information Discovery 9. Lateral Movement (T1021: Remote Services) Description: Adversaries use legitimate remote access tools like RDP to move between systems. Detection Strategy: Identifies non-standard RDP connections by flagging sessions not initiated by svchost.exe . Detection Rule Atomic Red Team Reference: T1021.001 - Remote Desktop Protocol 10. Collection (T1119: Automated Collection) Description: Attackers use scripts to automatically search for and gather files containing sensitive data. Detection Strategy: Alerts on the rapid creation of numerous sensitive file types by a shell process. Detection Rule Atomic Red Team Reference: T1119 - Automated Collection 11. Command and Control (C2) (T1071: Application Layer Protocol) Description: Adversaries use common protocols like HTTP to blend C2 traffic with legitimate activity. Detection Strategy: Flags network connections from non-browser processes to common code-hosting sites. Detection Rule Atomic Red Team Reference: T1071 - Application Layer Protocol 12. Exfiltration (T1048: Exfiltration Over Alternative Protocol) Description: Data is stolen by transmitting it over an alternative protocol, such as DNS. Detection Strategy: Detects potential DNS tunneling by identifying abnormally long DNS queries. Detection Rule Atomic Red Team Reference: T1048 - Exfiltration Over Alternative Protocol","title":"APT lifecycle"},{"location":"apt_lifecycle/#apt-threat-lifecycle-detection-coverage","text":"This document outlines the stages of an Advanced Persistent Threat (APT) lifecycle, mapped to the MITRE ATT&CK framework. Each stage includes a description of the adversary's objective, a concise detection strategy, a placeholder for your rule, and a link to the relevant Atomic Red Team test.","title":"APT Threat Lifecycle &amp; Detection Coverage"},{"location":"apt_lifecycle/#1-reconnaissance-t1595-active-scanning","text":"Description: Adversaries probe victim networks and systems to identify potential vulnerabilities, open ports, and running services. This helps them map the target's external footprint before launching an attack. Detection Strategy: Identifies brute-force patterns by detecting a high volume of failed logins from a single IP, a common byproduct of active scanning. Detection Rule Atomic Red Team Reference: T1595.003 - Scanning IP Blocks","title":"1. Reconnaissance (T1595: Active Scanning)"},{"location":"apt_lifecycle/#2-initial-access-t1566-phishing","text":"Description: Attackers send fraudulent emails containing malicious attachments or links to gain a foothold in the network. Detection Strategy: Detects anomalous parent-child process relationships, such as an email client spawning a script or executable. Detection Rule Atomic Red Team Reference: T1566.001 - Spearphishing Attachment","title":"2. Initial Access (T1566: Phishing)"},{"location":"apt_lifecycle/#3-execution-t1059-command-and-scripting-interpreter","text":"Description: Adversaries use command-line interfaces (like PowerShell) to execute malicious commands and scripts. Detection Strategy: Alerts on PowerShell execution using command-line flags ( -enc , -encodedcommand ) designed to run obfuscated or encoded commands. Detection Rule Atomic Red Team Reference: T1059 - Command and Scripting Interpreter","title":"3. Execution (T1059: Command and Scripting Interpreter)"},{"location":"apt_lifecycle/#4-persistence-t1547-boot-or-logon-autostart-execution","text":"Description: Attackers configure malware to run automatically by modifying registry keys, startup folders, or logon scripts. Detection Strategy: Monitors for modifications to common registry \"Run\" keys. Detection Rule Atomic Red Team Reference: T1547 - Boot or Logon Autostart Execution","title":"4. Persistence (T1547: Boot or Logon Autostart Execution)"},{"location":"apt_lifecycle/#5-privilege-escalation-t1548-abuse-elevation-control-mechanism","text":"Description: Adversaries exploit system mechanisms that manage user permissions, such as UAC on Windows, to gain higher-level privileges. Detection Strategy: Detects a known UAC bypass by identifying when fodhelper.exe anomalously spawns a command shell. Detection Rule Atomic Red Team Reference: T1548.001 - Setuid and Setgid","title":"5. Privilege Escalation (T1548: Abuse Elevation Control Mechanism)"},{"location":"apt_lifecycle/#6-defense-evasion-t1027-obfuscated-files-or-information","text":"Description: Attackers conceal their malicious code to avoid detection, often using encryption, encoding, or packing. Detection Strategy: Flags the use of certutil.exe with the -decode flag. Detection Rule Atomic Red Team Reference: T1027 - Obfuscated Files or Information","title":"6. Defense Evasion (T1027: Obfuscated Files or Information)"},{"location":"apt_lifecycle/#7-credential-access-t1003-os-credential-dumping","text":"Description: Extracting account login material from the OS, often by dumping memory from the LSASS process. Detection Strategy: Detects unauthorized processes attempting to access the memory of lsass.exe . Detection Rule Atomic Red Team Reference: T1003 - OS Credential Dumping","title":"7. Credential Access (T1003: OS Credential Dumping)"},{"location":"apt_lifecycle/#8-discovery-t1082-system-information-discovery","text":"Description: Attackers collect detailed information about the compromised system. Detection Strategy: Looks for a rapid burst of system discovery commands from a single process. Detection Rule Atomic Red Team Reference: T1082 - System Information Discovery","title":"8. Discovery (T1082: System Information Discovery)"},{"location":"apt_lifecycle/#9-lateral-movement-t1021-remote-services","text":"Description: Adversaries use legitimate remote access tools like RDP to move between systems. Detection Strategy: Identifies non-standard RDP connections by flagging sessions not initiated by svchost.exe . Detection Rule Atomic Red Team Reference: T1021.001 - Remote Desktop Protocol","title":"9. Lateral Movement (T1021: Remote Services)"},{"location":"apt_lifecycle/#10-collection-t1119-automated-collection","text":"Description: Attackers use scripts to automatically search for and gather files containing sensitive data. Detection Strategy: Alerts on the rapid creation of numerous sensitive file types by a shell process. Detection Rule Atomic Red Team Reference: T1119 - Automated Collection","title":"10. Collection (T1119: Automated Collection)"},{"location":"apt_lifecycle/#11-command-and-control-c2-t1071-application-layer-protocol","text":"Description: Adversaries use common protocols like HTTP to blend C2 traffic with legitimate activity. Detection Strategy: Flags network connections from non-browser processes to common code-hosting sites. Detection Rule Atomic Red Team Reference: T1071 - Application Layer Protocol","title":"11. Command and Control (C2) (T1071: Application Layer Protocol)"},{"location":"apt_lifecycle/#12-exfiltration-t1048-exfiltration-over-alternative-protocol","text":"Description: Data is stolen by transmitting it over an alternative protocol, such as DNS. Detection Strategy: Detects potential DNS tunneling by identifying abnormally long DNS queries. Detection Rule Atomic Red Team Reference: T1048 - Exfiltration Over Alternative Protocol","title":"12. Exfiltration (T1048: Exfiltration Over Alternative Protocol)"},{"location":"overall_workflow/","text":"Threat Detection Rule Development Workflow This project implements a structured, six-stage workflow for the end-to-end creation, testing, and validation of security detection rules. 1. Environment Setup & Integration This foundational stage involves preparing the complete analysis pipeline. Deploy Infrastructure : Set up the ELK Stack and target Windows 11 VMs. Install Agents : Deploy Winlogbeat on the target machine to collect security logs. Configure Data Pipeline : Ensure logs are successfully ingested and parsed by Logstash and Elasticsearch. 2. Threat Simulation & Log Generation This stage creates the necessary data by emulating adversary behavior. Execute Tests : Run controlled attack simulations using the Atomic Red Team framework. Generate Logs : Trigger the creation of detailed telemetry and security events on the target system. 3. Log Analysis & Pattern Identification This stage focuses on finding the \"signal in the noise\" within the collected logs. Isolate Events : Use Kibana to query and filter logs, pinpointing the exact events generated by the simulation. Identify Indicators : Analyze key log fields to find unique patterns that characterize the malicious activity. 4. KQL Rule Development This stage translates the analytical findings into a functional detection query. Translate Logic to KQL : Convert the identified patterns into a precise Kibana Query Language (KQL) query. Define Rule Logic : The KQL query forms the core logic that will be used to trigger a security alert. 5. Rule Validation & Finalization This final, iterative stage ensures the rule is accurate, reliable, and ready for an operational environment. Iterative Tuning : Test the draft rule against historical log data. Refine the KQL query to minimize false positives (benign alerts) and eliminate false negatives (missed detections). Assign Risk Score : Once the rule is stable, apply a numerical score to classify its severity and aid in alert prioritization. Live Validation : Re-run the corresponding Atomic Red Team test to confirm the finalized rule generates a real-time, accurate alert in the Kibana Security App.","title":"Overall Workflow"},{"location":"overall_workflow/#threat-detection-rule-development-workflow","text":"This project implements a structured, six-stage workflow for the end-to-end creation, testing, and validation of security detection rules.","title":"Threat Detection Rule Development Workflow"},{"location":"overall_workflow/#1-environment-setup-integration","text":"This foundational stage involves preparing the complete analysis pipeline. Deploy Infrastructure : Set up the ELK Stack and target Windows 11 VMs. Install Agents : Deploy Winlogbeat on the target machine to collect security logs. Configure Data Pipeline : Ensure logs are successfully ingested and parsed by Logstash and Elasticsearch.","title":"1. Environment Setup &amp; Integration"},{"location":"overall_workflow/#2-threat-simulation-log-generation","text":"This stage creates the necessary data by emulating adversary behavior. Execute Tests : Run controlled attack simulations using the Atomic Red Team framework. Generate Logs : Trigger the creation of detailed telemetry and security events on the target system.","title":"2. Threat Simulation &amp; Log Generation"},{"location":"overall_workflow/#3-log-analysis-pattern-identification","text":"This stage focuses on finding the \"signal in the noise\" within the collected logs. Isolate Events : Use Kibana to query and filter logs, pinpointing the exact events generated by the simulation. Identify Indicators : Analyze key log fields to find unique patterns that characterize the malicious activity.","title":"3. Log Analysis &amp; Pattern Identification"},{"location":"overall_workflow/#4-kql-rule-development","text":"This stage translates the analytical findings into a functional detection query. Translate Logic to KQL : Convert the identified patterns into a precise Kibana Query Language (KQL) query. Define Rule Logic : The KQL query forms the core logic that will be used to trigger a security alert.","title":"4. KQL Rule Development"},{"location":"overall_workflow/#5-rule-validation-finalization","text":"This final, iterative stage ensures the rule is accurate, reliable, and ready for an operational environment. Iterative Tuning : Test the draft rule against historical log data. Refine the KQL query to minimize false positives (benign alerts) and eliminate false negatives (missed detections). Assign Risk Score : Once the rule is stable, apply a numerical score to classify its severity and aid in alert prioritization. Live Validation : Re-run the corresponding Atomic Red Team test to confirm the finalized rule generates a real-time, accurate alert in the Kibana Security App.","title":"5. Rule Validation &amp; Finalization"},{"location":"rules/","text":"Detection Rule Repository This page serves as the central repository for all detection rules developed for this project. Each rule is mapped to a specific MITRE ATT&CK\u00ae tactic and technique, and the link will take you to a detailed page with the KQL query and implementation notes. All Rules Rule Name MITRE ATT&CK Tactic Technique ID Description Active Scanning Reconnaissance T1595 Detects brute-force patterns indicative of network scanning. Phishing Initial Access T1566 Identifies email clients spawning suspicious child processes. Command and Scripting Interpreter Execution T1059 Flags PowerShell execution with encoded command flags. Boot or Logon Autostart Execution Persistence T1547 Monitors for modifications to common registry \"Run\" keys. Abuse Elevation Control Mechanism Privilege Escalation T1548 Detects a known UAC bypass using fodhelper.exe . Obfuscated Files or Information Defense Evasion T1027 Alerts on the use of certutil.exe to decode files. OS Credential Dumping Credential Access T1003 Identifies unauthorized processes accessing lsass.exe memory. System Information Discovery Discovery T1082 Looks for a rapid burst of system discovery commands. Remote Services Lateral Movement T1021 Flags non-standard RDP connections. Automated Collection Collection T1119 Detects rapid creation of sensitive file types by a shell. Application Layer Protocol Command and Control T1071 Flags non-browser processes connecting to code-hosting sites. Exfiltration Over Alternative Protocol Exfiltration T1048 Detects abnormally long DNS queries indicative of tunneling. Note : Click on any rule name to view its detailed documentation, including the full KQL query, data source requirements, and validation steps.","title":"Rules"},{"location":"rules/#detection-rule-repository","text":"This page serves as the central repository for all detection rules developed for this project. Each rule is mapped to a specific MITRE ATT&CK\u00ae tactic and technique, and the link will take you to a detailed page with the KQL query and implementation notes.","title":"Detection Rule Repository"},{"location":"rules/#all-rules","text":"Rule Name MITRE ATT&CK Tactic Technique ID Description Active Scanning Reconnaissance T1595 Detects brute-force patterns indicative of network scanning. Phishing Initial Access T1566 Identifies email clients spawning suspicious child processes. Command and Scripting Interpreter Execution T1059 Flags PowerShell execution with encoded command flags. Boot or Logon Autostart Execution Persistence T1547 Monitors for modifications to common registry \"Run\" keys. Abuse Elevation Control Mechanism Privilege Escalation T1548 Detects a known UAC bypass using fodhelper.exe . Obfuscated Files or Information Defense Evasion T1027 Alerts on the use of certutil.exe to decode files. OS Credential Dumping Credential Access T1003 Identifies unauthorized processes accessing lsass.exe memory. System Information Discovery Discovery T1082 Looks for a rapid burst of system discovery commands. Remote Services Lateral Movement T1021 Flags non-standard RDP connections. Automated Collection Collection T1119 Detects rapid creation of sensitive file types by a shell. Application Layer Protocol Command and Control T1071 Flags non-browser processes connecting to code-hosting sites. Exfiltration Over Alternative Protocol Exfiltration T1048 Detects abnormally long DNS queries indicative of tunneling. Note : Click on any rule name to view its detailed documentation, including the full KQL query, data source requirements, and validation steps.","title":"All Rules"},{"location":"setup/","text":"All Setups Go to ELK Stack Setup Guide Atomic Red Team Setup Guide","title":"All Setups"},{"location":"setup/#all-setups","text":"Go to ELK Stack Setup Guide Atomic Red Team Setup Guide","title":"All Setups"},{"location":"rules_created/abuse_elevation_control_mechanism/","text":"Detection Rule: Privilege Escalation via Fodhelper UAC Bypass Rule ID: 6727ae6d-21ee-40aa-b0a1-bbcb1c58f8cf Rule Name: Privilege Escalation (T1548: Abuse Elevation Control Mechanism) MITRE ATT&CK Tactic: Privilege Escalation MITRE ATT&CK Technique: T1548.002, Abuse Elevation Control Mechanism: Bypass User Account Control Description This rule detects a specific User Account Control (UAC) bypass technique that abuses the legitimate Windows executable fodhelper.exe . Adversaries exploit this mechanism to execute code with elevated (administrator) privileges on a compromised system without triggering the standard UAC prompt that would alert the user. fodhelper.exe is a trusted Microsoft binary that is allowed to auto-elevate its privileges. Attackers can hijack its execution by modifying specific registry keys. When fodhelper.exe is launched, it inadvertently executes the attacker's malicious command instead of its intended function, inheriting the elevated privileges. Rule Derivation from Log Analysis The logic for this rule is derived from analyzing the process execution chain during a UAC bypass, focusing on anomalous parent-child relationships. 1. Defining the Behavior : The attack involves an untrusted process (like cmd.exe or a malicious script) launching fodhelper.exe to trigger the hijack. In normal operations, fodhelper.exe is typically launched by core Windows processes like the user's shell ( explorer.exe ) or the Service Host ( svchost.exe ). Therefore, the key indicator of malicious activity is fodhelper.exe being started by an unexpected parent process. 2. Translating Behavior to Log Fields : This parent-child relationship is captured in process creation logs: The child process is identified in the process.name field (as fodhelper.exe ). The parent process that launched it is identified in the process.parent.name field. 3. Constructing the Rule : The query was built to be highly specific and reduce false positives. It first identifies all instances of fodhelper.exe being executed. Then, it explicitly excludes the known, legitimate parent processes. Any remaining event, where fodhelper.exe is launched by any other process, is treated as suspicious and triggers an alert. Detection Logic This is a query-based rule that triggers on a single process creation event matching a specific parent-child relationship. Query: process.name : \"fodhelper.exe\" AND NOT (process.parent.name : \"explorer.exe\" OR process.parent.name : \"svchost.exe\") Query Explanation: The query logic identifies instances where fodhelper.exe is executed by a process other than its expected parent processes. - The process.name : \"fodhelper.exe\" clause selects all events where the fodhelper.exe process is created. - The AND NOT (...) clause then filters out these events if the parent process ( process.parent.name ) is either explorer.exe or svchost.exe , which are considered legitimate initiators. The rule triggers an alert for any fodhelper.exe process creation event that does not match the exclusion criteria, indicating a high probability of a UAC bypass attempt. Simulation and Validation This rule can be validated by simulating the registry hijack and execution flow used in this UAC bypass technique. Atomic Red Team Test Command: reg add HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /v \"\" /d \"C:\\Windows\\System32\\cmd.exe\" /f reg add HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /v \"DelegateExecute\" /d \"\" /f fodhelper.exe This sequence of commands first modifies the registry key associated with the ms-settings URI handler, pointing it to the Command Prompt ( cmd.exe ). When fodhelper.exe is executed in the final step, it attempts to open the settings handler, but because of the registry modification, it launches cmd.exe with elevated privileges instead. This action, where cmd.exe (or another shell) becomes the parent of fodhelper.exe, matches the rule's logic and will generate an alert.","title":"Abuse Elevation Control Mechanism"},{"location":"rules_created/abuse_elevation_control_mechanism/#detection-rule-privilege-escalation-via-fodhelper-uac-bypass","text":"Rule ID: 6727ae6d-21ee-40aa-b0a1-bbcb1c58f8cf Rule Name: Privilege Escalation (T1548: Abuse Elevation Control Mechanism) MITRE ATT&CK Tactic: Privilege Escalation MITRE ATT&CK Technique: T1548.002, Abuse Elevation Control Mechanism: Bypass User Account Control","title":"Detection Rule: Privilege Escalation via Fodhelper UAC Bypass"},{"location":"rules_created/abuse_elevation_control_mechanism/#description","text":"This rule detects a specific User Account Control (UAC) bypass technique that abuses the legitimate Windows executable fodhelper.exe . Adversaries exploit this mechanism to execute code with elevated (administrator) privileges on a compromised system without triggering the standard UAC prompt that would alert the user. fodhelper.exe is a trusted Microsoft binary that is allowed to auto-elevate its privileges. Attackers can hijack its execution by modifying specific registry keys. When fodhelper.exe is launched, it inadvertently executes the attacker's malicious command instead of its intended function, inheriting the elevated privileges.","title":"Description"},{"location":"rules_created/abuse_elevation_control_mechanism/#rule-derivation-from-log-analysis","text":"The logic for this rule is derived from analyzing the process execution chain during a UAC bypass, focusing on anomalous parent-child relationships.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/abuse_elevation_control_mechanism/#1-defining-the-behavior","text":"The attack involves an untrusted process (like cmd.exe or a malicious script) launching fodhelper.exe to trigger the hijack. In normal operations, fodhelper.exe is typically launched by core Windows processes like the user's shell ( explorer.exe ) or the Service Host ( svchost.exe ). Therefore, the key indicator of malicious activity is fodhelper.exe being started by an unexpected parent process.","title":"1. Defining the Behavior:"},{"location":"rules_created/abuse_elevation_control_mechanism/#2-translating-behavior-to-log-fields","text":"This parent-child relationship is captured in process creation logs: The child process is identified in the process.name field (as fodhelper.exe ). The parent process that launched it is identified in the process.parent.name field.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/abuse_elevation_control_mechanism/#3-constructing-the-rule","text":"The query was built to be highly specific and reduce false positives. It first identifies all instances of fodhelper.exe being executed. Then, it explicitly excludes the known, legitimate parent processes. Any remaining event, where fodhelper.exe is launched by any other process, is treated as suspicious and triggers an alert.","title":"3. Constructing the Rule:"},{"location":"rules_created/abuse_elevation_control_mechanism/#detection-logic","text":"This is a query-based rule that triggers on a single process creation event matching a specific parent-child relationship.","title":"Detection Logic"},{"location":"rules_created/abuse_elevation_control_mechanism/#query","text":"process.name : \"fodhelper.exe\" AND NOT (process.parent.name : \"explorer.exe\" OR process.parent.name : \"svchost.exe\")","title":"Query:"},{"location":"rules_created/abuse_elevation_control_mechanism/#query-explanation","text":"The query logic identifies instances where fodhelper.exe is executed by a process other than its expected parent processes. - The process.name : \"fodhelper.exe\" clause selects all events where the fodhelper.exe process is created. - The AND NOT (...) clause then filters out these events if the parent process ( process.parent.name ) is either explorer.exe or svchost.exe , which are considered legitimate initiators. The rule triggers an alert for any fodhelper.exe process creation event that does not match the exclusion criteria, indicating a high probability of a UAC bypass attempt.","title":"Query Explanation:"},{"location":"rules_created/abuse_elevation_control_mechanism/#simulation-and-validation","text":"This rule can be validated by simulating the registry hijack and execution flow used in this UAC bypass technique.","title":"Simulation and Validation"},{"location":"rules_created/abuse_elevation_control_mechanism/#atomic-red-team-test-command","text":"reg add HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /v \"\" /d \"C:\\Windows\\System32\\cmd.exe\" /f reg add HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /v \"DelegateExecute\" /d \"\" /f fodhelper.exe This sequence of commands first modifies the registry key associated with the ms-settings URI handler, pointing it to the Command Prompt ( cmd.exe ). When fodhelper.exe is executed in the final step, it attempts to open the settings handler, but because of the registry modification, it launches cmd.exe with elevated privileges instead. This action, where cmd.exe (or another shell) becomes the parent of fodhelper.exe, matches the rule's logic and will generate an alert.","title":"Atomic Red Team Test Command:"},{"location":"rules_created/active_scanning/","text":"Detection Rule: Reconnaissance - Active Scanning Rule ID: 05e649fb-4bdf-4f4a-82ef-52b83a4c9090 Rule Name: Reconnaissance (T1595: Active Scanning) MITRE ATT&CK Tactic: Reconnaissance MITRE ATT&CK Technique: T1595, Active Scanning Description This rule detects a potential network port scan originating from an external IP address. Active scanning is a common reconnaissance technique used by adversaries to identify open ports, discover running services, and map potential vulnerabilities on target systems before launching an attack. This activity is analogous to a burglar checking every door and window of a building to find an unlocked entry point. An alert from this rule indicates that a single external source has attempted to connect to an abnormally high number of different ports across the network within a short time frame. Rule Derivation from Log Analysis The logic for this rule was developed by modeling the digital footprint of a port scan and translating it into a query. The process involved identifying key patterns in network logs that distinguish a scan from benign traffic. 1. Defining the Behavior : The primary goal was to identify an external actor systematically probing many network ports. The key characteristics of this behavior in raw log data are: A high volume of connection attempts. All attempts originate from a single source IP. The attempts target many different destination ports. The events occur within a condensed time frame. The source is external to our network. 2. Translating Behavior to Log Fields : These characteristics were then mapped to specific fields and logic available in our log data: The \"single source IP\" is represented by the source.ip field. The \"many different destination ports\" is identified by looking for a high number of unique values in the destination.port field. To focus on \"external\" traffic, we filter out all logs where the source.ip belongs to a known internal (private RFC 1918) address range. 3. Constructing the Rule : This analysis directly led to the rule's threshold-based design: First, we filter for only the relevant data: inbound TCP connections from external IPs. Next, we tell the system to group the events by source.ip, as we want to analyze the behavior of each external actor individually. Finally, we set a threshold: an alert is triggered if any single group (a unique source IP) has a count of unique destination.port values that exceeds 50 within the rule's time window. This numeric threshold is the critical piece that separates the systematic, broad nature of a scan from normal, targeted network communication. 4. Detection Logic This is a threshold-based rule that analyzes network connection logs to identify patterns indicative of scanning behavior. Query: event.category:network and event.type:connection and network.transport:tcp and not source.ip:(10.0.0.0/8 or 172.16.0.0/12 or 192.168.0.0/16) The query filters logs to isolate inbound TCP connection events. Crucially, it excludes traffic originating from internal, private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to prevent false positives from legitimate internal network activity. Threshold: The rule groups events by the source IP address (winlog.event_data.SourceIp.keyword). It triggers an alert if the number of unique destination ports (winlog.event_data.DestinationPort.keyword) from a single source IP exceeds 50 within the rule's 5-minute evaluation window. In summary, the rule alerts when a single external IP address attempts to connect to 50 or more unique ports on the network in under five minutes. Simulation and Validation To validate that this rule is working correctly, a port scan can be simulated against a monitored endpoint using a tool like Nmap from an external machine. Atomic Red Team Test Command: nmap -sT -p- <target_IP> This command initiates a TCP connect scan (-sT) against all 65,535 ports (-p-) of the . This will generate a large volume of connection attempts from a single source to many distinct ports, satisfying the rule's threshold condition and triggering an alert.","title":"Active Scanning"},{"location":"rules_created/active_scanning/#detection-rule-reconnaissance-active-scanning","text":"Rule ID: 05e649fb-4bdf-4f4a-82ef-52b83a4c9090 Rule Name: Reconnaissance (T1595: Active Scanning) MITRE ATT&CK Tactic: Reconnaissance MITRE ATT&CK Technique: T1595, Active Scanning","title":"Detection Rule: Reconnaissance - Active Scanning"},{"location":"rules_created/active_scanning/#description","text":"This rule detects a potential network port scan originating from an external IP address. Active scanning is a common reconnaissance technique used by adversaries to identify open ports, discover running services, and map potential vulnerabilities on target systems before launching an attack. This activity is analogous to a burglar checking every door and window of a building to find an unlocked entry point. An alert from this rule indicates that a single external source has attempted to connect to an abnormally high number of different ports across the network within a short time frame.","title":"Description"},{"location":"rules_created/active_scanning/#rule-derivation-from-log-analysis","text":"The logic for this rule was developed by modeling the digital footprint of a port scan and translating it into a query. The process involved identifying key patterns in network logs that distinguish a scan from benign traffic.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/active_scanning/#1-defining-the-behavior","text":"The primary goal was to identify an external actor systematically probing many network ports. The key characteristics of this behavior in raw log data are: A high volume of connection attempts. All attempts originate from a single source IP. The attempts target many different destination ports. The events occur within a condensed time frame. The source is external to our network.","title":"1. Defining the Behavior:"},{"location":"rules_created/active_scanning/#2-translating-behavior-to-log-fields","text":"These characteristics were then mapped to specific fields and logic available in our log data: The \"single source IP\" is represented by the source.ip field. The \"many different destination ports\" is identified by looking for a high number of unique values in the destination.port field. To focus on \"external\" traffic, we filter out all logs where the source.ip belongs to a known internal (private RFC 1918) address range.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/active_scanning/#3-constructing-the-rule","text":"This analysis directly led to the rule's threshold-based design: First, we filter for only the relevant data: inbound TCP connections from external IPs. Next, we tell the system to group the events by source.ip, as we want to analyze the behavior of each external actor individually. Finally, we set a threshold: an alert is triggered if any single group (a unique source IP) has a count of unique destination.port values that exceeds 50 within the rule's time window. This numeric threshold is the critical piece that separates the systematic, broad nature of a scan from normal, targeted network communication.","title":"3. Constructing the Rule:"},{"location":"rules_created/active_scanning/#4-detection-logic","text":"This is a threshold-based rule that analyzes network connection logs to identify patterns indicative of scanning behavior.","title":"4. Detection Logic"},{"location":"rules_created/active_scanning/#query","text":"event.category:network and event.type:connection and network.transport:tcp and not source.ip:(10.0.0.0/8 or 172.16.0.0/12 or 192.168.0.0/16) The query filters logs to isolate inbound TCP connection events. Crucially, it excludes traffic originating from internal, private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to prevent false positives from legitimate internal network activity.","title":"Query:"},{"location":"rules_created/active_scanning/#threshold","text":"The rule groups events by the source IP address (winlog.event_data.SourceIp.keyword). It triggers an alert if the number of unique destination ports (winlog.event_data.DestinationPort.keyword) from a single source IP exceeds 50 within the rule's 5-minute evaluation window. In summary, the rule alerts when a single external IP address attempts to connect to 50 or more unique ports on the network in under five minutes.","title":"Threshold:"},{"location":"rules_created/active_scanning/#simulation-and-validation","text":"To validate that this rule is working correctly, a port scan can be simulated against a monitored endpoint using a tool like Nmap from an external machine. Atomic Red Team Test Command: nmap -sT -p- <target_IP> This command initiates a TCP connect scan (-sT) against all 65,535 ports (-p-) of the . This will generate a large volume of connection attempts from a single source to many distinct ports, satisfying the rule's threshold condition and triggering an alert.","title":"Simulation and Validation"},{"location":"rules_created/application_layer_protocol/","text":"Detection Rule: C2 via Application Layer Protocol Rule ID: a2b74aea-b267-4ddd-9a51-bac87083d306 Rule Name: Command and Control (T1071: Application Layer Protocol) MITRE ATT&CK Tactic: Command and Control MITRE ATT&CK Technique: T1071, Application Layer Protocol Description Adversaries use common protocols like HTTP or HTTPS for their command and control (C2) communications to blend in with legitimate network traffic. This rule detects this behavior by identifying network connections to standard web ports (80/443) that originate from non-browser processes. While it's normal for browsers like Chrome or Firefox to connect to these ports, it is highly suspicious when other programs (like cmd.exe , powershell.exe , or an unknown executable) do so, as this can indicate a malware beacon. Rule Derivation from Log Analysis The logic for this rule was developed by baselining normal web traffic and then hunting for outliers. 1. Defining the Behavior : The goal was to find C2 traffic hiding as legitimate web browsing. The key differentiator is the source process . Legitimate HTTP/S traffic originates from a web browser or a few core system processes. Malicious C2 traffic often originates from malware, droppers, or script interpreters. 2. Translating Behavior to Log Fields : This behavior is observed in network connection logs. The network protocol is identified by the destination.port (80 for HTTP, 443 for HTTPS). The source process is identified by process.name . 3. Constructing the Rule : The query was built using an exclusion model. It looks for all traffic on web ports and then explicitly excludes connections from known, legitimate browsers and system processes. Any remaining traffic is flagged as suspicious, providing a powerful way to spot hidden C2 channels. Detection Logic This is a query-based rule that triggers on a single network connection event. Query: event.category:network and destination.port:(80 or 443) and not process.name:(\"chrome.exe\" or \"firefox.exe\" or \"msedge.exe\" or \"iexplore.exe\" or \"svchost.exe\") Query Explanation: The query identifies network traffic from non-standard applications to web ports. event.category:network : This clause filters events to only include network connections. destination.port:(80 or 443) : This filters for traffic directed to the standard ports for HTTP (80) and HTTPS (443). not process.name:(...) : This is the core logic, which excludes traffic originating from common web browsers and the Windows Service Host (svchost.exe). Simulation and Validation This rule can be validated by initiating a web request from a non-browser application, such as PowerShell. Atomic Red Team Test Command: Invoke-WebRequest -Uri https://www.google.com This command uses PowerShell's Invoke-WebRequest cmdlet to download the homepage of Google. This creates a network connection from the powershell.exe process to a destination on port 443 (HTTPS). Since powershell.exe is not in the rule's exclusion list, this action directly matches the rule's logic and will generate an alert.","title":"Application Layer Protocol"},{"location":"rules_created/application_layer_protocol/#detection-rule-c2-via-application-layer-protocol","text":"Rule ID: a2b74aea-b267-4ddd-9a51-bac87083d306 Rule Name: Command and Control (T1071: Application Layer Protocol) MITRE ATT&CK Tactic: Command and Control MITRE ATT&CK Technique: T1071, Application Layer Protocol","title":"Detection Rule: C2 via Application Layer Protocol"},{"location":"rules_created/application_layer_protocol/#description","text":"Adversaries use common protocols like HTTP or HTTPS for their command and control (C2) communications to blend in with legitimate network traffic. This rule detects this behavior by identifying network connections to standard web ports (80/443) that originate from non-browser processes. While it's normal for browsers like Chrome or Firefox to connect to these ports, it is highly suspicious when other programs (like cmd.exe , powershell.exe , or an unknown executable) do so, as this can indicate a malware beacon.","title":"Description"},{"location":"rules_created/application_layer_protocol/#rule-derivation-from-log-analysis","text":"The logic for this rule was developed by baselining normal web traffic and then hunting for outliers.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/application_layer_protocol/#1-defining-the-behavior","text":"The goal was to find C2 traffic hiding as legitimate web browsing. The key differentiator is the source process . Legitimate HTTP/S traffic originates from a web browser or a few core system processes. Malicious C2 traffic often originates from malware, droppers, or script interpreters.","title":"1. Defining the Behavior:"},{"location":"rules_created/application_layer_protocol/#2-translating-behavior-to-log-fields","text":"This behavior is observed in network connection logs. The network protocol is identified by the destination.port (80 for HTTP, 443 for HTTPS). The source process is identified by process.name .","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/application_layer_protocol/#3-constructing-the-rule","text":"The query was built using an exclusion model. It looks for all traffic on web ports and then explicitly excludes connections from known, legitimate browsers and system processes. Any remaining traffic is flagged as suspicious, providing a powerful way to spot hidden C2 channels.","title":"3. Constructing the Rule:"},{"location":"rules_created/application_layer_protocol/#detection-logic","text":"This is a query-based rule that triggers on a single network connection event.","title":"Detection Logic"},{"location":"rules_created/application_layer_protocol/#query","text":"event.category:network and destination.port:(80 or 443) and not process.name:(\"chrome.exe\" or \"firefox.exe\" or \"msedge.exe\" or \"iexplore.exe\" or \"svchost.exe\")","title":"Query:"},{"location":"rules_created/application_layer_protocol/#query-explanation","text":"The query identifies network traffic from non-standard applications to web ports. event.category:network : This clause filters events to only include network connections. destination.port:(80 or 443) : This filters for traffic directed to the standard ports for HTTP (80) and HTTPS (443). not process.name:(...) : This is the core logic, which excludes traffic originating from common web browsers and the Windows Service Host (svchost.exe).","title":"Query Explanation:"},{"location":"rules_created/application_layer_protocol/#simulation-and-validation","text":"This rule can be validated by initiating a web request from a non-browser application, such as PowerShell.","title":"Simulation and Validation"},{"location":"rules_created/application_layer_protocol/#atomic-red-team-test-command","text":"Invoke-WebRequest -Uri https://www.google.com This command uses PowerShell's Invoke-WebRequest cmdlet to download the homepage of Google. This creates a network connection from the powershell.exe process to a destination on port 443 (HTTPS). Since powershell.exe is not in the rule's exclusion list, this action directly matches the rule's logic and will generate an alert.","title":"Atomic Red Team Test Command:"},{"location":"rules_created/automated_collection/","text":"Detection Rule: Automated Collection and Archiving Rule ID: 3f756498-01bb-435e-92d1-5e19468abe64 Rule Name: Collection (T1119: Automated Collection) MITRE ATT&CK Tactic: Collection MITRE ATT&CK Technique: T1119, Automated Collection & T1560.001, Archive Collected Data: Archive via Utility Description Attackers use scripts to automatically gather sensitive files (.doc, .pdf, etc.). This rule detects a common follow-up action: compressing these files into a password-protected archive using tools like 7z or rar. This action stages the data, making it easier for an attacker to exfiltrate a large volume of information in a single, encrypted file. Rule Derivation from Log Analysis The logic for this rule was developed by identifying the command-line footprint of data being staged for exfiltration. 1. Defining the Behavior : An adversary, after identifying files of interest, will often use a command-line utility to compress them into a password-protected archive. This behavior involves three key components: an archiving tool, target files (often documents), and a password. 2. Translating Behavior to Log Fields : This entire action is captured in a single process creation event. The archiving utility is found in process.name . The files being targeted and the password switch are both found in the process.command_line. 3. Constructing the Rule : The query was built to require all three behavioral components to be present. It looks for a known archiving tool, common document file extensions in the command line, and the specific command-line switches used for password protection. The combination of these three elements is a very strong indicator of malicious data staging. Detection Logic This is a query-based rule that triggers on a single process creation event. Query: process.name:(\"7z.exe\" or \"rar.exe\" or \"zip.exe\") and process.command_line:(\"*.doc*\" or \"*.xls*\" or \"*.pdf*\" or \"*.txt*\") and process.command_line:(\"-p*\" or \"-hp*\") Query Explanation: The query identifies the use of common archiving tools to create password-protected archives of document files. process.name:(...) : This clause filters for events where a common archiving utility (7z.exe, rar.exe, zip.exe) is executed. process.command_line:(\"*.doc*\"...) : This clause checks that the command line contains references to common document file types. process.command_line:(\"-p*\" or \"-hp*\") : This clause checks for the presence of command-line switches used to set a password (-p for 7-Zip/Zip, -hp for RAR). Simulation and Validation This rule can be validated by creating dummy document files and then using an archiving tool to compress them with a password. Atomic Red Team Test Command: echo \"secret\" > file.doc 7z.exe a -pSuperSecret collected.zip *.doc This test first creates a dummy document file named file.doc. It then uses the 7-Zip utility (7z.exe) to create a new archive named collected.zip, protecting it with a password (-pSuperSecret), and adds all files with a .doc extension to it. This action perfectly matches the rule's logic and will generate an alert.","title":"Automated Collection"},{"location":"rules_created/automated_collection/#detection-rule-automated-collection-and-archiving","text":"Rule ID: 3f756498-01bb-435e-92d1-5e19468abe64 Rule Name: Collection (T1119: Automated Collection) MITRE ATT&CK Tactic: Collection MITRE ATT&CK Technique: T1119, Automated Collection & T1560.001, Archive Collected Data: Archive via Utility","title":"Detection Rule: Automated Collection and Archiving"},{"location":"rules_created/automated_collection/#description","text":"Attackers use scripts to automatically gather sensitive files (.doc, .pdf, etc.). This rule detects a common follow-up action: compressing these files into a password-protected archive using tools like 7z or rar. This action stages the data, making it easier for an attacker to exfiltrate a large volume of information in a single, encrypted file.","title":"Description"},{"location":"rules_created/automated_collection/#rule-derivation-from-log-analysis","text":"The logic for this rule was developed by identifying the command-line footprint of data being staged for exfiltration.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/automated_collection/#1-defining-the-behavior","text":"An adversary, after identifying files of interest, will often use a command-line utility to compress them into a password-protected archive. This behavior involves three key components: an archiving tool, target files (often documents), and a password.","title":"1. Defining the Behavior:"},{"location":"rules_created/automated_collection/#2-translating-behavior-to-log-fields","text":"This entire action is captured in a single process creation event. The archiving utility is found in process.name . The files being targeted and the password switch are both found in the process.command_line.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/automated_collection/#3-constructing-the-rule","text":"The query was built to require all three behavioral components to be present. It looks for a known archiving tool, common document file extensions in the command line, and the specific command-line switches used for password protection. The combination of these three elements is a very strong indicator of malicious data staging.","title":"3. Constructing the Rule:"},{"location":"rules_created/automated_collection/#detection-logic","text":"This is a query-based rule that triggers on a single process creation event.","title":"Detection Logic"},{"location":"rules_created/automated_collection/#query","text":"process.name:(\"7z.exe\" or \"rar.exe\" or \"zip.exe\") and process.command_line:(\"*.doc*\" or \"*.xls*\" or \"*.pdf*\" or \"*.txt*\") and process.command_line:(\"-p*\" or \"-hp*\")","title":"Query:"},{"location":"rules_created/automated_collection/#query-explanation","text":"The query identifies the use of common archiving tools to create password-protected archives of document files. process.name:(...) : This clause filters for events where a common archiving utility (7z.exe, rar.exe, zip.exe) is executed. process.command_line:(\"*.doc*\"...) : This clause checks that the command line contains references to common document file types. process.command_line:(\"-p*\" or \"-hp*\") : This clause checks for the presence of command-line switches used to set a password (-p for 7-Zip/Zip, -hp for RAR).","title":"Query Explanation:"},{"location":"rules_created/automated_collection/#simulation-and-validation","text":"This rule can be validated by creating dummy document files and then using an archiving tool to compress them with a password.","title":"Simulation and Validation"},{"location":"rules_created/automated_collection/#atomic-red-team-test-command","text":"echo \"secret\" > file.doc 7z.exe a -pSuperSecret collected.zip *.doc This test first creates a dummy document file named file.doc. It then uses the 7-Zip utility (7z.exe) to create a new archive named collected.zip, protecting it with a password (-pSuperSecret), and adds all files with a .doc extension to it. This action perfectly matches the rule's logic and will generate an alert.","title":"Atomic Red Team Test Command:"},{"location":"rules_created/boot_or_logon_autostart_execution/","text":"Detection Rule: Persistence via Registry Run Keys Rule ID: 5a51e164-aaae-42a4-9537-00406b2f85ba Rule Name: Persistence (T1547: Boot or Logon Autostart Execution) MITRE ATT&CK Tactic: Persistence MITRE ATT&CK Technique: T1547.001, Boot or Logon Autostart Execution: Registry Run Keys Description This rule detects when a program establishes persistence by adding an entry to the Run keys in the Windows Registry. After gaining access, an adversary uses persistence mechanisms to ensure their malicious software automatically executes every time the computer is booted or a user logs on. This technique is one of the oldest and most common methods for maintaining a foothold. By writing to these specific registry locations, the attacker guarantees their code will survive a system reboot. Rule Derivation from Log Analysis The logic for this rule was developed by targeting a well-documented and high-fidelity persistence method within Windows. 1. Defining the Behavior : The goal was to detect the act of creating an auto-start entry. In Windows, this is most commonly done by adding a new value to one of two specific registry keys (HKCU\\...\\Run or HKLM\\...\\Run) . Any program path listed here is automatically executed by the operating system at startup. 2. Translating Behavior to Log Fields : This action is captured by system monitoring tools that log registry modifications. The critical log fields are: event.category: This must be registry to focus on registry operations. registry.path: This field contains the full path to the key and value being modified. 3. Constructing the Rule : The query was built to be highly specific. It filters all system events for only those that are registry modifications and then checks if the path of the modification falls within the two primary Run keys. The wildcard (*) is used to match any new program entry being added under these keys. This approach is effective because legitimate software installations that use these keys are relatively infrequent compared to daily operations, making any modification a noteworthy event. Detection Logic This is a query-based rule that triggers on a single registry modification event matching the specified criteria. Query: event.category:registry and registry.path:(\"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\*\" or \"HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\*\") Explanation: The query identifies events where a value is created or modified within the specified Windows Registry Run keys. The event.category:registry clause filters events to only include operations involving the Windows Registry . The registry.path:(...) clause matches events where the modified path is located in one of two keys: HKEY_CURRENT_USER\\...\\Run\\* : This key contains programs that execute upon the current user's logon. HKEY_LOCAL_MACHINE\\...\\Run\\* : This key contains programs that execute for any user upon system startup. The logic triggers an alert when any registry modification event occurs within these specific auto-start execution paths. Simulation and Validation This rule can be validated by using the built-in Windows Registry Editor (reg.exe) to add a new startup entry. Atomic Red Team Test Command: reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v \"AtomicPersistence\" /t REG_SZ /d \"C:\\Windows\\System32\\calc.exe\" /f This command adds a new registry value named AtomicPersistence to the current user's Run key. It instructs Windows to launch the Calculator (calc.exe) every time the user logs in. This action directly modifies one of the paths monitored by the rule and will immediately generate an alert.","title":"Boot or Logon Autostart Execution"},{"location":"rules_created/boot_or_logon_autostart_execution/#detection-rule-persistence-via-registry-run-keys","text":"Rule ID: 5a51e164-aaae-42a4-9537-00406b2f85ba Rule Name: Persistence (T1547: Boot or Logon Autostart Execution) MITRE ATT&CK Tactic: Persistence MITRE ATT&CK Technique: T1547.001, Boot or Logon Autostart Execution: Registry Run Keys","title":"Detection Rule: Persistence via Registry Run Keys"},{"location":"rules_created/boot_or_logon_autostart_execution/#description","text":"This rule detects when a program establishes persistence by adding an entry to the Run keys in the Windows Registry. After gaining access, an adversary uses persistence mechanisms to ensure their malicious software automatically executes every time the computer is booted or a user logs on. This technique is one of the oldest and most common methods for maintaining a foothold. By writing to these specific registry locations, the attacker guarantees their code will survive a system reboot.","title":"Description"},{"location":"rules_created/boot_or_logon_autostart_execution/#rule-derivation-from-log-analysis","text":"The logic for this rule was developed by targeting a well-documented and high-fidelity persistence method within Windows.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/boot_or_logon_autostart_execution/#1-defining-the-behavior","text":"The goal was to detect the act of creating an auto-start entry. In Windows, this is most commonly done by adding a new value to one of two specific registry keys (HKCU\\...\\Run or HKLM\\...\\Run) . Any program path listed here is automatically executed by the operating system at startup.","title":"1. Defining the Behavior:"},{"location":"rules_created/boot_or_logon_autostart_execution/#2-translating-behavior-to-log-fields","text":"This action is captured by system monitoring tools that log registry modifications. The critical log fields are: event.category: This must be registry to focus on registry operations. registry.path: This field contains the full path to the key and value being modified.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/boot_or_logon_autostart_execution/#3-constructing-the-rule","text":"The query was built to be highly specific. It filters all system events for only those that are registry modifications and then checks if the path of the modification falls within the two primary Run keys. The wildcard (*) is used to match any new program entry being added under these keys. This approach is effective because legitimate software installations that use these keys are relatively infrequent compared to daily operations, making any modification a noteworthy event.","title":"3. Constructing the Rule:"},{"location":"rules_created/boot_or_logon_autostart_execution/#detection-logic","text":"This is a query-based rule that triggers on a single registry modification event matching the specified criteria.","title":"Detection Logic"},{"location":"rules_created/boot_or_logon_autostart_execution/#query","text":"event.category:registry and registry.path:(\"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\*\" or \"HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\*\")","title":"Query:"},{"location":"rules_created/boot_or_logon_autostart_execution/#explanation","text":"The query identifies events where a value is created or modified within the specified Windows Registry Run keys. The event.category:registry clause filters events to only include operations involving the Windows Registry . The registry.path:(...) clause matches events where the modified path is located in one of two keys: HKEY_CURRENT_USER\\...\\Run\\* : This key contains programs that execute upon the current user's logon. HKEY_LOCAL_MACHINE\\...\\Run\\* : This key contains programs that execute for any user upon system startup. The logic triggers an alert when any registry modification event occurs within these specific auto-start execution paths.","title":"Explanation:"},{"location":"rules_created/boot_or_logon_autostart_execution/#simulation-and-validation","text":"This rule can be validated by using the built-in Windows Registry Editor (reg.exe) to add a new startup entry.","title":"Simulation and Validation"},{"location":"rules_created/boot_or_logon_autostart_execution/#atomic-red-team-test-command","text":"reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v \"AtomicPersistence\" /t REG_SZ /d \"C:\\Windows\\System32\\calc.exe\" /f This command adds a new registry value named AtomicPersistence to the current user's Run key. It instructs Windows to launch the Calculator (calc.exe) every time the user logs in. This action directly modifies one of the paths monitored by the rule and will immediately generate an alert.","title":"Atomic Red Team Test Command:"},{"location":"rules_created/command_and_scripting_interpreter/","text":"Detection Rule: Execution via PowerShell Download Rule ID: c99f9f9a-b0bd-49dc-b3af-3d837cfb64e1 Rule Name: Execution (T1059: Command and Scripting Interpreter) MITRE ATT&CK Tactic: Execution MITRE ATT&CK Technique: T1059.001, Command and Scripting Interpreter: PowerShell Description This rule detects an adversary using Windows PowerShell to download a file from an external source. After gaining initial access, attackers often use this technique to retrieve their primary malware, tools, or second-stage payloads from a command-and-control (C2) server onto the compromised host. Because PowerShell is a legitimate and powerful administration tool installed on all modern Windows systems, its activity can blend in with normal operations, making it a favored tool for \"living off the land.\" An alert from this rule is a strong indicator that an active payload is being introduced into the environment. Rule Derivation from Log Analysis This rule's logic was derived by identifying the specific command-line artifacts left behind when PowerShell is used for network downloads. 1. Defining the Behavior : The core behavior is the execution of powershell.exe with command-line arguments that instruct it to initiate a file download from a URL. 2.Translating Behavior to Log Fields : This activity is captured entirely within process execution logs: The process being run is identified in the process.name field (i.e., powershell.exe). The specific download instructions are found in the process.command_line field. 3. Constructing the Rule : We identified the most common PowerShell classes, cmdlets, and aliases used for downloading files. These include the .NET class System.Net.WebClient and its methods (DownloadFile, DownloadString), as well as the native PowerShell cmdlets Invoke-WebRequest (aliased as iwr) and wget. The rule logic was then built to search for the execution of powershell.exe where any of these specific, high-fidelity strings are present in the command line. Detection Logic This is a query-based rule that triggers on a single process creation event. Query: process.name:powershell.exe and process.command_line:(*System.Net.WebClient* or *DownloadFile* or *DownloadString* or *iwr* or *wget*) Breakdown: process.name:powershell.exe : The rule first looks for any event where the powershell.exe process is started. and : It then requires the second condition to also be true. process.command_line:(...) : The rule inspects the full command line used to launch PowerShell. It triggers if it finds any of the following keywords, which are commonly used to download files: System.Net.WebClient, DownloadFile, DownloadString: Methods from the .NET Framework for web requests. iwr: A standard alias for the Invoke-WebRequest cmdlet. wget: A common alias for the Invoke-WebRequest cmdlet, familiar to Linux users. In short, the rule alerts whenever PowerShell is launched with a command that explicitly instructs it to download content from the internet. Simulation and Validation This rule can be validated by running a simple PowerShell command to download a benign file from the internet. Atomic Red Team Test Command: powershell.exe -Command \"Invoke-WebRequest -Uri https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/LICENSE.txt -OutFile C:\\Users\\Public\\license.txt\" This command starts PowerShell and uses the Invoke-WebRequest cmdlet (iwr) to download the LICENSE.txt file from the official Atomic Red Team GitHub repository and save it to the public user's directory. This action directly matches the process.name and process.command_line logic in the rule and will generate an alert.","title":"Command and Scripting Interpreter"},{"location":"rules_created/command_and_scripting_interpreter/#detection-rule-execution-via-powershell-download","text":"Rule ID: c99f9f9a-b0bd-49dc-b3af-3d837cfb64e1 Rule Name: Execution (T1059: Command and Scripting Interpreter) MITRE ATT&CK Tactic: Execution MITRE ATT&CK Technique: T1059.001, Command and Scripting Interpreter: PowerShell","title":"Detection Rule: Execution via PowerShell Download"},{"location":"rules_created/command_and_scripting_interpreter/#description","text":"This rule detects an adversary using Windows PowerShell to download a file from an external source. After gaining initial access, attackers often use this technique to retrieve their primary malware, tools, or second-stage payloads from a command-and-control (C2) server onto the compromised host. Because PowerShell is a legitimate and powerful administration tool installed on all modern Windows systems, its activity can blend in with normal operations, making it a favored tool for \"living off the land.\" An alert from this rule is a strong indicator that an active payload is being introduced into the environment.","title":"Description"},{"location":"rules_created/command_and_scripting_interpreter/#rule-derivation-from-log-analysis","text":"This rule's logic was derived by identifying the specific command-line artifacts left behind when PowerShell is used for network downloads.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/command_and_scripting_interpreter/#1-defining-the-behavior","text":"The core behavior is the execution of powershell.exe with command-line arguments that instruct it to initiate a file download from a URL.","title":"1. Defining the Behavior:"},{"location":"rules_created/command_and_scripting_interpreter/#2translating-behavior-to-log-fields","text":"This activity is captured entirely within process execution logs: The process being run is identified in the process.name field (i.e., powershell.exe). The specific download instructions are found in the process.command_line field.","title":"2.Translating Behavior to Log Fields:"},{"location":"rules_created/command_and_scripting_interpreter/#3-constructing-the-rule","text":"We identified the most common PowerShell classes, cmdlets, and aliases used for downloading files. These include the .NET class System.Net.WebClient and its methods (DownloadFile, DownloadString), as well as the native PowerShell cmdlets Invoke-WebRequest (aliased as iwr) and wget. The rule logic was then built to search for the execution of powershell.exe where any of these specific, high-fidelity strings are present in the command line.","title":"3. Constructing the Rule:"},{"location":"rules_created/command_and_scripting_interpreter/#detection-logic","text":"This is a query-based rule that triggers on a single process creation event.","title":"Detection Logic"},{"location":"rules_created/command_and_scripting_interpreter/#query","text":"process.name:powershell.exe and process.command_line:(*System.Net.WebClient* or *DownloadFile* or *DownloadString* or *iwr* or *wget*)","title":"Query:"},{"location":"rules_created/command_and_scripting_interpreter/#breakdown","text":"process.name:powershell.exe : The rule first looks for any event where the powershell.exe process is started. and : It then requires the second condition to also be true. process.command_line:(...) : The rule inspects the full command line used to launch PowerShell. It triggers if it finds any of the following keywords, which are commonly used to download files: System.Net.WebClient, DownloadFile, DownloadString: Methods from the .NET Framework for web requests. iwr: A standard alias for the Invoke-WebRequest cmdlet. wget: A common alias for the Invoke-WebRequest cmdlet, familiar to Linux users. In short, the rule alerts whenever PowerShell is launched with a command that explicitly instructs it to download content from the internet.","title":"Breakdown:"},{"location":"rules_created/command_and_scripting_interpreter/#simulation-and-validation","text":"This rule can be validated by running a simple PowerShell command to download a benign file from the internet. Atomic Red Team Test Command: powershell.exe -Command \"Invoke-WebRequest -Uri https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/LICENSE.txt -OutFile C:\\Users\\Public\\license.txt\" This command starts PowerShell and uses the Invoke-WebRequest cmdlet (iwr) to download the LICENSE.txt file from the official Atomic Red Team GitHub repository and save it to the public user's directory. This action directly matches the process.name and process.command_line logic in the rule and will generate an alert.","title":"Simulation and Validation"},{"location":"rules_created/exfiltration_over_alternative_protocol/","text":"Detection Rule: Exfiltration Over DNS Tunneling Rule ID: 21890b79-0173-4afc-a46e-338635db2a75 Rule Name: Exfiltration (T1048: Exfiltration Over Alternative Protocol) MITRE ATT&CK Tactic: Exfiltration MITRE ATT&CK Technique: T1048.003, Exfiltration Over Alternative Protocol: DNS Description Data is often stolen by transmitting it over a protocol that differs from the primary C2 channel. This rule detects DNS tunneling , a technique where an attacker encodes stolen data into a series of DNS queries. Because DNS is a fundamental network protocol and is almost always allowed through firewalls, it provides a covert channel for exfiltration. A compromised host will make an abnormally high number of DNS requests to many unique, malicious subdomains. Each query's subdomain contains a small chunk of the stolen data. This rule identifies this \"DNS storm\" behavior. Rule Derivation from Log Analysis The logic for this rule was developed by establishing a baseline for normal DNS activity and identifying the statistical anomalies created by DNS tunneling. 1. Defining the Behavior : DNS tunneling is characterized by two main factors from a single host: a very high volume of total DNS queries and a high cardinality (uniqueness) of the domains being queried. Legitimate activity may be high volume (e.g., loading a website), but the number of unique domains is typically limited. Tunneling creates hundreds of unique subdomains. 2. Translating Behavior to Log Fields : This behavior is observed in DNS logs ( event.dataset:dns ). The key fields are the source of the query ( host.hostname ) and the domain being queried ( winlog.event_data.TargetDomainName.keyword ). 3. Constructing the Rule : A simple query is insufficient. A threshold rule was built to group events by the source host. The rule then requires two conditions to be met: the total count of DNS queries from that host must exceed a high threshold (200), and the number of unique domains within those queries must also exceed a high threshold (100). This dual condition effectively isolates the unique pattern of DNS tunneling. Detection Logic This is a threshold-based rule that triggers when the volume and variety of DNS queries from a single host exceed a defined limit within the rule's time window. Query: event.category:network and event.dataset:dns Threshold: Group By : The rule groups DNS queries by the source host ( host.hostname.keyword or winlog.event_data.SourceIp.keyword ). Condition 1 (Volume) : The total number of DNS queries from a single host must be greater than or equal to 200. Condition 2 (Variety) : Within those queries, the number of unique domain names must be greater than or equal to 100. Query Explanation: The rule's logic is: \"Alert if any single host makes more than 200 DNS queries to at least 100 different domain names within a five-minute window.\" This is a strong indicator of automated data exfiltration using DNS. Simulation and Validation This rule can be validated by running a script that generates a high volume of DNS lookups for unique, non-existent subdomains. Atomic Red Team Test Command: 1..200 | ForEach-Object { $subdomain = -join ((65..90) + (97..122) | Get-Random -Count 15 | ForEach-Object { [char]$_ }); try { Resolve-DnsName -Name \"$subdomain.example.com\" -ErrorAction SilentlyContinue } catch {} } This PowerShell one-liner runs a loop 200 times. In each iteration, it generates a random 15-character string to act as a unique subdomain and performs a DNS lookup for [random_string].example.com. This activity generates 200 DNS queries for 200 unique subdomains from a single host, which will satisfy both threshold conditions and trigger the alert.","title":"Exfiltration Over Alternative Protocol"},{"location":"rules_created/exfiltration_over_alternative_protocol/#detection-rule-exfiltration-over-dns-tunneling","text":"Rule ID: 21890b79-0173-4afc-a46e-338635db2a75 Rule Name: Exfiltration (T1048: Exfiltration Over Alternative Protocol) MITRE ATT&CK Tactic: Exfiltration MITRE ATT&CK Technique: T1048.003, Exfiltration Over Alternative Protocol: DNS","title":"Detection Rule: Exfiltration Over DNS Tunneling"},{"location":"rules_created/exfiltration_over_alternative_protocol/#description","text":"Data is often stolen by transmitting it over a protocol that differs from the primary C2 channel. This rule detects DNS tunneling , a technique where an attacker encodes stolen data into a series of DNS queries. Because DNS is a fundamental network protocol and is almost always allowed through firewalls, it provides a covert channel for exfiltration. A compromised host will make an abnormally high number of DNS requests to many unique, malicious subdomains. Each query's subdomain contains a small chunk of the stolen data. This rule identifies this \"DNS storm\" behavior.","title":"Description"},{"location":"rules_created/exfiltration_over_alternative_protocol/#rule-derivation-from-log-analysis","text":"The logic for this rule was developed by establishing a baseline for normal DNS activity and identifying the statistical anomalies created by DNS tunneling.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/exfiltration_over_alternative_protocol/#1-defining-the-behavior","text":"DNS tunneling is characterized by two main factors from a single host: a very high volume of total DNS queries and a high cardinality (uniqueness) of the domains being queried. Legitimate activity may be high volume (e.g., loading a website), but the number of unique domains is typically limited. Tunneling creates hundreds of unique subdomains.","title":"1. Defining the Behavior:"},{"location":"rules_created/exfiltration_over_alternative_protocol/#2-translating-behavior-to-log-fields","text":"This behavior is observed in DNS logs ( event.dataset:dns ). The key fields are the source of the query ( host.hostname ) and the domain being queried ( winlog.event_data.TargetDomainName.keyword ).","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/exfiltration_over_alternative_protocol/#3-constructing-the-rule","text":"A simple query is insufficient. A threshold rule was built to group events by the source host. The rule then requires two conditions to be met: the total count of DNS queries from that host must exceed a high threshold (200), and the number of unique domains within those queries must also exceed a high threshold (100). This dual condition effectively isolates the unique pattern of DNS tunneling.","title":"3. Constructing the Rule:"},{"location":"rules_created/exfiltration_over_alternative_protocol/#detection-logic","text":"This is a threshold-based rule that triggers when the volume and variety of DNS queries from a single host exceed a defined limit within the rule's time window.","title":"Detection Logic"},{"location":"rules_created/exfiltration_over_alternative_protocol/#query","text":"event.category:network and event.dataset:dns","title":"Query:"},{"location":"rules_created/exfiltration_over_alternative_protocol/#threshold","text":"Group By : The rule groups DNS queries by the source host ( host.hostname.keyword or winlog.event_data.SourceIp.keyword ). Condition 1 (Volume) : The total number of DNS queries from a single host must be greater than or equal to 200. Condition 2 (Variety) : Within those queries, the number of unique domain names must be greater than or equal to 100.","title":"Threshold:"},{"location":"rules_created/exfiltration_over_alternative_protocol/#query-explanation","text":"The rule's logic is: \"Alert if any single host makes more than 200 DNS queries to at least 100 different domain names within a five-minute window.\" This is a strong indicator of automated data exfiltration using DNS.","title":"Query Explanation:"},{"location":"rules_created/exfiltration_over_alternative_protocol/#simulation-and-validation","text":"This rule can be validated by running a script that generates a high volume of DNS lookups for unique, non-existent subdomains.","title":"Simulation and Validation"},{"location":"rules_created/exfiltration_over_alternative_protocol/#atomic-red-team-test-command","text":"1..200 | ForEach-Object { $subdomain = -join ((65..90) + (97..122) | Get-Random -Count 15 | ForEach-Object { [char]$_ }); try { Resolve-DnsName -Name \"$subdomain.example.com\" -ErrorAction SilentlyContinue } catch {} } This PowerShell one-liner runs a loop 200 times. In each iteration, it generates a random 15-character string to act as a unique subdomain and performs a DNS lookup for [random_string].example.com. This activity generates 200 DNS queries for 200 unique subdomains from a single host, which will satisfy both threshold conditions and trigger the alert.","title":"Atomic Red Team Test Command:"},{"location":"rules_created/obfuscated_files_or_information/","text":"Detection Rule: Defense Evasion via Encoded PowerShell Command Rule ID: 9ddec47a-5d4c-465c-be29-ea27ce6340b8 Rule Name: Defense Evasion (T1027: Obfuscated Files or Information) MITRE ATT&CK Tactic: Defense Evasion MITRE ATT&CK Technique: T1027, Obfuscated Files or Information Description This rule detects attackers using Base64-encoded PowerShell commands to evade security software. This \"living off the land\" technique hides malicious keywords (like Invoke-Mimikatz ) from signature-based scanners by abusing a legitimate PowerShell feature. An alert from this rule indicates that an adversary is intentionally obfuscating their commands on the system.. Rule Derivation from Log Analysis The logic for this rule was derived by focusing on how an obfuscated command is executed, rather than on the content of the command itself, which is unreadable. 1. Defining the Behavior : The key behavior is the execution of powershell.exe with a specific command-line argument that instructs it to decode and then run a Base64 string. The presence of these specific arguments is the primary indicator of this evasion technique. 2. Translating Behavior to Log Fields : The required information is found entirely within process creation logs: The executed process is captured in the process.name field ( powershell.exe ). The specific switches used to handle encoded data are found in the process.args or process.command_line field. 3. Constructing the Rule : We identified all the valid switches that PowerShell uses to accept an encoded command. The full switch is -EncodedCommand , but this can be abbreviated to -enc, -en, or -e. The rule was built to look for the execution of powershell.exe where any of these four switches are present in the command line. This is a high-fidelity detection because, while legitimate administrative scripts can use this feature, it is far more common in malicious and unauthorized activity. Detection Logic This is a query-based rule that triggers on a single process creation event. Query: process.name : \"powershell.exe\" AND (process.args:\"-e\" OR process.args:\"-en\" OR process.args:\"-enc\" OR process.args:\"-encodedcommand\") Query Explanation: The query identifies events where the PowerShell interpreter is launched with arguments that specify an encoded command. The process.name : \"powershell.exe\" clause filters for events where the PowerShell process is started. The AND (...) clause provides the core logic, checking if the process arguments ( process.args ) contain any of the switches used to pass a Base64-encoded command string: -e, -en, -enc, or the full -encodedcommand. The rule triggers an alert if powershell.exe is executed with any of these specific command-line switches. Simulation and Validation This rule can be validated by encoding a simple command into Base64 and executing it using the -EncodedCommand switch. Atomic Red Team Test Command: powershell.exe -EncodedCommand dwBoAG8AYQBtAGkA This command executes PowerShell and instructs it to run an encoded command. The Base64 string dwBoAG8AYQBtAGkA decodes to the simple command whoami. The PowerShell process decodes the string and executes whoami in memory. This action, which uses powershell.exe and the -EncodedCommand switch (which can be shortened to -e, -en, or -enc ), directly matches the rule's logic and will generate an alert.","title":"Obfuscated Files or Information"},{"location":"rules_created/obfuscated_files_or_information/#detection-rule-defense-evasion-via-encoded-powershell-command","text":"Rule ID: 9ddec47a-5d4c-465c-be29-ea27ce6340b8 Rule Name: Defense Evasion (T1027: Obfuscated Files or Information) MITRE ATT&CK Tactic: Defense Evasion MITRE ATT&CK Technique: T1027, Obfuscated Files or Information","title":"Detection Rule: Defense Evasion via Encoded PowerShell Command"},{"location":"rules_created/obfuscated_files_or_information/#description","text":"This rule detects attackers using Base64-encoded PowerShell commands to evade security software. This \"living off the land\" technique hides malicious keywords (like Invoke-Mimikatz ) from signature-based scanners by abusing a legitimate PowerShell feature. An alert from this rule indicates that an adversary is intentionally obfuscating their commands on the system..","title":"Description"},{"location":"rules_created/obfuscated_files_or_information/#rule-derivation-from-log-analysis","text":"The logic for this rule was derived by focusing on how an obfuscated command is executed, rather than on the content of the command itself, which is unreadable.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/obfuscated_files_or_information/#1-defining-the-behavior","text":"The key behavior is the execution of powershell.exe with a specific command-line argument that instructs it to decode and then run a Base64 string. The presence of these specific arguments is the primary indicator of this evasion technique.","title":"1. Defining the Behavior:"},{"location":"rules_created/obfuscated_files_or_information/#2-translating-behavior-to-log-fields","text":"The required information is found entirely within process creation logs: The executed process is captured in the process.name field ( powershell.exe ). The specific switches used to handle encoded data are found in the process.args or process.command_line field.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/obfuscated_files_or_information/#3-constructing-the-rule","text":"We identified all the valid switches that PowerShell uses to accept an encoded command. The full switch is -EncodedCommand , but this can be abbreviated to -enc, -en, or -e. The rule was built to look for the execution of powershell.exe where any of these four switches are present in the command line. This is a high-fidelity detection because, while legitimate administrative scripts can use this feature, it is far more common in malicious and unauthorized activity.","title":"3. Constructing the Rule:"},{"location":"rules_created/obfuscated_files_or_information/#detection-logic","text":"This is a query-based rule that triggers on a single process creation event.","title":"Detection Logic"},{"location":"rules_created/obfuscated_files_or_information/#query","text":"process.name : \"powershell.exe\" AND (process.args:\"-e\" OR process.args:\"-en\" OR process.args:\"-enc\" OR process.args:\"-encodedcommand\")","title":"Query:"},{"location":"rules_created/obfuscated_files_or_information/#query-explanation","text":"The query identifies events where the PowerShell interpreter is launched with arguments that specify an encoded command. The process.name : \"powershell.exe\" clause filters for events where the PowerShell process is started. The AND (...) clause provides the core logic, checking if the process arguments ( process.args ) contain any of the switches used to pass a Base64-encoded command string: -e, -en, -enc, or the full -encodedcommand. The rule triggers an alert if powershell.exe is executed with any of these specific command-line switches.","title":"Query Explanation:"},{"location":"rules_created/obfuscated_files_or_information/#simulation-and-validation","text":"This rule can be validated by encoding a simple command into Base64 and executing it using the -EncodedCommand switch.","title":"Simulation and Validation"},{"location":"rules_created/obfuscated_files_or_information/#atomic-red-team-test-command","text":"powershell.exe -EncodedCommand dwBoAG8AYQBtAGkA This command executes PowerShell and instructs it to run an encoded command. The Base64 string dwBoAG8AYQBtAGkA decodes to the simple command whoami. The PowerShell process decodes the string and executes whoami in memory. This action, which uses powershell.exe and the -EncodedCommand switch (which can be shortened to -e, -en, or -enc ), directly matches the rule's logic and will generate an alert.","title":"Atomic Red Team Test Command:"},{"location":"rules_created/os_credential_dumping/","text":"Detection Rule: OS Credential Dumping via LSASS Rule ID: 49fcd163-9359-4472-8f27-47315023d94a Rule Name: Credential Access (T1003: OS Credential Dumping) MITRE ATT&CK Tactic: Credential Access MITRE ATT&CK Technique: T1003, OS Credential Dumping Description This technique involves extracting account login and credential material from the operating system's memory. Adversaries specifically target the Local Security Authority Subsystem Service (LSASS) process on Windows because it stores valuable credentials (like password hashes and Kerberos tickets) for active user sessions. By dumping the memory of the lsass.exe process, an attacker can extract these credentials and use them for lateral movement across the network. This rule is designed to detect suspicious activity targeting this critical process. Rule Derivation from Log Analysis The logic for this rule is based on identifying anomalous process creation events that masquerade as the legitimate LSASS process. 1. Defining the Behavior : The legitimate lsass.exe process is started by wininit.exe during the system boot sequence. It should never be created by another process during a normal user session. Therefore, any creation of a process named lsass.exe by an unexpected parent is a strong indicator of malicious activity, such as malware attempting to hide by impersonating a critical system process. 2. Translating Behavior to Log Fields : This behavior is captured in process creation logs, focusing on the parent-child relationship: The event type is a Process Create event. The child process name ( process.name ) is lsass.exe. The parent process name ( source.process.executable ) is the key field to inspect for anomalies. 3. Constructing the Rule : The query is constructed to specifically look for the creation of lsass.exe while excluding a shortlist of common system processes that might be false positives. Any other parent process is flagged as suspicious, providing a high-fidelity alert for this masquerading technique. Detection Logic This is a query-based rule that triggers on a single process creation event. Query: event.category:process and event.action:\"Process Create\" and process.name:lsass.exe and source.process.executable:* and not source.process.executable:(\"C:\\\\Windows\\\\System32\\\\svchost.exe\" or \"C:\\\\Windows\\\\System32\\\\services.exe\") Query Explanation: The query identifies events where a process named lsass.exe is created by an unauthorized parent process. event.category:process and event.action:\"Process Create\" : This clause filters events to only include new process creations. process.name:lsass.exe : This specifically looks for the creation of a process with the name lsass.exe. not source.process.executable:(...) : This clause excludes legitimate system processes (svchost.exe, services.exe) from being flagged as the parent, reducing potential noise. The rule triggers an alert if lsass.exe is created by any process not on the exclusion list, which is highly anomalous behavior. Simulation and Validation This rule can be validated by simulating a malware masquerading technique where a common utility is renamed to lsass.exe and executed. Atomic Red Team Test Command: copy C:\\Windows\\System32\\whoami.exe C:\\Users\\Public\\lsass.exe C:\\Users\\Public\\lsass.exe This test first copies a harmless utility, whoami.exe, to a new location and renames it to lsass.exe . When the renamed file is executed, a new process named lsass.exe is created. The parent process will be the shell that executed the command (e.g., cmd.exe or powershell.exe), which is not on the rule's exclusion list. This action directly matches the rule's logic and will generate an alert.","title":"OS Credential Dumping"},{"location":"rules_created/os_credential_dumping/#detection-rule-os-credential-dumping-via-lsass","text":"Rule ID: 49fcd163-9359-4472-8f27-47315023d94a Rule Name: Credential Access (T1003: OS Credential Dumping) MITRE ATT&CK Tactic: Credential Access MITRE ATT&CK Technique: T1003, OS Credential Dumping","title":"Detection Rule: OS Credential Dumping via LSASS"},{"location":"rules_created/os_credential_dumping/#description","text":"This technique involves extracting account login and credential material from the operating system's memory. Adversaries specifically target the Local Security Authority Subsystem Service (LSASS) process on Windows because it stores valuable credentials (like password hashes and Kerberos tickets) for active user sessions. By dumping the memory of the lsass.exe process, an attacker can extract these credentials and use them for lateral movement across the network. This rule is designed to detect suspicious activity targeting this critical process.","title":"Description"},{"location":"rules_created/os_credential_dumping/#rule-derivation-from-log-analysis","text":"The logic for this rule is based on identifying anomalous process creation events that masquerade as the legitimate LSASS process.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/os_credential_dumping/#1-defining-the-behavior","text":"The legitimate lsass.exe process is started by wininit.exe during the system boot sequence. It should never be created by another process during a normal user session. Therefore, any creation of a process named lsass.exe by an unexpected parent is a strong indicator of malicious activity, such as malware attempting to hide by impersonating a critical system process.","title":"1. Defining the Behavior:"},{"location":"rules_created/os_credential_dumping/#2-translating-behavior-to-log-fields","text":"This behavior is captured in process creation logs, focusing on the parent-child relationship: The event type is a Process Create event. The child process name ( process.name ) is lsass.exe. The parent process name ( source.process.executable ) is the key field to inspect for anomalies.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/os_credential_dumping/#3-constructing-the-rule","text":"The query is constructed to specifically look for the creation of lsass.exe while excluding a shortlist of common system processes that might be false positives. Any other parent process is flagged as suspicious, providing a high-fidelity alert for this masquerading technique.","title":"3. Constructing the Rule:"},{"location":"rules_created/os_credential_dumping/#detection-logic","text":"This is a query-based rule that triggers on a single process creation event.","title":"Detection Logic"},{"location":"rules_created/os_credential_dumping/#query","text":"event.category:process and event.action:\"Process Create\" and process.name:lsass.exe and source.process.executable:* and not source.process.executable:(\"C:\\\\Windows\\\\System32\\\\svchost.exe\" or \"C:\\\\Windows\\\\System32\\\\services.exe\")","title":"Query:"},{"location":"rules_created/os_credential_dumping/#query-explanation","text":"The query identifies events where a process named lsass.exe is created by an unauthorized parent process. event.category:process and event.action:\"Process Create\" : This clause filters events to only include new process creations. process.name:lsass.exe : This specifically looks for the creation of a process with the name lsass.exe. not source.process.executable:(...) : This clause excludes legitimate system processes (svchost.exe, services.exe) from being flagged as the parent, reducing potential noise. The rule triggers an alert if lsass.exe is created by any process not on the exclusion list, which is highly anomalous behavior.","title":"Query Explanation:"},{"location":"rules_created/os_credential_dumping/#simulation-and-validation","text":"This rule can be validated by simulating a malware masquerading technique where a common utility is renamed to lsass.exe and executed.","title":"Simulation and Validation"},{"location":"rules_created/os_credential_dumping/#atomic-red-team-test-command","text":"copy C:\\Windows\\System32\\whoami.exe C:\\Users\\Public\\lsass.exe C:\\Users\\Public\\lsass.exe This test first copies a harmless utility, whoami.exe, to a new location and renames it to lsass.exe . When the renamed file is executed, a new process named lsass.exe is created. The parent process will be the shell that executed the command (e.g., cmd.exe or powershell.exe), which is not on the rule's exclusion list. This action directly matches the rule's logic and will generate an alert.","title":"Atomic Red Team Test Command:"},{"location":"rules_created/phishing/","text":"Detection Rule: Initial Access via Phishing Rule ID: 51bac7dd-1389-4819-8812-50dc46744934 Rule Name: Initial Access (T1566: Phishing) MITRE ATT&CK Tactic: Initial Access MITRE ATT&CK Technique: T1566, Phishing Description This rule detects a common initial access pattern where a Microsoft Office application (Word, Excel, etc.) launches a command-line or scripting interpreter. This behavior is highly indicative of a successful phishing attack where a user has opened a malicious document containing embedded macros or exploits. Adversaries use this technique to gain an initial foothold on a system. The script executed by the Office application typically serves as a \"dropper\" or \"downloader\" to fetch the next stage of the malware payload from an external server. Rule Derivation from Log Analysis The logic for this rule is based on identifying anomalous parent-child process relationships. Benign usage of Microsoft Office almost never involves the direct creation of a script interpreter. 1. Defining the Behavior : The core of the attack is an Office application executing malicious code. In system process logs, this action is recorded as the Office process (e.g., winword.exe) starting a new, separate process, such as powershell.exe. The Office application is the parent, and the script interpreter is the child. 2. Translating Behavior to Log Fields : This relationship is directly observable in log data: The parent process is identified by the process.parent.name field. The child process is identified by the process.name field. 3. Constructing the Rule : The query was built to find this specific, high-fidelity malicious pattern. We created a list of common Office parent processes and a list of powerful script interpreters that are frequently abused by attackers. The rule then triggers an alert only when a process from the first list spawns a process from the second list. This specific parent-child combination is a very strong indicator of compromise. Detection Logic This is a query-based rule that triggers on a single event matching the specified process creation pattern. Query: process.parent.name:(\"winword.exe\" or \"excel.exe\" or \"powerpnt.exe\" or \"outlook.exe\") and process.name:(\"powershell.exe\" or \"cmd.exe\" or \"wscript.exe\" or \"mshta.exe\") Breakdown: process.parent.name:(...): This part of the query looks for an event where the parent (creating) process is a Microsoft Office application like Word, Excel, PowerPoint, or Outlook. and: This logical operator requires both conditions to be true. process.name:(...): This part looks for the child (created) process being a common script interpreter such as PowerShell, Command Prompt, Windows Script Host, or MSHTA (which executes HTML application files). In short, the rule alerts when an Office application is used to launch a command shell or script engine. Simulation and Validation This rule can be validated by creating a macro-enabled Microsoft Word document that executes a simple command. Atomic Red Team Test Procedure: Open Microsoft Word and create a new blank document. Press ALT + F11 to open the Visual Basic for Applications (VBA) editor. In the project window, double-click ThisDocument and paste the following code: VBA Sub AutoOpen() ` This macro will run automatically when the document is opened and macros are enabled. ` It launches PowerShell to execute the 'whoami command. CreateObject(\"WScript.Shell\").Run powershell.exe -c whoami, 0, True End Sub Save the document as a \"Word Macro-Enabled Document\" (.docm). Close and reopen the document on a monitored endpoint. When prompted, click \"Enable Content\". This action will cause winword.exe to spawn powershell.exe, which precisely matches the rule's logic and should trigger an alert.","title":"Phishing"},{"location":"rules_created/phishing/#detection-rule-initial-access-via-phishing","text":"Rule ID: 51bac7dd-1389-4819-8812-50dc46744934 Rule Name: Initial Access (T1566: Phishing) MITRE ATT&CK Tactic: Initial Access MITRE ATT&CK Technique: T1566, Phishing","title":"Detection Rule: Initial Access via Phishing"},{"location":"rules_created/phishing/#description","text":"This rule detects a common initial access pattern where a Microsoft Office application (Word, Excel, etc.) launches a command-line or scripting interpreter. This behavior is highly indicative of a successful phishing attack where a user has opened a malicious document containing embedded macros or exploits. Adversaries use this technique to gain an initial foothold on a system. The script executed by the Office application typically serves as a \"dropper\" or \"downloader\" to fetch the next stage of the malware payload from an external server.","title":"Description"},{"location":"rules_created/phishing/#rule-derivation-from-log-analysis","text":"The logic for this rule is based on identifying anomalous parent-child process relationships. Benign usage of Microsoft Office almost never involves the direct creation of a script interpreter.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/phishing/#1-defining-the-behavior","text":"The core of the attack is an Office application executing malicious code. In system process logs, this action is recorded as the Office process (e.g., winword.exe) starting a new, separate process, such as powershell.exe. The Office application is the parent, and the script interpreter is the child.","title":"1. Defining the Behavior:"},{"location":"rules_created/phishing/#2-translating-behavior-to-log-fields","text":"This relationship is directly observable in log data: The parent process is identified by the process.parent.name field. The child process is identified by the process.name field.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/phishing/#3-constructing-the-rule","text":"The query was built to find this specific, high-fidelity malicious pattern. We created a list of common Office parent processes and a list of powerful script interpreters that are frequently abused by attackers. The rule then triggers an alert only when a process from the first list spawns a process from the second list. This specific parent-child combination is a very strong indicator of compromise.","title":"3. Constructing the Rule:"},{"location":"rules_created/phishing/#detection-logic","text":"This is a query-based rule that triggers on a single event matching the specified process creation pattern.","title":"Detection Logic"},{"location":"rules_created/phishing/#query","text":"process.parent.name:(\"winword.exe\" or \"excel.exe\" or \"powerpnt.exe\" or \"outlook.exe\") and process.name:(\"powershell.exe\" or \"cmd.exe\" or \"wscript.exe\" or \"mshta.exe\")","title":"Query:"},{"location":"rules_created/phishing/#breakdown","text":"process.parent.name:(...): This part of the query looks for an event where the parent (creating) process is a Microsoft Office application like Word, Excel, PowerPoint, or Outlook. and: This logical operator requires both conditions to be true. process.name:(...): This part looks for the child (created) process being a common script interpreter such as PowerShell, Command Prompt, Windows Script Host, or MSHTA (which executes HTML application files). In short, the rule alerts when an Office application is used to launch a command shell or script engine.","title":"Breakdown:"},{"location":"rules_created/phishing/#simulation-and-validation","text":"This rule can be validated by creating a macro-enabled Microsoft Word document that executes a simple command.","title":"Simulation and Validation"},{"location":"rules_created/phishing/#atomic-red-team-test-procedure","text":"Open Microsoft Word and create a new blank document. Press ALT + F11 to open the Visual Basic for Applications (VBA) editor. In the project window, double-click ThisDocument and paste the following code: VBA Sub AutoOpen() ` This macro will run automatically when the document is opened and macros are enabled. ` It launches PowerShell to execute the 'whoami command. CreateObject(\"WScript.Shell\").Run powershell.exe -c whoami, 0, True End Sub Save the document as a \"Word Macro-Enabled Document\" (.docm). Close and reopen the document on a monitored endpoint. When prompted, click \"Enable Content\". This action will cause winword.exe to spawn powershell.exe, which precisely matches the rule's logic and should trigger an alert.","title":"Atomic Red Team Test Procedure:"},{"location":"rules_created/remote_services/","text":"Detection Rule: Lateral Movement via PsExec Rule ID: ec5fb1d6-1f59-428e-bfb0-0086cb81fded Rule Name: Lateral Movement (T1021: Remote Services) MITRE ATT&CK Tactic: Lateral Movement MITRE ATT&CK Technique: T1021.002, Remote Services: SMB/Windows Admin Shares Description Adversaries use legitimate remote access tools to move from one compromised system to another. This rule detects the use of PsExec , a common systems administration tool, for lateral movement. Because PsExec is a legitimate tool, its use can blend in with normal administrative activity. However, it is also a favorite of attackers for executing commands on remote systems. The rule specifically looks for the creation of the PSEXESVC.exe service on a host, which is the unique footprint left by PsExec during its operation. Rule Derivation from Log Analysis The logic for this rule is based on identifying the unique and predictable artifact created by PsExec on a target system. 1. Defining the Behavior : When PsExec is used to run a command on a remote machine, it first copies a service executable named PSEXESVC.exe to the SYSTEM32 directory of the target and then starts this service. The service then executes the desired command. 2. Translating Behavior to Log Fields : This behavior is captured as a process creation event in the logs of the target machine. The key field is process.name, which will be PSEXESVC.exe . 3. Constructing the Rule : The query was built to simply detect the creation of this specific process. Since PSEXESVC.exe should not be running for any other reason, its presence is a high-fidelity indicator that PsExec was used to access the machine. Detection Logic This is a query-based rule that triggers on a single process creation event. Query: event.category:process and process.name:PSEXESVC.exe Query Explanation: The query identifies the execution of the PsExec service executable. event.category:process :This clause filters events to only include process creations. and process.name:PSEXESVC.exe : This clause provides the core logic, triggering an alert if the name of the process being created is exactly PSEXESVC.exe. Simulation and Validation This rule can be validated by using PsExec from one machine to run a command on a monitored target machine. Atomic Red Team Test Command: PsExec.exe \\\\<target_machine_ip> -s cmd.exe /c \"whoami\" Description: This command uses PsExec to connect to the target machine and run the whoami command with SYSTEM (-s) privileges. This will cause the PSEXESVC.exe process to be created and run on the , which directly matches the rule's logic and will generate an alert on the target.","title":"Remote Services"},{"location":"rules_created/remote_services/#detection-rule-lateral-movement-via-psexec","text":"Rule ID: ec5fb1d6-1f59-428e-bfb0-0086cb81fded Rule Name: Lateral Movement (T1021: Remote Services) MITRE ATT&CK Tactic: Lateral Movement MITRE ATT&CK Technique: T1021.002, Remote Services: SMB/Windows Admin Shares","title":"Detection Rule: Lateral Movement via PsExec"},{"location":"rules_created/remote_services/#description","text":"Adversaries use legitimate remote access tools to move from one compromised system to another. This rule detects the use of PsExec , a common systems administration tool, for lateral movement. Because PsExec is a legitimate tool, its use can blend in with normal administrative activity. However, it is also a favorite of attackers for executing commands on remote systems. The rule specifically looks for the creation of the PSEXESVC.exe service on a host, which is the unique footprint left by PsExec during its operation.","title":"Description"},{"location":"rules_created/remote_services/#rule-derivation-from-log-analysis","text":"The logic for this rule is based on identifying the unique and predictable artifact created by PsExec on a target system.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/remote_services/#1-defining-the-behavior","text":"When PsExec is used to run a command on a remote machine, it first copies a service executable named PSEXESVC.exe to the SYSTEM32 directory of the target and then starts this service. The service then executes the desired command.","title":"1. Defining the Behavior:"},{"location":"rules_created/remote_services/#2-translating-behavior-to-log-fields","text":"This behavior is captured as a process creation event in the logs of the target machine. The key field is process.name, which will be PSEXESVC.exe .","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/remote_services/#3-constructing-the-rule","text":"The query was built to simply detect the creation of this specific process. Since PSEXESVC.exe should not be running for any other reason, its presence is a high-fidelity indicator that PsExec was used to access the machine.","title":"3. Constructing the Rule:"},{"location":"rules_created/remote_services/#detection-logic","text":"This is a query-based rule that triggers on a single process creation event.","title":"Detection Logic"},{"location":"rules_created/remote_services/#query","text":"event.category:process and process.name:PSEXESVC.exe","title":"Query:"},{"location":"rules_created/remote_services/#query-explanation","text":"The query identifies the execution of the PsExec service executable. event.category:process :This clause filters events to only include process creations. and process.name:PSEXESVC.exe : This clause provides the core logic, triggering an alert if the name of the process being created is exactly PSEXESVC.exe.","title":"Query Explanation:"},{"location":"rules_created/remote_services/#simulation-and-validation","text":"This rule can be validated by using PsExec from one machine to run a command on a monitored target machine.","title":"Simulation and Validation"},{"location":"rules_created/remote_services/#atomic-red-team-test-command","text":"PsExec.exe \\\\<target_machine_ip> -s cmd.exe /c \"whoami\"","title":"Atomic Red Team Test Command:"},{"location":"rules_created/remote_services/#description_1","text":"This command uses PsExec to connect to the target machine and run the whoami command with SYSTEM (-s) privileges. This will cause the PSEXESVC.exe process to be created and run on the , which directly matches the rule's logic and will generate an alert on the target.","title":"Description:"},{"location":"rules_created/system_information_discovery/","text":"Detection Rule: System Information Discovery Rule ID: 623df799-a310-464a-8294-15a0c7c7e1d8 Rule Name: Discovery (T1082: System Information Discovery) MITRE ATT&CK Tactic: Discovery MITRE ATT&CK Technique: T1082, System Information Discovery Description This rule detects post-compromise reconnaissance. Attackers run a series of built-in Windows utilities to gather information about the system (its identity, network, etc.) to plan their next move. While a single one of these commands is normal, a cluster of them in a short period strongly indicates an attacker is actively and manually exploring the compromised machine. Rule Derivation from Log Analysis The logic for this rule was derived by identifying a \"basket\" of legitimate Windows tools that are overwhelmingly favored by attackers for initial system reconnaissance. 1. Defining the Behavior : The goal is to detect an actor, having just landed on a machine, trying to orient themselves. They typically run a series of commands to answer basic questions: Who am I (whoami)? What is this machine (systeminfo)? What is its IP address (ipconfig)? What network connections exist (net)? What is running (tasklist)? 2. Translating Behavior to Log Fields : This behavior is captured directly in process execution logs. The key field is process.name , which records the name of the executable that was launched. 3. Constructing the Rule : The query was built as a simple list of these key discovery-related executables. The rule's core value is not in flagging a single command, but in generating alerts that can be correlated. When multiple alerts from this rule fire from the same host in a short time window, it strongly suggests a manual discovery phase of an attack. Detection Logic This is a query-based rule that triggers on a single process creation event. Query: event.category : \"process\" AND process.name : (\"whoami.exe\" OR \"systeminfo.exe\" OR \"ipconfig.exe\" OR \"net.exe\" OR \"tasklist.exe\") Query Explanation: The query identifies the execution of specific system discovery commands. event.category : \"process\" : This clause filters events to only include process creations. AND process.name : (...) : This clause triggers if the name of the process being executed is one of the following common discovery tools: whoami.exe : Displays the current user's identity. systeminfo.exe : Displays detailed OS and hardware information. ipconfig.exe : Displays the host's IP configuration. net.exe : Used for a wide range of network information gathering. tasklist.exe : Lists currently running processes. Simulation and Validation This rule can be validated by executing the targeted commands from a Command Prompt or PowerShell session. Atomic Red Team Test Command: whoami hostname systeminfo ipconfig /all netstat -an tasklist This sequence of commands mimics an attacker performing initial reconnaissance on a host. Each command execution creates a process event that matches one of the names in the rule's query ( whoami.exe, systeminfo.exe , etc.), which will generate a corresponding alert.","title":"System Information Discovery"},{"location":"rules_created/system_information_discovery/#detection-rule-system-information-discovery","text":"Rule ID: 623df799-a310-464a-8294-15a0c7c7e1d8 Rule Name: Discovery (T1082: System Information Discovery) MITRE ATT&CK Tactic: Discovery MITRE ATT&CK Technique: T1082, System Information Discovery","title":"Detection Rule: System Information Discovery"},{"location":"rules_created/system_information_discovery/#description","text":"This rule detects post-compromise reconnaissance. Attackers run a series of built-in Windows utilities to gather information about the system (its identity, network, etc.) to plan their next move. While a single one of these commands is normal, a cluster of them in a short period strongly indicates an attacker is actively and manually exploring the compromised machine.","title":"Description"},{"location":"rules_created/system_information_discovery/#rule-derivation-from-log-analysis","text":"The logic for this rule was derived by identifying a \"basket\" of legitimate Windows tools that are overwhelmingly favored by attackers for initial system reconnaissance.","title":"Rule Derivation from Log Analysis"},{"location":"rules_created/system_information_discovery/#1-defining-the-behavior","text":"The goal is to detect an actor, having just landed on a machine, trying to orient themselves. They typically run a series of commands to answer basic questions: Who am I (whoami)? What is this machine (systeminfo)? What is its IP address (ipconfig)? What network connections exist (net)? What is running (tasklist)?","title":"1. Defining the Behavior:"},{"location":"rules_created/system_information_discovery/#2-translating-behavior-to-log-fields","text":"This behavior is captured directly in process execution logs. The key field is process.name , which records the name of the executable that was launched.","title":"2. Translating Behavior to Log Fields:"},{"location":"rules_created/system_information_discovery/#3-constructing-the-rule","text":"The query was built as a simple list of these key discovery-related executables. The rule's core value is not in flagging a single command, but in generating alerts that can be correlated. When multiple alerts from this rule fire from the same host in a short time window, it strongly suggests a manual discovery phase of an attack.","title":"3. Constructing the Rule:"},{"location":"rules_created/system_information_discovery/#detection-logic","text":"This is a query-based rule that triggers on a single process creation event.","title":"Detection Logic"},{"location":"rules_created/system_information_discovery/#query","text":"event.category : \"process\" AND process.name : (\"whoami.exe\" OR \"systeminfo.exe\" OR \"ipconfig.exe\" OR \"net.exe\" OR \"tasklist.exe\")","title":"Query:"},{"location":"rules_created/system_information_discovery/#query-explanation","text":"The query identifies the execution of specific system discovery commands. event.category : \"process\" : This clause filters events to only include process creations. AND process.name : (...) : This clause triggers if the name of the process being executed is one of the following common discovery tools: whoami.exe : Displays the current user's identity. systeminfo.exe : Displays detailed OS and hardware information. ipconfig.exe : Displays the host's IP configuration. net.exe : Used for a wide range of network information gathering. tasklist.exe : Lists currently running processes.","title":"Query Explanation:"},{"location":"rules_created/system_information_discovery/#simulation-and-validation","text":"This rule can be validated by executing the targeted commands from a Command Prompt or PowerShell session.","title":"Simulation and Validation"},{"location":"rules_created/system_information_discovery/#atomic-red-team-test-command","text":"whoami hostname systeminfo ipconfig /all netstat -an tasklist This sequence of commands mimics an attacker performing initial reconnaissance on a host. Each command execution creates a process event that matches one of the names in the rule's query ( whoami.exe, systeminfo.exe , etc.), which will generate a corresponding alert.","title":"Atomic Red Team Test Command:"},{"location":"setup/art_setup/","text":"Atomic Red Team Setup and Execution Guide for Windows Introduction Atomic Red Team is an open-source library of tests mapped to the MITRE ATT&CK framework, used to safely simulate adversary behavior. This guide covers its installation and execution on a Windows VM. Prerequisites Before you begin, ensure your Windows VM meets the following requirements: Administrator Access : You must be able to run commands with administrative - privileges. PowerShell : Windows PowerShell 5.1 or later is required. This is installed by default on modern Windows versions (Windows 10/11, Server 2016+). Internet Connection : Required for the initial download and installation of the framework and atomic tests. Installation and Setup The installation process involves setting up the PowerShell execution policy, installing the framework module, and downloading the library of atomic tests. Open PowerShell as an Administrator Click the Start Menu. Type PowerShell. Right-click on Windows PowerShell and select Run as administrator. Set the PowerShell Execution Policy This command lowers the security policy for the current session to allow locally-run scripts, which is necessary to install and run the Atomic Red Team framework. In the administrative PowerShell window, run the following command: Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope CurrentUser-Force Install the Atomic Red Team PowerShell Module This command downloads and installs the core execution engine from the official PowerShell Gallery. Run the following command. When prompted to install from an untrusted repository, type Y and press Enter. Install-Module -Name AtomicRedTeam -Scope CurrentUser-Force Import the Module and Download Atomics After installing the engine, this step loads its commands into your PowerShell session and downloads the actual test files (\"atomics\") from the official GitHub repository. Run these two commands in sequence: 1. Import the module : Import-Module AtomicRedTeam 2. Download the atomic tests : Install-AtomicRedTeam -getAtomics This will download the tests to your local machine, typically into the C:\\AtomicRedTeam directory. You have now successfully installed Atomic Red Team! Executing Atomic Tests With the framework installed, you can now simulate adversary techniques. The primary command you will use is Invoke-AtomicTest. 1. List Available Tests for a Technique Before running an attack, it's best to see what specific tests are available for a given MITRE ATT&CK technique. We'll use T1059.001: Command and Scripting Interpreter: PowerShell as an example. Run the following command to see a brief list of available tests for this technique: Invoke-AtomicTest T1059.001 -ShowDetailsBrief You will see an output listing the different atomic tests available, each with a unique test number, name, and supported platform. 2. Check for Test Prerequisites Some tests require specific software or configurations to be in place before they can run. This command checks for those dependencies. Let's check the prerequisites for T1548.002: Abuse Elevation Control Mechanism: Bypass User Account Control : Invoke-AtomicTest T1548.002 -GetPrereqs If any prerequisites are missing, the framework will provide commands to help you install or configure them. 3. Run a Specific Atomic Test This is the core command that executes the simulated attack. We will run a test for T1003.001: OS Credential Dumping: LSASS Memory , which simulates an attacker dumping credentials from memory. Run the following command: Invoke-AtomicTest T1003.001 The framework will execute the test defined in the T1003.001 YAML file. You will see output describing the command being run. If you have a security tool (like Sysmon or an EDR) running, this is the action it should detect and alert on. 4. Clean Up After a Test Many tests have corresponding cleanup commands to revert any changes made to the system, such as removing created files or registry keys. To revert the changes made by the previous test (if any), run the same command with the -Cleanup flag: Invoke-AtomicTest T1003.001 -Cleanup This ensures your VM is returned to its original state.","title":"Atomic Red Team"},{"location":"setup/art_setup/#atomic-red-team-setup-and-execution-guide-for-windows","text":"","title":"Atomic Red Team Setup and Execution Guide for Windows"},{"location":"setup/art_setup/#introduction","text":"Atomic Red Team is an open-source library of tests mapped to the MITRE ATT&CK framework, used to safely simulate adversary behavior. This guide covers its installation and execution on a Windows VM.","title":"Introduction"},{"location":"setup/art_setup/#prerequisites","text":"Before you begin, ensure your Windows VM meets the following requirements: Administrator Access : You must be able to run commands with administrative - privileges. PowerShell : Windows PowerShell 5.1 or later is required. This is installed by default on modern Windows versions (Windows 10/11, Server 2016+). Internet Connection : Required for the initial download and installation of the framework and atomic tests.","title":"Prerequisites"},{"location":"setup/art_setup/#installation-and-setup","text":"The installation process involves setting up the PowerShell execution policy, installing the framework module, and downloading the library of atomic tests.","title":"Installation and Setup"},{"location":"setup/art_setup/#open-powershell-as-an-administrator","text":"Click the Start Menu. Type PowerShell. Right-click on Windows PowerShell and select Run as administrator.","title":"Open PowerShell as an Administrator"},{"location":"setup/art_setup/#set-the-powershell-execution-policy","text":"This command lowers the security policy for the current session to allow locally-run scripts, which is necessary to install and run the Atomic Red Team framework. In the administrative PowerShell window, run the following command: Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope CurrentUser-Force","title":"Set the PowerShell Execution Policy"},{"location":"setup/art_setup/#install-the-atomic-red-team-powershell-module","text":"This command downloads and installs the core execution engine from the official PowerShell Gallery. Run the following command. When prompted to install from an untrusted repository, type Y and press Enter. Install-Module -Name AtomicRedTeam -Scope CurrentUser-Force","title":"Install the Atomic Red Team PowerShell Module"},{"location":"setup/art_setup/#import-the-module-and-download-atomics","text":"After installing the engine, this step loads its commands into your PowerShell session and downloads the actual test files (\"atomics\") from the official GitHub repository. Run these two commands in sequence: 1. Import the module : Import-Module AtomicRedTeam 2. Download the atomic tests : Install-AtomicRedTeam -getAtomics This will download the tests to your local machine, typically into the C:\\AtomicRedTeam directory. You have now successfully installed Atomic Red Team!","title":"Import the Module and Download Atomics"},{"location":"setup/art_setup/#executing-atomic-tests","text":"With the framework installed, you can now simulate adversary techniques. The primary command you will use is Invoke-AtomicTest.","title":"Executing Atomic Tests"},{"location":"setup/art_setup/#1-list-available-tests-for-a-technique","text":"Before running an attack, it's best to see what specific tests are available for a given MITRE ATT&CK technique. We'll use T1059.001: Command and Scripting Interpreter: PowerShell as an example. Run the following command to see a brief list of available tests for this technique: Invoke-AtomicTest T1059.001 -ShowDetailsBrief You will see an output listing the different atomic tests available, each with a unique test number, name, and supported platform.","title":"1. List Available Tests for a Technique"},{"location":"setup/art_setup/#2-check-for-test-prerequisites","text":"Some tests require specific software or configurations to be in place before they can run. This command checks for those dependencies. Let's check the prerequisites for T1548.002: Abuse Elevation Control Mechanism: Bypass User Account Control : Invoke-AtomicTest T1548.002 -GetPrereqs If any prerequisites are missing, the framework will provide commands to help you install or configure them.","title":"2. Check for Test Prerequisites"},{"location":"setup/art_setup/#3-run-a-specific-atomic-test","text":"This is the core command that executes the simulated attack. We will run a test for T1003.001: OS Credential Dumping: LSASS Memory , which simulates an attacker dumping credentials from memory. Run the following command: Invoke-AtomicTest T1003.001 The framework will execute the test defined in the T1003.001 YAML file. You will see output describing the command being run. If you have a security tool (like Sysmon or an EDR) running, this is the action it should detect and alert on.","title":"3. Run a Specific Atomic Test"},{"location":"setup/art_setup/#4-clean-up-after-a-test","text":"Many tests have corresponding cleanup commands to revert any changes made to the system, such as removing created files or registry keys. To revert the changes made by the previous test (if any), run the same command with the -Cleanup flag: Invoke-AtomicTest T1003.001 -Cleanup This ensures your VM is returned to its original state.","title":"4. Clean Up After a Test"},{"location":"setup/elk_setup/","text":"ELK Stack Setup and Configuration Guide Introduction This document provides a detailed guide for deploying the ELK Stack \u2014 (Elasticsearch, Logstash, Kibana) \u2014 using Docker Compose . The ELK Stack is a powerful open-source platform for searching, analyzing, and visualizing log data in real-time. Components Elasticsearch : A distributed search and analytics engine. Logstash : A server-side data processing pipeline that ingests data from multiple sources, transforms it, and sends it to a \"stash\" like Elasticsearch. Kibana : A visualization layer that works on top of Elasticsearch, providing users with tools to explore their data through charts, tables, and dashboards. This guide prioritizes a secure-by-default setup, including the generation and use of passwords for all built-in users. Prerequisites: Docker and Docker Compose Installation Before you begin, you must have Docker Engine and Docker Compose installed on your system. Please follow the official instructions to download and install both components for your specific operating system. Official Documentation Project Structure For a clean setup, organize your files in a root directory (e.g., my-elk-stack) like this: my-elk-stack/ \u251c\u2500\u2500 docker-compose.yml \u2514\u2500\u2500 logstash/ \u2514\u2500\u2500 pipeline/ \u2514\u2500\u2500 logstash.conf docker-compose.yml : Defines the three services, their configurations, networks, and volumes. logstash/pipeline/logstash.conf : Contains the configuration for the Logstash pipeline. Installation and Configuration with Docker Compose Follow these steps sequentially to build and secure your stack. Create the Logstash Pipeline Configuration This file defines how Logstash receives data, what to do with it, and where to send it. Create the file logstash/pipeline/logstash.conf and add the following configuration: ./logstash/pipeline/logstash.conf input { beats { port => 5044 } tcp { port => 5000 codec => json_lines } } output { elasticsearch { hosts => [\"http://elasticsearch:9200\"] index => \"logstash-%{+YYYY.MM.dd}\" # Use environment variables for secure credential management user => \"${ELASTICSEARCH_USERNAME}\" password => \"${ELASTICSEARCH_PASSWORD}\" } } Create the Initial docker-compose.yml This file outlines the ELK services (Elasticsearch, Logstash, Kibana) without any sensitive passwords yet. Create the docker-compose.yml file in your project's root directory: ./docker-compose.yml ```yaml version: '3.8' services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:8.12.2 container_name: elasticsearch environment: - discovery.type=single-node - \"ES_JAVA_OPTS=-Xms1g -Xmx1g\" - xpack.security.enabled=true volumes: - esdata:/usr/share/elasticsearch/data ports: - \"9200:9200\" - \"9300:9300\" networks: - elknet logstash: image: docker.elastic.co/logstash/logstash:8.12.2 container_name: logstash volumes: - ./logstash/pipeline:/usr/share/logstash/pipeline:ro ports: - \"5044:5044\" - \"5000:5000/tcp\" - \"5000:5000/udp\" networks: - elknet depends_on: - elasticsearch kibana: image: docker.elastic.co/kibana/kibana:8.12.2 container_name: kibana environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 ports: - \"5601:5601\" networks: - elknet depends_on: - elasticsearch volumes: esdata: driver: local networks: elknet: driver: bridge Generate Passwords for Built-in Users This crucial security step creates unique, secure passwords for all internal ELK users. Start only the Elasticsearch container: bash docker-compose up -d elasticsearch Run the password generation script and save the output : bash docker exec -it elasticsearch /usr/share/elasticsearch/bin/elasticsearch-setup-passwords auto Stop the container: bash docker-compose down Generate a Kibana Encryption Key This key encrypts sensitive data saved within Kibana, such as alerting configurations. Generate a 32-character key using one of the commands below and save the output: Bash For Linux/macOS/WSL bash openssl rand -hex 16 Alternative command bash head /dev/urandom | tr -dc A-Za-z0-9 | head -c 32 Update docker-compose.yml with Credentials and Keys Here, you embed the generated passwords and keys into your service definitions to secure the stack. Edit your docker-compose.yml file and add the environment variables shown below. Replace the placeholder values (e.g., your_elastic_password) with the actual credentials you saved. ./docker-compose.yml (Final Version) version: '3.8' services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:8.12.2 container_name: elasticsearch environment: - discovery.type=single-node - \"ES_JAVA_OPTS=-Xms1g -Xmx1g\" - xpack.security.enabled=true # --- ADD PASSWORD FOR THE 'elastic' SUPERUSER --- - ELASTIC_PASSWORD=your_elastic_password volumes: - esdata:/usr/share/elasticsearch/data ports: - \"9200:9200\" - \"9300:9300\" networks: - elknet logstash: image: docker.elastic.co/logstash/logstash:8.12.2 container_name: logstash volumes: - ./logstash/pipeline:/usr/share/logstash/pipeline:ro ports: - \"5044:5044\" - \"5000:5000/tcp\" - \"5000:5000/udp\" # --- ADD CREDENTIALS FOR LOGSTASH TO CONNECT TO ELASTICSEARCH --- environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 - ELASTICSEARCH_USERNAME=logstash_system - ELASTICSEARCH_PASSWORD=your_logstash_system_password networks: - elknet depends_on: - elasticsearch kibana: image: docker.elastic.co/kibana/kibana:8.12.2 container_name: kibana environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 # --- ADD CREDENTIALS FOR KIBANA TO CONNECT TO ELASTICSEARCH --- - ELASTICSEARCH_USERNAME=kibana_system - ELASTICSEARCH_PASSWORD=your_kibana_system_password # --- ADD THE KIBANA ENCRYPTION KEY --- - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=your_generated_32_character_key ports: - \"5601:5601\" networks: - elknet depends_on: - elasticsearch volumes: esdata: driver: local networks: elknet: driver: bridge Launch the Full ELK Stack This command reads your final docker-compose.yml file and starts all the configured containers. bash docker-compose up -d Access Kibana This is the final step to log in and access the ELK Stack's powerful user interface. URL Username : elastic Password : The your_elastic_password you saved in Step 4.3. Post-Setup: Basic Configuration in Kibana Creating a Data View This tells Kibana which Elasticsearch index pattern to use for discovering and analyzing your data. Navigate to Stack Management > Kibana > Data Views. Click Create data view. For the Name, enter logstash-*. Select a Timestamp field (usually @timestamp). Click Create data view. Creating Visualizations and Dashboards This is where you build charts, graphs, and unified dashboards to visualize your log data. Navigate to the Visualize Library and click Create visualization. Choose a visualization type (e.g., Pie, Bar Chart) and select your logstash-* data view. Configure and save the visualization. Navigate to the Dashboard section, create a new dashboard, and add your saved visualizations from the library.","title":"ELK"},{"location":"setup/elk_setup/#elk-stack-setup-and-configuration-guide","text":"","title":"ELK Stack Setup and Configuration Guide"},{"location":"setup/elk_setup/#introduction","text":"This document provides a detailed guide for deploying the ELK Stack \u2014 (Elasticsearch, Logstash, Kibana) \u2014 using Docker Compose . The ELK Stack is a powerful open-source platform for searching, analyzing, and visualizing log data in real-time.","title":"Introduction"},{"location":"setup/elk_setup/#components","text":"Elasticsearch : A distributed search and analytics engine. Logstash : A server-side data processing pipeline that ingests data from multiple sources, transforms it, and sends it to a \"stash\" like Elasticsearch. Kibana : A visualization layer that works on top of Elasticsearch, providing users with tools to explore their data through charts, tables, and dashboards. This guide prioritizes a secure-by-default setup, including the generation and use of passwords for all built-in users.","title":"Components"},{"location":"setup/elk_setup/#prerequisites-docker-and-docker-compose-installation","text":"Before you begin, you must have Docker Engine and Docker Compose installed on your system. Please follow the official instructions to download and install both components for your specific operating system. Official Documentation","title":"Prerequisites: Docker and Docker Compose Installation"},{"location":"setup/elk_setup/#project-structure","text":"For a clean setup, organize your files in a root directory (e.g., my-elk-stack) like this: my-elk-stack/ \u251c\u2500\u2500 docker-compose.yml \u2514\u2500\u2500 logstash/ \u2514\u2500\u2500 pipeline/ \u2514\u2500\u2500 logstash.conf docker-compose.yml : Defines the three services, their configurations, networks, and volumes. logstash/pipeline/logstash.conf : Contains the configuration for the Logstash pipeline.","title":"Project Structure"},{"location":"setup/elk_setup/#installation-and-configuration-with-docker-compose","text":"Follow these steps sequentially to build and secure your stack.","title":"Installation and Configuration with Docker Compose"},{"location":"setup/elk_setup/#create-the-logstash-pipeline-configuration","text":"This file defines how Logstash receives data, what to do with it, and where to send it. Create the file logstash/pipeline/logstash.conf and add the following configuration: ./logstash/pipeline/logstash.conf input { beats { port => 5044 } tcp { port => 5000 codec => json_lines } } output { elasticsearch { hosts => [\"http://elasticsearch:9200\"] index => \"logstash-%{+YYYY.MM.dd}\" # Use environment variables for secure credential management user => \"${ELASTICSEARCH_USERNAME}\" password => \"${ELASTICSEARCH_PASSWORD}\" } }","title":"Create the Logstash Pipeline Configuration"},{"location":"setup/elk_setup/#create-the-initial-docker-composeyml","text":"This file outlines the ELK services (Elasticsearch, Logstash, Kibana) without any sensitive passwords yet. Create the docker-compose.yml file in your project's root directory: ./docker-compose.yml ```yaml version: '3.8' services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:8.12.2 container_name: elasticsearch environment: - discovery.type=single-node - \"ES_JAVA_OPTS=-Xms1g -Xmx1g\" - xpack.security.enabled=true volumes: - esdata:/usr/share/elasticsearch/data ports: - \"9200:9200\" - \"9300:9300\" networks: - elknet logstash: image: docker.elastic.co/logstash/logstash:8.12.2 container_name: logstash volumes: - ./logstash/pipeline:/usr/share/logstash/pipeline:ro ports: - \"5044:5044\" - \"5000:5000/tcp\" - \"5000:5000/udp\" networks: - elknet depends_on: - elasticsearch kibana: image: docker.elastic.co/kibana/kibana:8.12.2 container_name: kibana environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 ports: - \"5601:5601\" networks: - elknet depends_on: - elasticsearch volumes: esdata: driver: local networks: elknet: driver: bridge","title":"Create the Initial docker-compose.yml"},{"location":"setup/elk_setup/#generate-passwords-for-built-in-users","text":"This crucial security step creates unique, secure passwords for all internal ELK users. Start only the Elasticsearch container: bash docker-compose up -d elasticsearch Run the password generation script and save the output : bash docker exec -it elasticsearch /usr/share/elasticsearch/bin/elasticsearch-setup-passwords auto Stop the container: bash docker-compose down","title":"Generate Passwords for Built-in Users"},{"location":"setup/elk_setup/#generate-a-kibana-encryption-key","text":"This key encrypts sensitive data saved within Kibana, such as alerting configurations. Generate a 32-character key using one of the commands below and save the output: Bash","title":"Generate a Kibana Encryption Key"},{"location":"setup/elk_setup/#for-linuxmacoswsl","text":"bash openssl rand -hex 16","title":"For Linux/macOS/WSL"},{"location":"setup/elk_setup/#alternative-command","text":"bash head /dev/urandom | tr -dc A-Za-z0-9 | head -c 32","title":"Alternative command"},{"location":"setup/elk_setup/#update-docker-composeyml-with-credentials-and-keys","text":"Here, you embed the generated passwords and keys into your service definitions to secure the stack. Edit your docker-compose.yml file and add the environment variables shown below. Replace the placeholder values (e.g., your_elastic_password) with the actual credentials you saved. ./docker-compose.yml (Final Version) version: '3.8' services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:8.12.2 container_name: elasticsearch environment: - discovery.type=single-node - \"ES_JAVA_OPTS=-Xms1g -Xmx1g\" - xpack.security.enabled=true # --- ADD PASSWORD FOR THE 'elastic' SUPERUSER --- - ELASTIC_PASSWORD=your_elastic_password volumes: - esdata:/usr/share/elasticsearch/data ports: - \"9200:9200\" - \"9300:9300\" networks: - elknet logstash: image: docker.elastic.co/logstash/logstash:8.12.2 container_name: logstash volumes: - ./logstash/pipeline:/usr/share/logstash/pipeline:ro ports: - \"5044:5044\" - \"5000:5000/tcp\" - \"5000:5000/udp\" # --- ADD CREDENTIALS FOR LOGSTASH TO CONNECT TO ELASTICSEARCH --- environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 - ELASTICSEARCH_USERNAME=logstash_system - ELASTICSEARCH_PASSWORD=your_logstash_system_password networks: - elknet depends_on: - elasticsearch kibana: image: docker.elastic.co/kibana/kibana:8.12.2 container_name: kibana environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 # --- ADD CREDENTIALS FOR KIBANA TO CONNECT TO ELASTICSEARCH --- - ELASTICSEARCH_USERNAME=kibana_system - ELASTICSEARCH_PASSWORD=your_kibana_system_password # --- ADD THE KIBANA ENCRYPTION KEY --- - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=your_generated_32_character_key ports: - \"5601:5601\" networks: - elknet depends_on: - elasticsearch volumes: esdata: driver: local networks: elknet: driver: bridge","title":"Update docker-compose.yml with Credentials and Keys"},{"location":"setup/elk_setup/#launch-the-full-elk-stack","text":"This command reads your final docker-compose.yml file and starts all the configured containers. bash docker-compose up -d","title":"Launch the Full ELK Stack"},{"location":"setup/elk_setup/#access-kibana","text":"This is the final step to log in and access the ELK Stack's powerful user interface. URL Username : elastic Password : The your_elastic_password you saved in Step 4.3.","title":"Access Kibana"},{"location":"setup/elk_setup/#post-setup-basic-configuration-in-kibana","text":"","title":"Post-Setup: Basic Configuration in Kibana"},{"location":"setup/elk_setup/#creating-a-data-view","text":"This tells Kibana which Elasticsearch index pattern to use for discovering and analyzing your data. Navigate to Stack Management > Kibana > Data Views. Click Create data view. For the Name, enter logstash-*. Select a Timestamp field (usually @timestamp). Click Create data view.","title":"Creating a Data View"},{"location":"setup/elk_setup/#creating-visualizations-and-dashboards","text":"This is where you build charts, graphs, and unified dashboards to visualize your log data. Navigate to the Visualize Library and click Create visualization. Choose a visualization type (e.g., Pie, Bar Chart) and select your logstash-* data view. Configure and save the visualization. Navigate to the Dashboard section, create a new dashboard, and add your saved visualizations from the library.","title":"Creating Visualizations and Dashboards"},{"location":"setup/vm_setup/","text":"Environment Setup Guide This guide provides step-by-step instructions to configure the complete lab environment required for this project. Following these steps ensures that you have a functional ELK Stack ready to receive and analyze logs for threat detection. Pre-installation This phase involves gathering all the necessary software before starting the installation process. Windows 11 Disk Image (ISO) This is the operating system that will serve as our target endpoint. Description: A Windows 11 ISO file is a complete copy of the Windows 11 installation media, required by the virtual machine manager to install the OS. Instructions: Navigate to the official Microsoft Windows 11 Download page . Under the \"Download Windows 11 Disk Image (ISO)\" section, select \"Windows 11 (multi-edition ISO)\". Click \"Download\", choose your product language, and click \"Confirm\". Click the \"64-bit Download\" button to save the ISO file to your computer. VirtIO Drivers These are specialized drivers that boost the performance of your virtual machine. Description: VirtIO provides a set of high-performance drivers for virtualized hardware, such as network cards and disk controllers. Using them allows the guest OS (Windows) to communicate more efficiently with the host hypervisor (QEMU/KVM), resulting in significantly better I/O performance. Instructions: Go to the Proxmox VE Wiki for Windows VirtIO Drivers . Download the latest stable VirtIO driver ISO file. The direct link is typically named virtio-win-x.x.xxx.iso. Installation This phase covers the setup of the virtualization platform and the installation of the Windows 11 guest OS. QEMU/KVM & Virtual Machine Manager This is the software that will create and run your virtual machine. Description: QEMU is an emulator, and KVM (Kernel-based Virtual Machine) is a Linux kernel module that allows the kernel to act as a hypervisor. Together, they provide an efficient, hardware-accelerated virtualization solution. virt-manager provides a user-friendly graphical interface to manage them. Instructions: Check for Virtualization Support : Open a terminal on your Linux host and run egrep -c '(vmx|svm)' /proc/cpuinfo . A result greater than 0 means your CPU supports virtualization. Ensure it is enabled in your BIOS/UEFI. Install Packages (for Debian/Ubuntu-based systems): sudo apt update sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virt-manager Restart and Enable Services : After installation, restart, enable, and start the virtualization service. sudo systemctl restart libvirt.service sudo systemctl enable libvirt.service It is also a good practice to log out and log back in, or reboot your machine, to ensure all changes are applied. Windows 11 VM Creation and Driver Setup Now you'll create the VM and install Windows along with the performance drivers. Instructions: Launch Virtual Machine Manager ( virt-manager ) from your applications menu or terminal. Click the \"Create a new virtual machine\" icon. Select \"Local install media (ISO image or CDROM)\" and click \"Forward\". Click \"Browse Local\" and select the Windows 11 ISO you downloaded. Click \"Forward\". Allocate at least 4 GB (4096 MB) of RAM and 2 CPU cores. Click \"Forward\". Create a virtual disk of at least 64 GB. Click \"Forward\". On the final screen, check the box for \"Customize configuration before install\" and click \"Finish\". In the customization window, click \"Add Hardware\". Select \"Storage\", choose \"CDROM device\", and click \"Manage\". Click \"Browse Local\" and select the VirtIO driver ISO you downloaded. Click \"Finish\". Click \"Begin Installation\" . During the Windows setup, when you reach the \"Where do you want to install Windows?\" screen, your disk will likely not be visible. Click \"Load driver\" , then \"Browse\". Navigate to the VirtIO CD drive, find the amd64\\w11 folder inside the viostor directory, and select it. Click \"OK\". The storage driver will load, and your virtual disk will appear. You can now proceed with the Windows installation as usual. After Windows is installed and running, open File Explorer, go to the VirtIO CD drive, and run the virtio-win-guest-tools installer to install all remaining drivers automatically. Post-installation After the Windows VM is running, you will deploy and configure the security agents needed for log collection. 1. Enable Group Policy Editor ( gpedit.msc ) and Advanced Logging This tool allows you to enable detailed system auditing that isn't on by default. Description : The Group Policy Editor (gpedit.msc) is a Windows administration tool used to configure system and user settings. We will use it to enable Advanced Audit Policies that generate high-value security events, such as detailed process creation logs with command-line arguments. Note: gpedit.msc is not available on Windows Home editions, but can be enabled with a script. Instructions : 1. Enable gpedit.msc (if using Windows Home) : - Open Notepad and paste the following code: @echo off echo Checking for permissions... net session >nul 2>&1 if %errorlevel% neq 0 ( echo Administrator permissions required. echo Please run this script as an administrator. pause exit ) echo Enabling Group Policy Editor... pushd \"%~dp0\" set \"package_path=%SystemRoot%\\servicing\\Packages\" set \"search_pattern1=Microsoft-Windows-GroupPolicy-ClientTools-Package~*.mum\" set \"search_pattern2=Microsoft-Windows-GroupPolicy-ClientExtensions-Package~*.mum\" echo Searching for packages... dir /b \"%package_path%\\%search_pattern1%\" > gpedit_list.txt dir /b \"%package_path%\\%search_pattern2%\" >> gpedit_list.txt echo Installing packages... for /f %%i in ('findstr /i . gpedit_list.txt 2^>nul') do ( echo Installing %%i dism /online /norestart /add-package:\"%package_path%\\%%i\" ) echo Cleaning up... del gpedit_list.txt echo Process completed. You can now try running gpedit.msc. pause Save the file as gpedit-enabler.bat and run it as an Administrator. 2. Enable Advanced Audit Policies : Press Win + R, type gpedit.msc, and press Enter. Navigate to Computer Configuration -> Windows Settings -> Security Settings -> Advanced Audit Policy Configuration -> System Audit Policies. Go to Detailed Tracking and double-click \"Audit Process Creation\". Check the boxes for both \"Success\" and \"Failure\" and click \"OK\". This will enable logging for Event ID 4688, which includes command-line details. 2. Sysmon (System Monitor) Setup Sysmon is a powerful tool that provides deep visibility into system activity. Description : Sysmon is a free tool from Microsoft Sysinternals that monitors and logs system activity to the Windows Event Log. It provides highly detailed information about process creation, network connections, file changes, and more, which are invaluable for threat detection. Instructions : Download Sysmon from the Microsoft Sysinternals page . Download a trusted, community-vetted configuration file. The SwiftOnSecurity configuration is an excellent starting point. Download the sysmonconfig-export.xml file. Place both the Sysmon64.exe executable and the configuration file ( sysmonconfig-export.xml ) in the same directory (e.g., C:\\Sysmon ). Open PowerShell as an Administrator, navigate to the directory, and run the installation command: .\\Sysmon64.exe -accepteula -i sysmonconfig-export.xml Sysmon is now installed and actively logging events to Applications and Services Logs/Microsoft/Windows/Sysmon/Operational . 3. Winlogbeat Setup This agent will collect all your logs and send them to your analysis server. Description : Winlogbeat is a lightweight data shipper from Elastic that is installed on your Windows VM. It tails Windows event logs (including the ones generated by Sysmon), and forwards them to a central Logstash or Elasticsearch server for analysis and visualization. Instructions : Download Winlogbeat from the Elastic downloads page . Unzip the file to a location like C:\\Program Files\\Winlogbeat . Navigate to the Winlogbeat directory and open the winlogbeat.yml configuration file in a text editor like Notepad++. Configure the input: Ensure Winlogbeat collects the Sysmon logs. winlogbeat.event_logs: - name: Application - name: Security - name: System - name: Microsoft-Windows-Sysmon/Operational ignore_older: 72h Configure the output: Point it to your Logstash or Elasticsearch instance. Replace the IP address accordingly. output.logstash: hosts: [\"192.168.1.100:5044\"] Example for Elasticsearch (comment out the Logstash section if using this) output.elasticsearch: hosts: [\"192.168.1.100:9200\"] Save the winlogbeat.yml file. Open PowerShell as an Administrator, navigate to the Winlogbeat directory, and run the following scripts to install and start the service: .\\install-service-winlogbeat.ps1 Start-Service winlogbeat Winlogbeat is now running as a service and forwarding logs from your Windows 11 VM.","title":"Virtual Machine"},{"location":"setup/vm_setup/#environment-setup-guide","text":"This guide provides step-by-step instructions to configure the complete lab environment required for this project. Following these steps ensures that you have a functional ELK Stack ready to receive and analyze logs for threat detection.","title":"Environment Setup Guide"},{"location":"setup/vm_setup/#pre-installation","text":"This phase involves gathering all the necessary software before starting the installation process.","title":"Pre-installation"},{"location":"setup/vm_setup/#windows-11-disk-image-iso","text":"This is the operating system that will serve as our target endpoint.","title":"Windows 11 Disk Image (ISO)"},{"location":"setup/vm_setup/#description","text":"A Windows 11 ISO file is a complete copy of the Windows 11 installation media, required by the virtual machine manager to install the OS.","title":"Description:"},{"location":"setup/vm_setup/#instructions","text":"Navigate to the official Microsoft Windows 11 Download page . Under the \"Download Windows 11 Disk Image (ISO)\" section, select \"Windows 11 (multi-edition ISO)\". Click \"Download\", choose your product language, and click \"Confirm\". Click the \"64-bit Download\" button to save the ISO file to your computer.","title":"Instructions:"},{"location":"setup/vm_setup/#virtio-drivers","text":"These are specialized drivers that boost the performance of your virtual machine.","title":"VirtIO Drivers"},{"location":"setup/vm_setup/#description_1","text":"VirtIO provides a set of high-performance drivers for virtualized hardware, such as network cards and disk controllers. Using them allows the guest OS (Windows) to communicate more efficiently with the host hypervisor (QEMU/KVM), resulting in significantly better I/O performance.","title":"Description:"},{"location":"setup/vm_setup/#instructions_1","text":"Go to the Proxmox VE Wiki for Windows VirtIO Drivers . Download the latest stable VirtIO driver ISO file. The direct link is typically named virtio-win-x.x.xxx.iso.","title":"Instructions:"},{"location":"setup/vm_setup/#installation","text":"This phase covers the setup of the virtualization platform and the installation of the Windows 11 guest OS.","title":"Installation"},{"location":"setup/vm_setup/#qemukvm-virtual-machine-manager","text":"This is the software that will create and run your virtual machine.","title":"QEMU/KVM &amp; Virtual Machine Manager"},{"location":"setup/vm_setup/#description_2","text":"QEMU is an emulator, and KVM (Kernel-based Virtual Machine) is a Linux kernel module that allows the kernel to act as a hypervisor. Together, they provide an efficient, hardware-accelerated virtualization solution. virt-manager provides a user-friendly graphical interface to manage them.","title":"Description:"},{"location":"setup/vm_setup/#instructions_2","text":"Check for Virtualization Support : Open a terminal on your Linux host and run egrep -c '(vmx|svm)' /proc/cpuinfo . A result greater than 0 means your CPU supports virtualization. Ensure it is enabled in your BIOS/UEFI. Install Packages (for Debian/Ubuntu-based systems): sudo apt update sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virt-manager Restart and Enable Services : After installation, restart, enable, and start the virtualization service. sudo systemctl restart libvirt.service sudo systemctl enable libvirt.service It is also a good practice to log out and log back in, or reboot your machine, to ensure all changes are applied.","title":"Instructions:"},{"location":"setup/vm_setup/#windows-11-vm-creation-and-driver-setup","text":"Now you'll create the VM and install Windows along with the performance drivers.","title":"Windows 11 VM Creation and Driver Setup"},{"location":"setup/vm_setup/#instructions_3","text":"Launch Virtual Machine Manager ( virt-manager ) from your applications menu or terminal. Click the \"Create a new virtual machine\" icon. Select \"Local install media (ISO image or CDROM)\" and click \"Forward\". Click \"Browse Local\" and select the Windows 11 ISO you downloaded. Click \"Forward\". Allocate at least 4 GB (4096 MB) of RAM and 2 CPU cores. Click \"Forward\". Create a virtual disk of at least 64 GB. Click \"Forward\". On the final screen, check the box for \"Customize configuration before install\" and click \"Finish\". In the customization window, click \"Add Hardware\". Select \"Storage\", choose \"CDROM device\", and click \"Manage\". Click \"Browse Local\" and select the VirtIO driver ISO you downloaded. Click \"Finish\". Click \"Begin Installation\" . During the Windows setup, when you reach the \"Where do you want to install Windows?\" screen, your disk will likely not be visible. Click \"Load driver\" , then \"Browse\". Navigate to the VirtIO CD drive, find the amd64\\w11 folder inside the viostor directory, and select it. Click \"OK\". The storage driver will load, and your virtual disk will appear. You can now proceed with the Windows installation as usual. After Windows is installed and running, open File Explorer, go to the VirtIO CD drive, and run the virtio-win-guest-tools installer to install all remaining drivers automatically.","title":"Instructions:"},{"location":"setup/vm_setup/#post-installation","text":"After the Windows VM is running, you will deploy and configure the security agents needed for log collection.","title":"Post-installation"},{"location":"setup/vm_setup/#1-enable-group-policy-editor-gpeditmsc-and-advanced-logging","text":"This tool allows you to enable detailed system auditing that isn't on by default. Description : The Group Policy Editor (gpedit.msc) is a Windows administration tool used to configure system and user settings. We will use it to enable Advanced Audit Policies that generate high-value security events, such as detailed process creation logs with command-line arguments. Note: gpedit.msc is not available on Windows Home editions, but can be enabled with a script. Instructions : 1. Enable gpedit.msc (if using Windows Home) : - Open Notepad and paste the following code: @echo off echo Checking for permissions... net session >nul 2>&1 if %errorlevel% neq 0 ( echo Administrator permissions required. echo Please run this script as an administrator. pause exit ) echo Enabling Group Policy Editor... pushd \"%~dp0\" set \"package_path=%SystemRoot%\\servicing\\Packages\" set \"search_pattern1=Microsoft-Windows-GroupPolicy-ClientTools-Package~*.mum\" set \"search_pattern2=Microsoft-Windows-GroupPolicy-ClientExtensions-Package~*.mum\" echo Searching for packages... dir /b \"%package_path%\\%search_pattern1%\" > gpedit_list.txt dir /b \"%package_path%\\%search_pattern2%\" >> gpedit_list.txt echo Installing packages... for /f %%i in ('findstr /i . gpedit_list.txt 2^>nul') do ( echo Installing %%i dism /online /norestart /add-package:\"%package_path%\\%%i\" ) echo Cleaning up... del gpedit_list.txt echo Process completed. You can now try running gpedit.msc. pause Save the file as gpedit-enabler.bat and run it as an Administrator. 2. Enable Advanced Audit Policies : Press Win + R, type gpedit.msc, and press Enter. Navigate to Computer Configuration -> Windows Settings -> Security Settings -> Advanced Audit Policy Configuration -> System Audit Policies. Go to Detailed Tracking and double-click \"Audit Process Creation\". Check the boxes for both \"Success\" and \"Failure\" and click \"OK\". This will enable logging for Event ID 4688, which includes command-line details.","title":"1. Enable Group Policy Editor (gpedit.msc) and Advanced Logging"},{"location":"setup/vm_setup/#2-sysmon-system-monitor-setup","text":"Sysmon is a powerful tool that provides deep visibility into system activity. Description : Sysmon is a free tool from Microsoft Sysinternals that monitors and logs system activity to the Windows Event Log. It provides highly detailed information about process creation, network connections, file changes, and more, which are invaluable for threat detection. Instructions : Download Sysmon from the Microsoft Sysinternals page . Download a trusted, community-vetted configuration file. The SwiftOnSecurity configuration is an excellent starting point. Download the sysmonconfig-export.xml file. Place both the Sysmon64.exe executable and the configuration file ( sysmonconfig-export.xml ) in the same directory (e.g., C:\\Sysmon ). Open PowerShell as an Administrator, navigate to the directory, and run the installation command: .\\Sysmon64.exe -accepteula -i sysmonconfig-export.xml Sysmon is now installed and actively logging events to Applications and Services Logs/Microsoft/Windows/Sysmon/Operational .","title":"2. Sysmon (System Monitor) Setup"},{"location":"setup/vm_setup/#3-winlogbeat-setup","text":"This agent will collect all your logs and send them to your analysis server. Description : Winlogbeat is a lightweight data shipper from Elastic that is installed on your Windows VM. It tails Windows event logs (including the ones generated by Sysmon), and forwards them to a central Logstash or Elasticsearch server for analysis and visualization. Instructions : Download Winlogbeat from the Elastic downloads page . Unzip the file to a location like C:\\Program Files\\Winlogbeat . Navigate to the Winlogbeat directory and open the winlogbeat.yml configuration file in a text editor like Notepad++. Configure the input: Ensure Winlogbeat collects the Sysmon logs. winlogbeat.event_logs: - name: Application - name: Security - name: System - name: Microsoft-Windows-Sysmon/Operational ignore_older: 72h Configure the output: Point it to your Logstash or Elasticsearch instance. Replace the IP address accordingly. output.logstash: hosts: [\"192.168.1.100:5044\"] Example for Elasticsearch (comment out the Logstash section if using this) output.elasticsearch: hosts: [\"192.168.1.100:9200\"] Save the winlogbeat.yml file. Open PowerShell as an Administrator, navigate to the Winlogbeat directory, and run the following scripts to install and start the service: .\\install-service-winlogbeat.ps1 Start-Service winlogbeat Winlogbeat is now running as a service and forwarding logs from your Windows 11 VM.","title":"3. Winlogbeat Setup"}]}